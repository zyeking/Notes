{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Mysite","text_tokens":["to"," ","mysite","welcome"],"title":"index","title_tokens":["index"]},{"location":"#welcome-to-mysite","text":"","text_tokens":[],"title":"Welcome to Mysite","title_tokens":["to"," ","mysite","welcome"]},{"location":"Docker/01 ChangeImageSource/","text":"Docker 01：修改镜像源 在 settings -> Daemon -> Advanced 在 registry-mirrors 括号内添加 \"https://registry.docker-cn.com\" docker info 查询 registry-mirrors","text_tokens":[".","registry","docker","在","-","镜像","源","daemon","mirrors","01","查询","括号","https","com","/","：","cn","添加","\"","修改",":","settings",">","advanced","info","内"," "],"title":"Docker 01：修改镜像源","title_tokens":["源","修改","01","docker","："," ","镜像"]},{"location":"Docker/01 ChangeImageSource/#docker-01","text":"在 settings -> Daemon -> Advanced 在 registry-mirrors 括号内添加 \"https://registry.docker-cn.com\" docker info 查询 registry-mirrors","text_tokens":[".","registry","docker","在","-","daemon","mirrors","查询","括号","https","com","/","cn","添加","\"",":","settings",">","advanced","info","内"," "],"title":"Docker 01：修改镜像源","title_tokens":["源","修改","01","docker","："," ","镜像"]},{"location":"Docker/02 EntryPointAndCMD/","text":"Docker 02：Dockerfile中的ENTRYPOINT、RUN与CMD CMD与ENRTYPOINT RUN CMD 每个 Dockerfile 中只能有一个 CMD , 如果有多个那么只会执行最后一个. CMD 相当于启动 docker 时候后面添加的参数: docker run -itd --name aaa docker_image /bin/bash -c. 镜像名称后面跟了 /bin/bash -c 等价于在dockerfile中的 CMD [\"/bin/bash\", \"-c\"] 若执行的时候添加了参数,默认的 CMD 中的参数则无效 ENTRYPOINT 类似 CMD , 每个 Dockerfile 只能有一个 ENTRYPOINT , 如果存在多个只执行最后一个. 必定执行, 不会动态改变 书写格式 Shell格式： , 例如: apt-get install python3 Exec [\"executable\", \"param1\", \"param2\", ...], 例如: [\"apt-get\", \"install\", \"python3\"] CMD命令 CMD echo \"hello world\" 1. 运行 docker run -it [image] , 输出hello world 2. 运行 docker run -it [image]/bin/bash , CMD 命令会被忽略, 命令 bash 会被执行 ENTRYPOINT ENTRYPOINT [\"/bin/echo\", \"Hello\"] 1. 运行 docker run -it [image] , 输出Hello 2. 运行 docker run -it [image] kk , 输出Hello kk, 原本的Hello仍然会输出 修改 Dockerfile 为 ENTRYPOINT [ \"/bin/echo\" , \"Hello\" ] CMD [ \"world\" ] 1. 运行 docker run -it [name] , 输出Hello world 2. 运行 docker run -it [name] king , 输出Hello king, CMD 参数被动态替换. RUN命令 RUN apt-get update && apt-get install -y \\ bzr \\ cvs \\ git \\ mercurial \\ subversion 1. apt-get update 和 apt-get install 放在同一个 RUN 指令执行可以==保证每次安装的都是最新的包==; 如果将 apt-get install 放在单独的的 RUN 中执行, 则会使用 apt-get update 创建的镜像层, 这层镜像可能是很久以前缓存的. 总结 CMD 设置容器启动后==默认执行的命令以及参数==, 设置的指令可以被 docker run 命令后面的命令函参数==动态替换== ENTRYPOINT 配置容器启动时的执行命令, 不会被忽略, 一定会被执行 , 即使运行了 docker run 时指定了其他命令 使用 RUN 指令安装应用和软件包，构建镜像。 如果 Docker 镜像的用途是运行应用程序或服务, 比如运行一个 MySQL, 应该优先使用 Exec 格式的 ENTRYPOINT 指令. CMD 可为 ENTRYPOINT 提供额外的默认参数, 同时可利用 docker run 命令行替换默认参数. 如果想为容器设置默认的启动命令,可使用 CMD 指令.用户可在 docker run 命令行中替换此默认命令. REF: Dockerfile RUN，CMD，ENTRYPOINT命令区别 Dockerfile中ENTRYPOINT 和 CMD的区别","text_tokens":["原本","_","缓存","包","都","docker","只会","可以","总结","同时","executable","=","书写","subversion","...","于","函","镜像","aaa","y","执行命令","与","以前","可能","有","\\","例如","同一个","配置","此","，","了","软件","it","创建","最后","mercurial","安装","参数","bzr","容器","比如","放在","名称","修改","1","构建","可","很久","想","启动","改变","和","运行","相当","中",".","run","apt","dockerfile","跟","默认","-","hello","最新","存在","这层","输出","exec","同一","那么","是","python3","替换","时候","。","enrtypoint",",","设置","软件包","或","单独","ref","/","提供","]","被","添加","当于",";","\"","多个","很久以前","执行","用户","应该","为","将"," ","不会","命令","指令","cvs","额外","时","后","在","用途","2","cmd","格式","git","、","bash","若","mysql","一定","install","每次","以及","必定","如果","应用","无效","shell","kk","服务","利用","则","使用","优先","entrypoint","忽略","param1","每个","只能","仍然","的","02","&&","指定","等价","保证","update","image","相当于","[","即使","itd","bin","c","层","后面","echo","动态","命令行","其他","：","一个","类似","区别","只",":","world","param2","会","应用程序","get","king","程序","name"],"title":"Docker 02：Dockerfile中的ENTRYPOINT、RUN与CMD","title_tokens":["entrypoint","、","的","与","docker","run","dockerfile","："," ","02","cmd","中"]},{"location":"Docker/02 EntryPointAndCMD/#docker-02dockerfileentrypointruncmd","text":"","text_tokens":[],"title":"Docker 02：Dockerfile中的ENTRYPOINT、RUN与CMD","title_tokens":["entrypoint","、","的","与","docker","run","dockerfile","："," ","02","cmd","中"]},{"location":"Docker/02 EntryPointAndCMD/#cmdenrtypoint","text":"RUN CMD 每个 Dockerfile 中只能有一个 CMD , 如果有多个那么只会执行最后一个. CMD 相当于启动 docker 时候后面添加的参数: docker run -itd --name aaa docker_image /bin/bash -c. 镜像名称后面跟了 /bin/bash -c 等价于在dockerfile中的 CMD [\"/bin/bash\", \"-c\"] 若执行的时候添加了参数,默认的 CMD 中的参数则无效 ENTRYPOINT 类似 CMD , 每个 Dockerfile 只能有一个 ENTRYPOINT , 如果存在多个只执行最后一个. 必定执行, 不会动态改变","text_tokens":[".","_","的","run","docker","等价","只会","image","相当于","在","dockerfile","跟","于","-","[","镜像","cmd","itd","aaa","bin","默认","bash","若","c","存在","必定","如果","有","后面","无效","那么","时候","不会",",","name","了","/","动态","最后","]","参数","一个","则","添加","类似","当于","entrypoint","\"","名称","多个","只",":","执行","每个","启动","只能","改变"," ","相当","中"],"title":"CMD与ENRTYPOINT","title_tokens":["与","enrtypoint","cmd"]},{"location":"Docker/02 EntryPointAndCMD/#_1","text":"Shell格式： , 例如: apt-get install python3 Exec [\"executable\", \"param1\", \"param2\", ...], 例如: [\"apt-get\", \"install\", \"python3\"]","text_tokens":["apt","executable","...","-","[","格式","install","exec","shell","例如","python3",",","]","：","\"","param1",":","param2","get"," "],"title":"书写格式","title_tokens":["书写","格式"]},{"location":"Docker/02 EntryPointAndCMD/#cmd","text":"CMD echo \"hello world\" 1. 运行 docker run -it [image] , 输出hello world 2. 运行 docker run -it [image]/bin/bash , CMD 命令会被忽略, 命令 bash 会被执行","text_tokens":[".","docker","run","image","2","-","[","hello","cmd","bin","bash","输出",",","echo","/","it","]","被","忽略","\"","1","world","执行","会","运行"," ","命令"],"title":"CMD命令","title_tokens":["命令","cmd"]},{"location":"Docker/02 EntryPointAndCMD/#entrypoint","text":"ENTRYPOINT [\"/bin/echo\", \"Hello\"] 1. 运行 docker run -it [image] , 输出Hello 2. 运行 docker run -it [image] kk , 输出Hello kk, 原本的Hello仍然会输出 修改 Dockerfile 为 ENTRYPOINT [ \"/bin/echo\" , \"Hello\" ] CMD [ \"world\" ] 1. 运行 docker run -it [name] , 输出Hello world 2. 运行 docker run -it [name] king , 输出Hello king, CMD 参数被动态替换.","text_tokens":[".","原本","的","docker","run","image","dockerfile","hello","-","[","2","cmd","bin","输出","kk","替换",",","echo","/","it","动态","]","被","参数","entrypoint","\"","修改","1","world","会","为","仍然","king","运行"," ","name"],"title":"ENTRYPOINT","title_tokens":["entrypoint"]},{"location":"Docker/02 EntryPointAndCMD/#run","text":"RUN apt-get update && apt-get install -y \\ bzr \\ cvs \\ git \\ mercurial \\ subversion 1. apt-get update 和 apt-get install 放在同一个 RUN 指令执行可以==保证每次安装的都是最新的包==; 如果将 apt-get install 放在单独的的 RUN 中执行, 则会使用 apt-get update 创建的镜像层, 这层镜像可能是很久以前缓存的.","text_tokens":[".","缓存","的","包","都","run","保证","指令","cvs","可以","update","apt","=","subversion","-","镜像","y","git","最新","将","install","每次","以前","这层","如果","层","可能","同一","\\","是","同一个",",","单独","创建","mercurial","安装","一个","则","bzr","使用",";","放在","很久以前","1","执行","很久","会","get","和"," ","&&","中"],"title":"RUN命令","title_tokens":["run","命令"]},{"location":"Docker/02 EntryPointAndCMD/#_2","text":"CMD 设置容器启动后==默认执行的命令以及参数==, 设置的指令可以被 docker run 命令后面的命令函参数==动态替换== ENTRYPOINT 配置容器启动时的执行命令, 不会被忽略, 一定会被执行 , 即使运行了 docker run 时指定了其他命令 使用 RUN 指令安装应用和软件包，构建镜像。 如果 Docker 镜像的用途是运行应用程序或服务, 比如运行一个 MySQL, 应该优先使用 Exec 格式的 ENTRYPOINT 指令. CMD 可为 ENTRYPOINT 提供额外的默认参数, 同时可利用 docker run 命令行替换默认参数. 如果想为容器设置默认的启动命令,可使用 CMD 指令.用户可在 docker run 命令行中替换此默认命令.","text_tokens":[".","指定","docker","run","指令","可以","额外","时","同时","=","后","在","函","默认","用途","即使","镜像","cmd"," ","执行命令","格式","mysql","一定","以及","如果","后面","exec","应用","是","服务","替换","配置","不会","。","此",",","设置","软件包","，","或","了","软件","利用","动态","提供","命令行","安装","其他","被","参数","一个","使用","优先","容器","entrypoint","忽略","比如","构建","可","执行","想","会","应该","用户","启动","应用程序","为","程序","和","运行","的","命令","中"],"title":"总结","title_tokens":["总结"]},{"location":"Docker/02 EntryPointAndCMD/#ref","text":"Dockerfile RUN，CMD，ENTRYPOINT命令区别 Dockerfile中ENTRYPOINT 和 CMD的区别","text_tokens":["entrypoint","，","的","run","命令","中","dockerfile","和"," ","cmd","区别"],"title":"REF:","title_tokens":["ref",":"]},{"location":"Docker/03 Docker-Compose/","text":"Docker-Compose快速入门 什么是Docker Compose? 用于定义和运行多容器Docker应用程序的工具，通过Compose使用YAML文件配置应用程序需要的所有服务。实现使用一个命令就能够从YAML文件配置中创建并启动所有服务。 使用步骤 使用Dockerfile定义应用程序环境 在 docker-compose.yml 中搭建应用程序所需的服务 执行 docker-compose up 运行整个应用程序 示例 # composetest/app.py import time import redis from flask import Flask app = Flask ( __name__ ) # 通过redis缓存 cache = redis . Redis ( host = 'redis' , port = 6379 ) def get_hit_count (): retries = 5 while True : try : return cache . incr ( 'hits' ) except redis . exceptions . ConnectionError as exc : if retries == 0 : raise exc retries -= 1 time . sleep ( 0.5 ) @app.route ( '/' ) def hello (): count = get_hit_count () return 'Hello World! I have been seen {} times. \\n ' . format ( count ) 创建 composetest/requirements.txt 文件 flask redis 创建 composetest/Dockerfile 文件定义 app.py 的环境 # 从python3.7 alpine镜像开始构建 FROM python:3.7-alpine # 设置工作目录 WORKDIR /code # 设置flask命令使用的环境变量 ENV FLASK_APP app.py ENV FLASK_RUN_HOST 0 .0.0.0 # 安装gcc RUN apk add --no-cache gcc musl-dev linux-headers # 复制requirements.txt并且安装依赖 COPY requirements.txt requirements.txt # 执行pip RUN pip install -r requirements.txt # 将当前项目复制到镜像中的工作目录 COPY . . # 设置容器默认的执行命令 CMD [ \"flask\" , \"run\" ] 创建 composetest/docker-compose.yml 文件指定应用程序所需的服务 # yaml 配置 # compose版本 version : '3' services : web : # 构建镜像的上下文路径: ./Dockerfile build : . # 对外映射的端口 ports : - \"5000:5000\" redis : image : \"redis:alpine\" # 定义了两个service,分别是web和redis # web 服务使用从Dockerfile 当前目录中构建的镜像 使用Compose命令运行 docker-compose up -d yml配置 version : \"3.7\" services : webapp : build : context : ./dir dockerfile : Dockerfile-alternate args : buildno : 1 labels : - \"com.example.description=Accounting webapp\" - \"com.example.department=Finance\" - \"com.example.label-with-empty-value\" target : prod container_name : my-web-container command : [ \"bundle\" , \"exec\" , \"thin\" , \"-p\" , \"3000\" ] context：指定Dockerfile的上下文路径 dockerfile：指定构建镜像的Dockerfile文件名 labels：设置构建镜像的标签 container_name：设置容器名称 command：覆盖容器启动的默认指令 依赖关系 version : \"3.7\" services : web : build : . depends_on : - db - redis redis : image : redis db : image : postgres docker-compose up：根据依赖关系启动服务，先启动db，redis再启动web docker-compose stop：根据依赖关系廷式服务，先关闭web，再关闭db和redis docker-compose up SERVICE：自动包含SERVICE的依赖项，通过 docker-compose up 还将创建并启动db，redis 挂载 version : '3' services : app : image : golang:latest volumes : # 将项目代码根目录映射到容器中的相关目录 - $PWD : /go/src/example/demo ports : - \"8000:8000\" # 执行go run command : go run /go/src/example/demo/main.go 环境变量 布尔值需要用引号，确保YML解析器不会将其转换为True/False environment : RACK_ENV : development SHOW : 'true' Ref: docker-compose快速入门","text_tokens":["缓存","_","volumes","复制","docker","复制到","flask","分别","路径","=","label","requirements","开始","上下文","镜像","当前目录","代码","执行命令","(","copy","依赖","import","true","composetest","并且","所","stop","其","需要","\\","关闭","配置","prod","步骤","3000","，","了","py","com","布尔值","service","创建","code","@","安装","$","def","as","dev","用","show","多","容器","yaml","就","名称","整个","compose","return","0","context","从","1","构建","环境变量","启动","标签","变量","和","运行","demo","my","linux","中","先",".","python3.7","description","到","确保","用于","run","buildno","thin","have","上下","development","up","build","n","所有","dockerfile","引号","hello","-","默认","rack","with","d","工具","文件","services","apk","env","web","exec","是","0.0","golang","while","。",",","设置","department","{","/","ref","main","empty","]","两个","target","python","\"","示例","no","3.7","映射","environment","执行","并","headers","pip","hits","文件名","项","为","db","musl","解析器","将"," ","}","不会","host","命令","当前","目录","go","通过","指令","on","还","什么","example","retries","sleep","在","command","bundle","raise","再启动","相关","入门","yml","cmd","r","版本","count","app","廷式","install","accounting","been","应用","ports","args","服务","?","快速","route","workdir","覆盖","布尔","value","再","alternate","自动","gcc","port","5000","挂载","工作","使用","add","项目","cache","webapp","seen","p","incr","'","实现","环境","端口","labels","time","depends","根据","8000","__","的","能够","6379","指定","container","image","dir","定义","txt","[","version","exceptions","对外","alpine","from","根目录","pwd","try","包含","下文","需","5","环境变","postgres","!","关系","src","解析","转换","exc","一个",")","：","false","format","hit","i",":","finance","except","if","redis","world","times","latest","搭建","应用程序","#","3","get","程序","connectionerror","0.5","name"],"title":"Docker-Compose快速入门","title_tokens":["compose","快速","docker","-","入门"]},{"location":"Docker/03 Docker-Compose/#docker-compose","text":"","text_tokens":[],"title":"Docker-Compose快速入门","title_tokens":["compose","快速","docker","-","入门"]},{"location":"Docker/03 Docker-Compose/#docker-compose_1","text":"用于定义和运行多容器Docker应用程序的工具，通过Compose使用YAML文件配置应用程序需要的所有服务。实现使用一个命令就能够从YAML文件配置中创建并启动所有服务。","text_tokens":["能够","用于","docker","通过","定义","所有","工具","文件","应用","需要","服务","配置","。","，","创建","一个","使用","多","容器","yaml","就","compose","从","并","实现","应用程序","启动","程序","和","运行","的","命令","中"],"title":"什么是Docker Compose?","title_tokens":["compose","?","docker","什么","是"," "]},{"location":"Docker/03 Docker-Compose/#_1","text":"使用Dockerfile定义应用程序环境 在 docker-compose.yml 中搭建应用程序所需的服务 执行 docker-compose up 运行整个应用程序","text_tokens":[".","docker","up","在","定义","dockerfile","-","yml"," ","所","应用","服务","使用","整个","compose","执行","环境","搭建","应用程序","程序","需","运行","的","中"],"title":"使用步骤","title_tokens":["步骤","使用"]},{"location":"Docker/03 Docker-Compose/#_2","text":"# composetest/app.py import time import redis from flask import Flask app = Flask ( __name__ ) # 通过redis缓存 cache = redis . Redis ( host = 'redis' , port = 6379 ) def get_hit_count (): retries = 5 while True : try : return cache . incr ( 'hits' ) except redis . exceptions . ConnectionError as exc : if retries == 0 : raise exc retries -= 1 time . sleep ( 0.5 ) @app.route ( '/' ) def hello (): count = get_hit_count () return 'Hello World! I have been seen {} times. \\n ' . format ( count ) 创建 composetest/requirements.txt 文件 flask redis 创建 composetest/Dockerfile 文件定义 app.py 的环境 # 从python3.7 alpine镜像开始构建 FROM python:3.7-alpine # 设置工作目录 WORKDIR /code # 设置flask命令使用的环境变量 ENV FLASK_APP app.py ENV FLASK_RUN_HOST 0 .0.0.0 # 安装gcc RUN apk add --no-cache gcc musl-dev linux-headers # 复制requirements.txt并且安装依赖 COPY requirements.txt requirements.txt # 执行pip RUN pip install -r requirements.txt # 将当前项目复制到镜像中的工作目录 COPY . . # 设置容器默认的执行命令 CMD [ \"flask\" , \"run\" ] 创建 composetest/docker-compose.yml 文件指定应用程序所需的服务 # yaml 配置 # compose版本 version : '3' services : web : # 构建镜像的上下文路径: ./Dockerfile build : . # 对外映射的端口 ports : - \"5000:5000\" redis : image : \"redis:alpine\" # 定义了两个service,分别是web和redis # web 服务使用从Dockerfile 当前目录中构建的镜像 使用Compose命令运行 docker-compose up -d","text_tokens":["缓存","_","复制","复制到","docker","flask","分别","路径","=","requirements","开始","上下文","镜像","当前目录","执行命令","(","copy","依赖","import","true","composetest","并且","所","\\","配置","了","py","service","创建","code","@","安装","def","as","dev","容器","yaml","0","compose","从","1","构建","环境变量","变量","程序","和","运行","linux","中",".","python3.7","run","have","上下","up","build","n","dockerfile","hello","-","默认","d","services","文件","web","apk","env","是","0.0","while",",","设置","{","/","]","两个","python","\"","映射","no","3.7","执行","headers","pip","hits","musl","将","}"," ","host","命令","当前","目录","通过","retries","sleep","raise","cmd","yml","r","版本","count","app","install","been","应用","ports","服务","route","workdir","gcc","port","5000","工作","使用","add","项目","cache","seen","incr","'","环境","端口","time","__","的","6379","指定","image","定义","txt","[","version","exceptions","对外","alpine","from","try","下文","5","需","环境变","!","exc",")","format","hit","i",":","except","if","redis","world","times","#","应用程序","3","get","return","connectionerror","0.5","name"],"title":"示例","title_tokens":["示例"]},{"location":"Docker/03 Docker-Compose/#yml","text":"version : \"3.7\" services : webapp : build : context : ./dir dockerfile : Dockerfile-alternate args : buildno : 1 labels : - \"com.example.description=Accounting webapp\" - \"com.example.department=Finance\" - \"com.example.label-with-empty-value\" target : prod container_name : my-web-container command : [ \"bundle\" , \"exec\" , \"thin\" , \"-p\" , \"3000\" ] context：指定Dockerfile的上下文路径 dockerfile：指定构建镜像的Dockerfile文件名 labels：设置构建镜像的标签 container_name：设置容器名称 command：覆盖容器启动的默认指令 依赖关系 version : \"3.7\" services : web : build : . depends_on : - db - redis redis : image : redis db : image : postgres docker-compose up：根据依赖关系启动服务，先启动db，redis再启动web docker-compose stop：根据依赖关系廷式服务，先关闭web，再关闭db和redis docker-compose up SERVICE：自动包含SERVICE的依赖项，通过 docker-compose up 还将创建并启动db，redis 挂载 version : '3' services : app : image : golang:latest volumes : # 将项目代码根目录映射到容器中的相关目录 - $PWD : /go/src/example/demo ports : - \"8000:8000\" # 执行go run command : go run /go/src/example/demo/main.go 环境变量 布尔值需要用引号，确保YML解析器不会将其转换为True/False environment : RACK_ENV : development SHOW : 'true' Ref: docker-compose快速入门","text_tokens":["_","volumes","docker","路径","=","label","上下文","代码","镜像","依赖","true","stop","其","需要","关闭","3000","prod","，","com","布尔值","service","创建","用","$","show","容器","名称","compose","context","环境变量","1","构建","标签","启动","变量","和","demo","my","先","中",".","description","到","确保","run","buildno","thin","上下","development","up","build","dockerfile","默认","-","rack","with","services","文件","web","env","exec","golang",",","department","设置","ref","/","main","empty","target","]","\"","映射","3.7","environment","执行","并","文件名","项","为","db","解析器","将"," ","不会","目录","go","指令","on","通过","还","example","bundle","再启动","command","相关","入门","yml","廷式","app","accounting","args","ports","服务","快速","覆盖","布尔","value","再","alternate","自动","引号","挂载","项目","webapp","p","'","labels","环境","depends","根据","8000","的","container","指定","image","dir","[","version","根目录","pwd","包含","下文","postgres","环境变","关系","src","解析","转换","：","false",":","finance","redis","latest","#","3","name"],"title":"yml配置","title_tokens":["配置","yml"]},{"location":"Docker/04 使用Docker搭建Go开发环境/","text":"使用Docker搭建Go开发环境 基本使用 拉取Golang镜像 docker pull golang 运行容器 docker run --rm -it -name go-demo golang bash 进入到bash中 设置goproxy go env -w GOPROXY=https://goproxy.io,direct 设置gomodule export GO111MODULE=on 在容器中运行go项目 docker run --rm -it --name go-demo \\ -v $PWD : /go/src/example/go-demo \\ -p 8000 :8000 golang 通过 -v 将本地目录/数据挂载到容器中， -p 指定主机和容器的端口映射。 切换到bash会话中运行 go run go/src/example/go-demo :warning: $PWD 目录表示当前目录，只能够在Linux下使用，在Windows下需要在Docker for Windows中设置挂载 之后通过 /c/... 指定目录。 使用docker-compose 在项目代码跟目录创建 docker-compose.yml version : '3' services : app : image : golang:latest volumes : # 将项目代码根目录映射到容器中的相关目录 - $PWD : /go/src/example/demo # - /c/users/king/desktop/test:/go/src/example ports : - \"8000:8000\" # 执行go run command : go run /go/src/example/demo/main.go 启动docker-compose并且： docker-compose up -d 修改代码，重新编译项目： docker-compose restart 进入容器中执行命令： docker-compose exec <container name> bash ，例如 docker-compose exec app go test ref: 五分钟用Docker快速搭建go开发环境","text_tokens":["volumes","docker","=","io","...","当前目录","代码","镜像","pull","执行命令","并且","需要","\\","例如","，","编译","it","创建","用","$","容器","分钟","gomodule","compose","修改","w","启动","和","运行","demo","linux","本地","中",".","到","run","切换","up","跟","-","<","d","services","env","exec","golang","。",",","设置","ref","/","main","进入","之后","direct","映射","\"","windows","执行","拉取","将"," ","命令","基本","当前","目录","五分","go","通过","go111module","on","example","下","在","command","for","相关","yml","bash","app","会话","https","ports","重新","快速","v","restart","挂载","使用","项目","p","users","'","king","主机","环境","端口","8000","的","test","rm","能够","container","指定","表示","image","warning","export","version","c","根目录","数据","pwd","五分钟","desktop","src","：","开发","只",":","latest","搭建","#",">","3","goproxy","端口映射","name"],"title":"使用Docker搭建Go开发环境","title_tokens":["docker","go","环境","搭建","开发","使用"]},{"location":"Docker/04 使用Docker搭建Go开发环境/#dockergo","text":"","text_tokens":[],"title":"使用Docker搭建Go开发环境","title_tokens":["docker","go","环境","搭建","开发","使用"]},{"location":"Docker/04 使用Docker搭建Go开发环境/#_1","text":"拉取Golang镜像 docker pull golang 运行容器 docker run --rm -it -name go-demo golang bash 进入到bash中 设置goproxy go env -w GOPROXY=https://goproxy.io,direct 设置gomodule export GO111MODULE=on 在容器中运行go项目 docker run --rm -it --name go-demo \\ -v $PWD : /go/src/example/go-demo \\ -p 8000 :8000 golang 通过 -v 将本地目录/数据挂载到容器中， -p 指定主机和容器的端口映射。 切换到bash会话中运行 go run go/src/example/go-demo :warning: $PWD 目录表示当前目录，只能够在Linux下使用，在Windows下需要在Docker for Windows中设置挂载 之后通过 /c/... 指定目录。","text_tokens":["docker","=","io","...","当前目录","镜像","pull","需要","\\","，","it","$","容器","gomodule","w","和","运行","demo","linux","本地","中",".","到","run","切换","-","env","golang","。",",","设置","/","进入","之后","direct","映射","windows","拉取","将"," ","当前","目录","go","通过","go111module","on","example","下","在","bash","会话","https","v","挂载","项目","使用","p","主机","端口","8000","的","rm","能够","指定","表示","warning","export","c","数据","pwd","src","只",":","goproxy","name","端口映射","for"],"title":"基本使用","title_tokens":["使用","基本"]},{"location":"Docker/04 使用Docker搭建Go开发环境/#docker-compose","text":"在项目代码跟目录创建 docker-compose.yml version : '3' services : app : image : golang:latest volumes : # 将项目代码根目录映射到容器中的相关目录 - $PWD : /go/src/example/demo # - /c/users/king/desktop/test:/go/src/example ports : - \"8000:8000\" # 执行go run command : go run /go/src/example/demo/main.go 启动docker-compose并且： docker-compose up -d 修改代码，重新编译项目： docker-compose restart 进入容器中执行命令： docker-compose exec <container name> bash ，例如 docker-compose exec app go test ref: 五分钟用Docker快速搭建go开发环境","text_tokens":["volumes","docker","代码","执行命令","并且","例如","，","编译","创建","用","$","容器","分钟","compose","修改","启动","demo","中",".","到","run","up","跟","-","<","d","services","exec","golang","ref","/","main","进入","映射","\"","执行","将"," ","命令","目录","五分","go","example","在","command","相关","yml","bash","app","ports","重新","快速","restart","项目","users","'","环境","8000","的","test","container","image","version","c","根目录","pwd","五分钟","desktop","src","：","开发",":","latest","搭建","#",">","3","king","name"],"title":"使用docker-compose","title_tokens":["docker","-","使用","compose"]},{"location":"Docker/05 Docker-Compose2/","text":"Docker-Compose 2 宿主机安装docker后生成docker网卡 docker网卡通过nat为容器分配ip 容器件通过ip直接通信(同一网段，访问相关端口） 容器和宿主机器通过网卡转发路由进行通信 示例1：ip访问 docker run -d -p 80:80 --name mynginx nginx 启动nginx容器 docker exec -it mynginx bash 进入容器 cat /etc/hosts 查看ip:172.17.0.2 通过alpine Linux尝试访问nginx docker run -dit alpine 后台阻塞运行alpine，因为alpine内部没有任何操作，所以需要阻塞运行 docker exec -it apline sh 进入容器 apk add curl 安装curl curl 172.17.0.2 访问nginx 示例2：通过--link映射容器域名 docker run -dit --link mynginx:myng alpine 通过 --link 将 mynginx 的==域名==映射到容器中的 myng ，通过curl访问 myng cat /ect/hosts 查看host文件可以看到 mynginx 映射到了 172.17.0.2 示例3：docker-compose 假如有nginx、golang和mysql三个服务则需要多个 --link 将各个容器给连接起来，其中创建顺序是mysql、golang、nginx，因为后面的容器都需要用到前面容器，需要先将前面容器给连接🔗起来。 通过配置文件统一配置： docker-compose","text_tokens":["都","进行","各个","docker","ip","可以","=","(","🔗","访问","没有","有","需要","配置","，","了","it","宿主机","件","创建","安装","统一","网卡","容器","因为","compose","ect","1","启动","和","运行","80","先","linux","中",".","三个","到","run","-","给","d","文件","apk","exec","同一","是","网段","golang","。","dit","172.17","/","通信","mynginx","后台","连接起来","进入","阻塞","sh","映射","示例","多个","内部","分配","为","将","查看","操作"," ","host","通过","后","用到","2","直接","相关","、","bash","宿主","mysql","接起","尝试","路由","其中","服务","起来","转发","apline","看到","则","add","hosts","p","任何","主机","端口","的","nginx","nat","myng","机器","alpine","link","顺序","域名","后面","所以","curl","）","生成","etc","：","0.2","前面","cat","配置文件",":","假如","连接","3","name"],"title":"Docker-Compose 2","title_tokens":["compose","docker","2","-"," "]},{"location":"Docker/05 Docker-Compose2/#docker-compose-2","text":"宿主机安装docker后生成docker网卡 docker网卡通过nat为容器分配ip 容器件通过ip直接通信(同一网段，访问相关端口） 容器和宿主机器通过网卡转发路由进行通信","text_tokens":["nat","进行","docker","ip","通过","后","直接","相关","机器","(","宿主","访问","路由","同一","）","，","转发","通信","宿主机","生成","件","安装","网卡","容器","主机","端口","分配","为","和"," ","网段"],"title":"Docker-Compose 2","title_tokens":["compose","docker","2","-"," "]},{"location":"Docker/05 Docker-Compose2/#1ip","text":"docker run -d -p 80:80 --name mynginx nginx 启动nginx容器 docker exec -it mynginx bash 进入容器 cat /etc/hosts 查看ip:172.17.0.2 通过alpine Linux尝试访问nginx docker run -dit alpine 后台阻塞运行alpine，因为alpine内部没有任何操作，所以需要阻塞运行 docker exec -it apline sh 进入容器 apk add curl 安装curl curl 172.17.0.2 访问nginx","text_tokens":["nginx",".","docker","run","ip","通过","-"," ","bash","alpine","尝试","d","访问","没有","apk","exec","需要","所以","curl","dit","，","172.17","/","mynginx","it","操作","后台","apline","安装","etc","进入","add","容器","0.2","阻塞","hosts","因为","sh","p","cat",":","运行","任何","内部","启动","查看","80","linux","name"],"title":"示例1：ip访问","title_tokens":["示例","ip","1","访问","："]},{"location":"Docker/05 Docker-Compose2/#2-link","text":"docker run -dit --link mynginx:myng alpine 通过 --link 将 mynginx 的==域名==映射到容器中的 myng ，通过curl访问 myng cat /ect/hosts 查看host文件可以看到 mynginx 映射到了 172.17.0.2","text_tokens":[".","到","docker","run","通过","可以","=","myng","-"," ","alpine","访问","link","文件","域名","curl","dit","，","172.17","了","/","mynginx","看到","容器","0.2","hosts","映射","cat",":","ect","将","查看","的","host","中"],"title":"示例2：通过--link映射容器域名","title_tokens":["映射","示例","通过","link","域名","：","2","-","容器"]},{"location":"Docker/05 Docker-Compose2/#3docker-compose","text":"假如有nginx、golang和mysql三个服务则需要多个 --link 将各个容器给连接起来，其中创建顺序是mysql、golang、nginx，因为后面的容器都需要用到前面容器，需要先将前面容器给连接🔗起来。 通过配置文件统一配置： docker-compose","text_tokens":["nginx","三个","的","都","各个","docker","通过","用到","-","给","和","、","接起","mysql","🔗","其中","link","有","顺序","后面","文件","需要","是","服务","golang","起来","配置","。","，","连接起来","创建","统一","：","则","容器","因为","前面","多个","配置文件","假如","compose","连接","将"," ","先"],"title":"示例3：docker-compose","title_tokens":["示例","compose","docker","3","：","-"]},{"location":"Docker/06 使用Docker打包Go文件/","text":"使用Docker打包Go文件 Dockerfile FROM golang:alpine # 为我们的镜像设置必要的环境变量 ENV GO111MODULE = on \\ CGO_ENABLED = 0 \\ GOOS = linux \\ GOARCH = amd64 \\ GOPROXY = https://goproxy.io,direct # 移动到工作目录：/build WORKDIR /build # 将代码复制到容器中 COPY . . # 将我们的代码编译成二进制可执行文件app RUN go build -o app . # 移动到用于存放生成的二进制文件的 /dist 目录 WORKDIR /dist # 将二进制文件从 /build 目录复制到这里 RUN cp /build/app . # 声明服务端口 EXPOSE 8888 # 启动容器时运行的命令，启动app CMD [ \"/dist/app\" ] 通过 docker build . -t <CONTAINER_NAME> 指令根据 Dockerfile 配置创建出相应的镜像，构建完毕后通过 docker run -p 8000：8888 <CONTAINER_NAME> 运行镜像 分段构建 因为Go程序编译后会得到可执行的二进制文件，所以可以创建一个能够运行最终的二进制文件的容器来运行app。这样的好处是镜像只保存了二进制文件从而使得镜像大小减小。 FROM golang:alpine AS builder # 为我们的镜像设置必要的环境变量 ENV GO111MODULE = on \\ CGO_ENABLED = 0 \\ GOOS = linux \\ GOARCH = amd64 \\ GOPROXY = https://goproxy.io,direct # 移动到工作目录：/build WORKDIR /build # 将代码复制到容器中 COPY . . # 创建一个小的镜像存放二进制文件 FROM scratch # 将builder镜像中的/dist/app拷贝到当前目录 COPY --from = builder /build/app / # 运行 ENRTYPOINT [ \"/app\" ] 打包项目 chitchat ├─config ├─data ├─handlers ├─locales ├─logs ├─models ├─public │ ├─css │ ├─fonts │ └─js ├─routes └─views ├─en └─zh 将静态文件拷贝到最终的镜像中 FROM golang:alpine AS builder # 为我们的镜像设置必要的环境变量 ENV GO111MODULE = on \\ CGO_ENABLED = 0 \\ GOOS = linux \\ GOARCH = amd64 \\ GOPROXY = https://goproxy.io,direct # 移动到工作目录：/build WORKDIR /build # 复制项目中的 go.mod 和 go.sum文件并下载依赖信息 COPY go.mod . COPY go.sum . RUN go mod download # 将代码复制到容器中 COPY . . # 将我们的代码编译成二进制可执行文件 chitchat RUN go build -o chitchat . # 接下来创建一个小镜像 FROM scratch COPY ./public /public COPY ./views /views COPY ./logs /logs COPY ./locales /locales COPY config.json / # 从builder镜像中把/dist/app 拷贝到当前目录 COPY --from = builder /build/chitchat / # 需要运行的命令 ENTRYPOINT [ \"/chitchat\" ] 启动Mysql服务 docker run --name mysql -p 3306 :3306 -e MYSQL_ROOT_PASSWORD = root -v /c/user/king/desktop/data:/var/lib/mysql -d mysql 关联：通过 --link docker run --link = mysql:mysql -p 8080 :8080 chitchat ref: 3步构建go docker最小镜像 如何使用Docker部署Go Web应用","text_tokens":["_","复制","docker","复制到","可以","静态","=","io","行文","小","代码","镜像","译成","声明","得到","当前目录","copy","使得","依赖","需要","\\","这样","配置","分段","，","编译","存放","了","zh","创建","as","routes","sum","goos","容器","因为","cp","0","环境变量","从","构建","可","启动","下载","变量","相应","好处","enabled","运行","和","接下来","password","linux","中","8080",".","如何","到","用于","locales","logs","run","user","build","en","dockerfile","-","<","从而","大小","builder","goarch","d","移动","进制","文件","拷贝到","把","env","web","必要","是","golang","。","enrtypoint",",","设置","o","最终","ref","/","可执行文件","public","二进制","]","direct","\"","config","执行","并","为","出","最小","将"," ","来","mod","命令","步","当前","目录","go","通过","go111module","on","时","指令","后","css","cmd","mysql","app","cgo","https","应用","8888","服务","编译成","workdir","v","3306","工作","使用","项目","lib","entrypoint","└","t","p","关联","信息","king","环境","端口","保存","根据","8000","的","fonts","能够","container","我们","json","这里","[","scratch","完毕","减小","c","alpine","from","views","models","link","amd64","拷贝","desktop","打包","所以","环境变","root","部署","─","js","expose","chitchat","生成","handlers","：","一个","var","接下","dist","只",":","下来","├","会","#",">","data","│","e","3","goproxy","程序","download","name"],"title":"使用Docker打包Go文件","title_tokens":["docker","go","文件","打包","使用"]},{"location":"Docker/06 使用Docker打包Go文件/#dockergo","text":"","text_tokens":[],"title":"使用Docker打包Go文件","title_tokens":["docker","go","文件","打包","使用"]},{"location":"Docker/06 使用Docker打包Go文件/#dockerfile","text":"FROM golang:alpine # 为我们的镜像设置必要的环境变量 ENV GO111MODULE = on \\ CGO_ENABLED = 0 \\ GOOS = linux \\ GOARCH = amd64 \\ GOPROXY = https://goproxy.io,direct # 移动到工作目录：/build WORKDIR /build # 将代码复制到容器中 COPY . . # 将我们的代码编译成二进制可执行文件app RUN go build -o app . # 移动到用于存放生成的二进制文件的 /dist 目录 WORKDIR /dist # 将二进制文件从 /build 目录复制到这里 RUN cp /build/app . # 声明服务端口 EXPOSE 8888 # 启动容器时运行的命令，启动app CMD [ \"/dist/app\" ] 通过 docker build . -t <CONTAINER_NAME> 指令根据 Dockerfile 配置创建出相应的镜像，构建完毕后通过 docker run -p 8000：8888 <CONTAINER_NAME> 运行镜像","text_tokens":["_","复制","复制到","docker","=","io","行文","代码","镜像","译成","声明","copy","\\","配置","，","编译","存放","创建","goos","容器","cp","0","环境变量","从","构建","启动","变量","相应","enabled","运行","linux","中",".","到","用于","run","build","dockerfile","-","<","goarch","移动","进制","文件","env","必要","golang",",","设置","o","/","可执行文件","二进制","]","direct","\"","执行","为","出","将"," ","命令","目录","go","通过","go111module","on","时","指令","后","cmd","app","cgo","https","8888","服务","编译成","workdir","工作","t","p","环境","端口","根据","8000","的","container","我们","这里","[","完毕","alpine","from","amd64","环境变","expose","生成","：","dist",":","#",">","goproxy","name"],"title":"Dockerfile","title_tokens":["dockerfile"]},{"location":"Docker/06 使用Docker打包Go文件/#_1","text":"因为Go程序编译后会得到可执行的二进制文件，所以可以创建一个能够运行最终的二进制文件的容器来运行app。这样的好处是镜像只保存了二进制文件从而使得镜像大小减小。 FROM golang:alpine AS builder # 为我们的镜像设置必要的环境变量 ENV GO111MODULE = on \\ CGO_ENABLED = 0 \\ GOOS = linux \\ GOARCH = amd64 \\ GOPROXY = https://goproxy.io,direct # 移动到工作目录：/build WORKDIR /build # 将代码复制到容器中 COPY . . # 创建一个小的镜像存放二进制文件 FROM scratch # 将builder镜像中的/dist/app拷贝到当前目录 COPY --from = builder /build/app / # 运行 ENRTYPOINT [ \"/app\" ]","text_tokens":["_","复制","复制到","可以","=","io","小","代码","得到","镜像","当前目录","copy","使得","\\","这样","，","编译","存放","了","创建","as","goos","容器","因为","0","环境变量","可","好处","变量","enabled","运行","linux","中",".","到","build","-","从而","大小","builder","goarch","移动","进制","文件","拷贝到","env","必要","是","golang","。","enrtypoint","最终","设置",",","/","二进制","]","direct","\"","执行","为","将"," ","来","当前","目录","go","go111module","on","后","app","cgo","https","workdir","工作","环境","保存","的","能够","我们","[","scratch","减小","alpine","from","amd64","拷贝","所以","环境变","：","一个","dist","只",":","会","#","goproxy","程序"],"title":"分段构建","title_tokens":["构建","分段"]},{"location":"Docker/06 使用Docker打包Go文件/#_2","text":"chitchat ├─config ├─data ├─handlers ├─locales ├─logs ├─models ├─public │ ├─css │ ├─fonts │ └─js ├─routes └─views ├─en └─zh 将静态文件拷贝到最终的镜像中 FROM golang:alpine AS builder # 为我们的镜像设置必要的环境变量 ENV GO111MODULE = on \\ CGO_ENABLED = 0 \\ GOOS = linux \\ GOARCH = amd64 \\ GOPROXY = https://goproxy.io,direct # 移动到工作目录：/build WORKDIR /build # 复制项目中的 go.mod 和 go.sum文件并下载依赖信息 COPY go.mod . COPY go.sum . RUN go mod download # 将代码复制到容器中 COPY . . # 将我们的代码编译成二进制可执行文件 chitchat RUN go build -o chitchat . # 接下来创建一个小镜像 FROM scratch COPY ./public /public COPY ./views /views COPY ./logs /logs COPY ./locales /locales COPY config.json / # 从builder镜像中把/dist/app 拷贝到当前目录 COPY --from = builder /build/chitchat / # 需要运行的命令 ENTRYPOINT [ \"/chitchat\" ] 启动Mysql服务 docker run --name mysql -p 3306 :3306 -e MYSQL_ROOT_PASSWORD = root -v /c/user/king/desktop/data:/var/lib/mysql -d mysql 关联：通过 --link docker run --link = mysql:mysql -p 8080 :8080 chitchat ref: 3步构建go docker最小镜像 如何使用Docker部署Go Web应用","text_tokens":["_","复制","复制到","docker","静态","=","io","行文","小","代码","镜像","译成","当前目录","copy","依赖","需要","\\","编译","zh","创建","as","routes","sum","goos","容器","0","环境变量","从","构建","启动","下载","变量","和","enabled","接下来","运行","password","linux","中","8080",".","如何","到","locales","user","run","build","en","-","builder","goarch","d","移动","进制","文件","拷贝到","把","env","web","必要","golang","最终","设置",",","o","ref","/","可执行文件","public","二进制","]","direct","\"","config","执行","并","为","最小","将"," ","mod","命令","步","当前","目录","go","通过","go111module","on","css","mysql","app","cgo","https","应用","服务","编译成","workdir","v","3306","工作","项目","lib","使用","entrypoint","└","p","关联","信息","king","环境","的","fonts","我们","json","[","scratch","c","alpine","from","views","models","link","amd64","拷贝","desktop","root","环境变","部署","─","js","chitchat","handlers","：","一个","var","接下","dist",":","下来","├","#","data","│","e","3","goproxy","logs","download","name"],"title":"打包项目","title_tokens":["打包","项目"]},{"location":"Golang/Basic/01 Channel/","text":"channel what is channel channel是goroutine和goroutine之间无锁交流的【媒介】，换句话说，channel是一种允许一个goroutine发送数据给另外一个goroutine的技术，默认的channel是双向的，意味着goroutines可以通过同一个channel发、收数据。 how syntax var Channel_name chan Type channel_name := make(chan Type) 在golang中, 我们用关键字 Channel_name chan Type 创建某种类型的channel，其中channel仅仅可以传递同种类型的数据，不同类型的数据不可以通过一个类型的channel传递。 Send and Receive Data From a Channel 在golang中，channel主要有两个操作，一个是 sending ，一个是 receiving ，这两种操作被称为通讯。 <- 箭头的方向表明是发送数据还是接受数据。在默认情况下，channel中的发送、接受操作块【直到另一端未就绪】 ，允许goroutine之间在没有显式锁或者条件变量的时候互相同步 发送操作：在channel的帮助下用来将goroutine的数据发送给另外一个goroutine，通过channel发送 float64 ， int ， bool 是安全切容易的，因为这些值会被 拷贝 一份，不会有意外并发的风险，同样的， strings 类型也是安全的，因为它是 immutable（不可更改） 。在发送 pointers 或者 slice ， map 等引用的时候，channel是不安全的，因为指针或者引用会被发送者或者接收者在同一时间修改，结果是不可预知的，因此需要==确保只有一个goroutine能够访问== Mychannel <- element 表明了数据（element）发送给了Mychannel 接受操作： element := <- Mychannel package main import \"fmt\" func main () { fmt . Println ( \"starting Main method\" ) ch := make ( chan int ) go myfunc ( ch ) ch <- 23 fmt . Println ( \"End Main method\" ) } func myfunc ( ch chan int ) { fmt . Println ( 234 + <- ch ) } Closing a Channel close() 这是一个内置函数，设了一个表示表明不会再有值发送给该channel。 ele, ok = <- Mychannel 通过循环，接受者会检查该channel是打开的还是关闭的，如果ok是真，则意味着该channel是打开的。 package main import \"fmt\" func main () { c := make ( chan string ) // 调用goroutine go myFunc ( c ) for { res , ok := <- c if ok == false { fmt . Println ( \"Channel Close\" , ok ) break } fmt . Println ( \"Channel Open\" , res , ok ) } } func myFunc ( mychnl chan string ) { for v := 0 ; v < 4 ; v ++ { mychnl <- \"GeeksforGeeks\" } close ( mychnl ) } Blocking Send and Receive 在channel中，当数据发送给一个channel，直到另外的goroutine读取这个channel前，发送的声明是被阻塞的（发送完后必须等待该信息被读取才能够继续发送）。同样的，当一个channel接受数据的时候在接收到数据前都是被阻塞的。 channel中的零值是 nil 。 for 循环可以迭代channel中所有连续的值，直到该channel。 package main import \"fmt\" func main () { mychnl := make ( chan string ) go func () { mychnl <- \"GFG\" mychnl <- \"ABC\" mychnl <- \"ASDJH\" mychnl <- \"asdjjak\" close ( mychnl ) }() for res := range mychnl { fmt . Println ( res ) } } Length of the Channel len() 表明在channel缓冲区中==值的数量== package main import \"fmt\" func main () { mychnl := make ( chan string , 4 ) mychnl <- \"GFG\" mychnl <- \"ABC\" mychnl <- \"ASDJH\" mychnl <- \"asdjjak\" fmt . Println ( \"Length of the channel is:\" , len ( mychnl )) } Capacity of the Channel cap() 表明channel缓冲区的大小 package main import \"fmt\" func main () { mychnl := make ( chan string , 8 ) mychnl <- \"GFG\" mychnl <- \"ABC\" mychnl <- \"ASDJH\" fmt . Println ( \"Capacity of the channel is:\" , cap ( mychnl )) }","text_tokens":["缓冲区","4","一种","_","媒介","或者","双向","发送者","结果","ch","都","关键字","可以","asdjjak","close","=","循环","abc","连续","what","换句","方向","声明","(","意味","import","继续","range","访问","没有","234","发送给","有","函数","需要","并发","关闭","同一个","method","，","未","另一端","检查","receiving","同样","了","才","就绪","用","创建","【","8","主要","等","前","syntax","互相","break","因为","修改","0","23","条件","更改","该","】","接收","type","变量","发","和","中","is","同步",".","读取","open","goroutines","不","技术","确保","到","同一时","意味着","这是","myfunc","所有","默认","-","这","无锁","送给","给","<","箭头","因此","end","必须","当","意外","ok","大小","asdjh","帮助","引用","同一","不可","是","blocking","golang","仅仅","用来","时候","。","允许",",","+","类型","{","接收者","closing","goroutine","main","打开","/","两个","被","func","完后","阻塞","（",";","\"","一时","starting","真","关键","通讯","一时间","将","设"," ","换句话","某种","操作","这些","不会","fmt","}","一份","受者","gfg","go","通过","strings","两种","下","在","send","指针","int","同一时间","for","mychnl","再有","迭代","、","显式","值","块","锁","pointers","mychannel","println","零值","其中","如果","安全","len","a","预知","情况","v","交流","receive","还是","只有","一端","sending","则","缓冲","接受","of","风险","信息","cap","how","package","++","的","ele","能够","调用","我们","slice","length","表明","时间","chan","另外","表示","这个","geeksforgeeks","capacity","容易","直到","res","值会","数量","c","from","内置","nil","数据","bool","传递","换句话说","拷贝","之间","切","string","）","称为","float64","等待","map","发送","收","不同","channel","：","一个","var",")","and","它","false","make","the","接受者","element",":","同种","if","会","immutable","data","发送数据","也","name"],"title":"channel","title_tokens":["channel"]},{"location":"Golang/Basic/01 Channel/#channel","text":"","text_tokens":[],"title":"channel","title_tokens":["channel"]},{"location":"Golang/Basic/01 Channel/#what-is-channel","text":"channel是goroutine和goroutine之间无锁交流的【媒介】，换句话说，channel是一种允许一个goroutine发送数据给另外一个goroutine的技术，默认的channel是双向的，意味着goroutines可以通过同一个channel发、收数据。","text_tokens":["一种","媒介","goroutines","技术","双向","意味着","通过","可以","另外","默认","换句","无锁","给","意味","、","发送数据","数据","换句话说","同一","是","之间","同一个","。","允许","，","发送","收","goroutine","交流","【","channel","一个","换句话","】","发","和","的"],"title":"what is channel","title_tokens":["channel"," ","what","is"]},{"location":"Golang/Basic/01 Channel/#how","text":"syntax var Channel_name chan Type channel_name := make(chan Type) 在golang中, 我们用关键字 Channel_name chan Type 创建某种类型的channel，其中channel仅仅可以传递同种类型的数据，不同类型的数据不可以通过一个类型的channel传递。","text_tokens":["_","的","不","我们","关键字","通过","chan","可以","=","在","(","其中","数据","传递","golang","仅仅","。",",","，","name","类型","用","创建","channel","var",")","一个","syntax","make",":","同种","关键","type","不同"," ","某种","中"],"title":"how","title_tokens":["how"]},{"location":"Golang/Basic/01 Channel/#send-and-receive-data-from-a-channel","text":"在golang中，channel主要有两个操作，一个是 sending ，一个是 receiving ，这两种操作被称为通讯。 <- 箭头的方向表明是发送数据还是接受数据。在默认情况下，channel中的发送、接受操作块【直到另一端未就绪】 ，允许goroutine之间在没有显式锁或者条件变量的时候互相同步 发送操作：在channel的帮助下用来将goroutine的数据发送给另外一个goroutine，通过channel发送 float64 ， int ， bool 是安全切容易的，因为这些值会被 拷贝 一份，不会有意外并发的风险，同样的， strings 类型也是安全的，因为它是 immutable（不可更改） 。在发送 pointers 或者 slice ， map 等引用的时候，channel是不安全的，因为指针或者引用会被发送者或者接收者在同一时间修改，结果是不可预知的，因此需要==确保只有一个goroutine能够访问== Mychannel <- element 表明了数据（element）发送给了Mychannel 接受操作： element := <- Mychannel package main import \"fmt\" func main () { fmt . Println ( \"starting Main method\" ) ch := make ( chan int ) go myfunc ( ch ) ch <- 23 fmt . Println ( \"End Main method\" ) } func myfunc ( ch chan int ) { fmt . Println ( 234 + <- ch ) }","text_tokens":["或者","发送者","结果","ch","=","方向","(","import","访问","没有","234","发送给","有","需要","并发","method","，","未","另一端","receiving","同样","了","就绪","【","主要","等","互相","因为","修改","23","条件","更改","】","接收","变量","中","同步",".","不","确保","同一时","myfunc","默认","-","这","送给","因此","<","end","箭头","意外","帮助","引用","同一","不可","是","golang","用来","时候","。","允许","+","类型","{","接收者","goroutine","main","被","两个","func","（","\"","一时","starting","通讯","一时间","将"," ","这些","不会","操作","fmt","}","一份","go","通过","strings","两种","下","在","指针","int","同一时间","、","显式","块","锁","pointers","mychannel","println","安全","预知","情况","还是","只有","一端","sending","接受","风险","package","的","能够","slice","表明","时间","chan","另外","容易","直到","值会","数据","bool","拷贝","之间","切","）","称为","float64","map","发送","channel","：","一个",")","它","make","element",":","会","immutable","发送数据","也"],"title":"Send and Receive Data From a Channel","title_tokens":["from","receive","channel","data","a","send","and"," "]},{"location":"Golang/Basic/01 Channel/#closing-a-channel","text":"close() 这是一个内置函数，设了一个表示表明不会再有值发送给该channel。 ele, ok = <- Mychannel 通过循环，接受者会检查该channel是打开的还是关闭的，如果ok是真，则意味着该channel是打开的。 package main import \"fmt\" func main () { c := make ( chan string ) // 调用goroutine go myFunc ( c ) for { res , ok := <- c if ok == false { fmt . Println ( \"Channel Close\" , ok ) break } fmt . Println ( \"Channel Open\" , res , ok ) } } func myFunc ( mychnl chan string ) { for v := 0 ; v < 4 ; v ++ { mychnl <- \"GeeksforGeeks\" } close ( mychnl ) }","text_tokens":["4","close","=","循环","(","意味","import","发送给","函数","关闭","，","检查","了","break","0","该",".","open","意味着","这是","myfunc","-","送给","<","ok","是","。",",","{","打开","/","main","goroutine","func",";","\"","真","设","不会","}"," ","fmt","受者","go","通过","mychnl","再有","值","mychannel","println","如果","v","还是","则","接受","package","++","的","ele","调用","表明","chan","表示","geeksforgeeks","res","c","内置","string","发送","channel","一个",")","false","make","接受者",":","if","会","for"],"title":"Closing a Channel","title_tokens":["closing"," ","channel","a"]},{"location":"Golang/Basic/01 Channel/#blocking-send-and-receive","text":"在channel中，当数据发送给一个channel，直到另外的goroutine读取这个channel前，发送的声明是被阻塞的（发送完后必须等待该信息被读取才能够继续发送）。同样的，当一个channel接受数据的时候在接收到数据前都是被阻塞的。 channel中的零值是 nil 。 for 循环可以迭代channel中所有连续的值，直到该channel。 package main import \"fmt\" func main () { mychnl := make ( chan string ) go func () { mychnl <- \"GFG\" mychnl <- \"ABC\" mychnl <- \"ASDJH\" mychnl <- \"asdjjak\" close ( mychnl ) }() for res := range mychnl { fmt . Println ( res ) } }","text_tokens":[".","能够","到","都","gfg","go","可以","chan","另外","asdjjak","close","这个","循环","=","迭代","在","所有","abc","直到","for","连续","送给","声明"," ","mychnl","(","<","-","res","必须","值","当","继续","零值","import","range","nil","数据","asdjh","println","发送给","是","string","时候","）","。","，","等待","同样","{","发送","goroutine","才","main","channel","中","被","完后","一个","func",")","前","阻塞","（","接受","make","\"",":","}","信息","该","接收","package","的","fmt","读取"],"title":"Blocking Send and Receive","title_tokens":["receive","send","blocking","and"," "]},{"location":"Golang/Basic/01 Channel/#length-of-the-channel","text":"len() 表明在channel缓冲区中==值的数量== package main import \"fmt\" func main () { mychnl := make ( chan string , 4 ) mychnl <- \"GFG\" mychnl <- \"ABC\" mychnl <- \"ASDJH\" mychnl <- \"asdjjak\" fmt . Println ( \"Length of the channel is:\" , len ( mychnl )) }","text_tokens":["缓冲区","4",".","length","表明","gfg","chan","asdjjak","=","abc","在","-","mychnl"," ","<","(","is","数量","值","println","import","asdjh","len","string",",","{","main","channel","func",")","缓冲","of","make","the","\"",":","}","package","的","fmt","中"],"title":"Length of the Channel","title_tokens":["length","channel"," ","of","the"]},{"location":"Golang/Basic/01 Channel/#capacity-of-the-channel","text":"cap() 表明channel缓冲区的大小 package main import \"fmt\" func main () { mychnl := make ( chan string , 8 ) mychnl <- \"GFG\" mychnl <- \"ABC\" mychnl <- \"ASDJH\" fmt . Println ( \"Capacity of the channel is:\" , cap ( mychnl )) }","text_tokens":["缓冲区",".","表明","gfg","chan","=","abc","capacity","-","mychnl"," ","<","(","大小","import","println","asdjh","string",",","{","main","8","channel","func",")","缓冲","of","make","the","\"",":","}","cap","package","的","fmt","is"],"title":"Capacity of the Channel","title_tokens":["channel","capacity"," ","of","the"]},{"location":"Golang/Basic/02 UseDelveDebug/","text":"使用delve调试Golang 安装 vscode中, 通过 ctrl+shift+p 运行 Go: Install/Update Tools ,选择 dlv 安装 go get -u github.com/go-delve/delve/cmd/dlv 使用 vscode 在vscode中按F5, 弹出 launch.json 文件, 配置 { // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 \"version\" : \"0.2.0\" , \"configurations\" : [ { \"name\" : \"Launch\" , \"type\" : \"go\" , \"request\" : \"launch\" , \"mode\" : \"debug\" , // auto \"program\" : \"${fileDirname}\" , \"env\" : { \"GOPATH\" : \"d:/workspace/go space/go\" }, \"args\" : [] } ] } 命令行debug package main import ( \"net/http\" \"github.com/gin-gonic/gin\" ) func HelloHandler ( c * gin . Context ) { firstname := c . DefaultQuery ( \"firstname\" , \"Guest\" ) lastname := c . Query ( \"lastname\" ) c . String ( http . StatusOK , \"Hello %s %s\" , firstname , lastname ) } func main () { router := gin . Default () router . GET ( \"/welcome\" , HelloHandler ) router . Run ( \":8000\" ) } 1. 进入要debug的文件目录 cd ../main.go dlv debug main.go // debug b HelloHandler // break point c // continue n // next s // step in p value // print value stepout // step out function st => start : Start : > http : // www . google . com [ blank ] e => end : > http : // www . google . com op1 => operation : My Operation sub1 => subroutine : My Subroutine cond => condition : Yes or No ?: > http : // www . google . com io => inputoutput : catch something ... st -> op1 -> cond cond ( yes ) -> io -> e cond ( no ) -> sub1 ( right ) -> op1 Title : Here is a title A -> B : Normal line B --> C : Dashed line C ->> D : Open arrow D -->> A : Dashed open arrow","text_tokens":["or","=","io","www","...","op1","function","(","program","import","debug","google","router","auto","to","firstname","调试","配置","use","net","view","blank","configurations","here","com","shift","information","安装","$","gonic","按","break","st","in","0","context","1","line","launch","type","linkid","运行","my","gin","弹","github",".","中","is","open","hellohandler","run","step","选择","condition","n","%","delve","-","existing","hello","filedirname","next","end","要","d","operation","attributes","文件","env","golang",",","+","dlv","intellisense","{","/","tools","u","main","]","func","进入","..","learn","http","out","\"","no","出","vscode"," ","}","命令","目录","go","通过","something","fwlink","在","s","cmd","*","lastname","ctrl","f5","830387","install","workspace","文件目录","inputoutput","https","arrow","args","a","defaultquery","cd","?","request","query","value","b","descriptions","print","使用","hover","of","dashed","p","about","normal","package","8000","的","gopath","visit","json","update","guest","cond","sub1","[","version","title","continue","more","c","possible","default","welcome","string","microsoft","start","yes","catch","命令行",")","statusok","subroutine","0.2","mode","point","stepout",":","space",">","e","get","name","right","for"],"title":"使用delve调试Golang","title_tokens":["调试","delve","golang","使用"]},{"location":"Golang/Basic/02 UseDelveDebug/#delvegolang","text":"","text_tokens":[],"title":"使用delve调试Golang","title_tokens":["调试","delve","golang","使用"]},{"location":"Golang/Basic/02 UseDelveDebug/#_1","text":"vscode中, 通过 ctrl+shift+p 运行 Go: Install/Update Tools ,选择 dlv 安装 go get -u github.com/go-delve/delve/cmd/dlv","text_tokens":[".","go","通过","选择","update","delve","-","cmd","ctrl","install","github","vscode",",","+","dlv","com","/","tools","u","shift","安装","p",":","get","运行"," ","中"],"title":"安装","title_tokens":["安装"]},{"location":"Golang/Basic/02 UseDelveDebug/#_2","text":"","text_tokens":[],"title":"使用","title_tokens":["使用"]},{"location":"Golang/Basic/02 UseDelveDebug/#vscode","text":"在vscode中按F5, 弹出 launch.json 文件, 配置 { // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 \"version\" : \"0.2.0\" , \"configurations\" : [ { \"name\" : \"Launch\" , \"type\" : \"go\" , \"request\" : \"launch\" , \"mode\" : \"debug\" , // auto \"program\" : \"${fileDirname}\" , \"env\" : { \"GOPATH\" : \"d:/workspace/go space/go\" }, \"args\" : [] } ] }","text_tokens":[".","gopath","visit","json","go","=","fwlink","在","linkid","existing","for","version","[","filedirname","f5","more","program","830387","workspace","d","possible","debug","attributes","文件","https","env","args","auto","to","microsoft","配置","use","view",",","intellisense","configurations","?","name","{","/","com","request","information","中","$","descriptions","]","按","learn","hover","of","0.2","mode","\"","0",":","about","}","space","launch","出","type","vscode"," ","弹"],"title":"vscode","title_tokens":["vscode"]},{"location":"Golang/Basic/02 UseDelveDebug/#debug","text":"package main import ( \"net/http\" \"github.com/gin-gonic/gin\" ) func HelloHandler ( c * gin . Context ) { firstname := c . DefaultQuery ( \"firstname\" , \"Guest\" ) lastname := c . Query ( \"lastname\" ) c . String ( http . StatusOK , \"Hello %s %s\" , firstname , lastname ) } func main () { router := gin . Default () router . GET ( \"/welcome\" , HelloHandler ) router . Run ( \":8000\" ) } 1. 进入要debug的文件目录 cd ../main.go dlv debug main.go // debug b HelloHandler // break point c // continue n // next s // step in p value // print value stepout // step out function st => start : Start : > http : // www . google . com [ blank ] e => end : > http : // www . google . com op1 => operation : My Operation sub1 => subroutine : My Subroutine cond => condition : Yes or No ?: > http : // www . google . com io => inputoutput : catch something ... st -> op1 -> cond cond ( yes ) -> io -> e cond ( no ) -> sub1 ( right ) -> op1 Title : Here is a title A -> B : Normal line B --> C : Dashed line C ->> D : Open arrow D -->> A : Dashed open arrow","text_tokens":["or","=","io","www","...","op1","function","(","import","debug","google","router","firstname","net","blank","here","com","gonic","break","st","in","context","1","line","my","gin","github","is",".","open","hellohandler","run","step","condition","n","%","hello","-","next","end","要","d","operation","文件",",","dlv","{","/","main","]","func","进入","..","http","out","\"","no","}"," ","目录","go","something","s","*","lastname","文件目录","inputoutput","arrow","a","defaultquery","cd","query","?","value","b","print","dashed","p","normal","package","8000","的","guest","cond","sub1","[","title","continue","c","default","welcome","string","start","yes","catch",")","statusok","subroutine","point","stepout",":",">","e","get","right"],"title":"命令行debug","title_tokens":["命令行","debug","命令"]},{"location":"Golang/ErrorCollect/20191127：Cannot fint main module[gomod]/","text":"20191127：Cannot fint the main module[gomod] 环境 在尝试vscode的debug中输出了 go: cannot find main module; see 'go help modules' 原因 & 解决 根目录下没有 go.mod 文件, 需要 go mod init 初始化建立相关 .mod 文件;或者将环境变量中的 GO111MODULE=AUTO/OFF","text_tokens":[".","或者","module","目录","go","&","解决","modules","go111module","=","下","在","初始化","[","相关"," ","原因","help","fint","尝试","根目录","init","debug","see","输出","没有","文件","find","gomod","auto","需要","环境变",",","off","20191127","了","/","main","]","：","the",";",":","初始","'","环境变量","环境","建立","cannot","变量","将","vscode","的","mod","中"],"title":"20191127：Cannot fint the main module[gomod]","title_tokens":["module","20191127","fint","main","cannot","[","gomod","]","："," ","the"]},{"location":"Golang/ErrorCollect/20191127：Cannot fint main module[gomod]/#20191127cannot-fint-the-main-modulegomod","text":"","text_tokens":[],"title":"20191127：Cannot fint the main module[gomod]","title_tokens":["module","20191127","fint","main","cannot","[","gomod","]","："," ","the"]},{"location":"Golang/ErrorCollect/20191127：Cannot fint main module[gomod]/#_1","text":"在尝试vscode的debug中输出了 go: cannot find main module; see 'go help modules'","text_tokens":["module","go","modules","在"," ","help","尝试","debug","see","输出","find","了","main",";",":","'","cannot","vscode","的","中"],"title":"环境","title_tokens":["环境"]},{"location":"Golang/ErrorCollect/20191127：Cannot fint main module[gomod]/#_2","text":"根目录下没有 go.mod 文件, 需要 go mod init 初始化建立相关 .mod 文件;或者将环境变量中的 GO111MODULE=AUTO/OFF","text_tokens":[".","的","或者","目录","go","go111module","=","下","初始化","相关","根目录","init","没有","文件","auto","需要","环境变",",","off","/",";","初始","环境变量","环境","建立","变量","将"," ","mod","中"],"title":"原因 &amp; 解决","title_tokens":[";","原因","解决","&"," ","amp"]},{"location":"Golang/Go-Web/01 HTTPServe/","text":"01：建立HTTP服务器的多种方法 建立服务器 package mian import ( \"log\" \"net/http\" ) func main () { http . HadnleFunc ( \"/\" , func ( w http . ResponseWriter , r * http . Request ) { w . Write ([] byte ( \"hello world\" ) } log . Println ( \"starting HTTP server..\" ) log . Fatal ( http . ListenAndServe ( \":8000\" , nil )) } http.HandleFunc(pattern string, handler func(ResponseWriter, *Request) 根据一个==路由规则==绑定一个执行函数, 当用户访问到指定路由时执行. http.HandleFunc 的第二个参数必须符合函数签名 func(http.ResponseWriter, *http.Request) , 第一个参数是请求所对应的响应对象 http.ResponseWriter ,包含响应码、响应头和响应体, 在这里通过调用 响应对象 的 Write 方法像响应体写入字符串. 第二个参数是请求所对应的请求对象 *http.Request ,包含请求头、请求体等. http.ListenAndServe 启动HTTP服务器,监听 指定地址 和 端口号 的HTTP请求 http.HandleFunc 将传入的 绑定函数 转换为类型 http.HandleFunc (一个HTTP请求处理器对象),该对象类型实现 http.Handler 接口,接口方法调用自己 // net / http / server . go // The HandlerFunc type is an adapter to allow the use of // ordinary functions as HTTP handlers . If f is a function // with the appropriate signature , HandlerFunc ( f ) is a // Handler that calls f . type HandlerFunc func ( ResponseWriter , * Request ) // ServeHTTP calls f ( w , r ) . func ( f HandlerFunc ) ServeHTTP ( w ResponseWriter , r * Request ) { f ( w , r ) } 自定义Handler package main import ( \"log\" \"net/http\" ) type customHandler {} // 将ServeHTTP方法绑定到customHandler上 func ( _ * customHandler ) ServeHTTP ( w http . ResponseWriter , r * http . Request ){ w . Write ([] byte ( \"hello custom Handler\" ) } func main () { http . Handle ( \"/\" , & cutsomerHandler {}) log . Println ( \"starting HTTP server...\" ) log . Fatl ( http . ListenAndServe ( \":8000\" , nil )) } 自定义类型 type customHandler{} 类型绑定 ServerHTTP(w http.ResponseWriter, r *http.Request) 方法 http.Handle 调用, 通过 &customHandler{} 传入该自定义类型的地址 少了将绑定函数转换为 type HandleFunc 的步骤 服务复用器(ServeMux) // ListenAndServe listens on the TCP network address addr and then calls // Serve with handler to handle requests on incoming connections. // Accepted connections are configured to enable TCP keep-alives. // // The handler is typically nil, in which case the DefaultServeMux is used. // // ListenAndServe always returns a non-nil error. func ListenAndServe ( addr string , handler Handler ) error { server := & Server { Addr : addr , Handler : handler } return server . ListenAndServe () } //*****************************// type Handler interface { ServeHTTP ( ResponseWriter , * Request ) } 1. 实例中 http.ListenAndServe 的nil替代了实现了 http.Handler 接口的对象 2. http.Handler 实现 ServeHTTP 接口 3. 缺陷 该方法不能像之前调用的 http.HandleFunc 和 http.Handle 为不同路由规则绑定不同的函数处理 package main import ( \"log\" \"net/http\" ) type customHandler struct {} func ( _ * customHandler ) ServeHTTP ( w http . ResponseWriter , r * http . Request ) { w . Write ([] byte ( \"hello custom server mux's ServeHTTP\" )) } func main () { log . Println ( \"starting HTTP server... \" ) log . Fatal ( http . ListenAndServe ( \":8000\" , & customHandler {})) } 自定义Serve Mux // HandleFunc registers the handler function for the given pattern // in the DefaultServeMux. // The documentation for ServeMux explains how patterns are matched. func HandleFunc ( pattern string , handler func ( ResponseWriter , * Request )) { DefaultServeMux . HandleFunc ( pattern , handler ) } //*****************************// // DefaultServeMux is the default ServeMux used by Serve. var DefaultServeMux = & defaultServeMux var defaultServeMux ServeMux //*****************************// type ServeMux struct { mu sync . RWMutex m map [ string ] muxEntry es [] muxEntry // slice of entries sorted from longest to shortest. hosts bool // whether any patterns contain hostnames } handle.Handle 调用 DefaultServeMux ,该 DefaultMux 是 http.ServeMux 的封装 http.ServeMux 带有基本路由功能的服务复用器(Serve Multiplexer) 通过 http.NewServeMux 操作 http.ServeMux 对象, 调用 http.NewServeMux 的 .Handle 方法 package main import ( \"log\" \"net/http\" ) type customHandler struct {} func ( _ * customHandler ) ServeHTTP ( w http . ResponseWriter , r * http . Request ) { w . Write ([] byte ( \"hello new custom server mux\" )) } func main () { mux := http . NewServeMux () mux . Handle ( \"/\" , & customHandler {}) log . Println ( \"starting HTTP serve...\" ) log . Fatal ( http . ListenAndServe ( \":8000\" , mux )) } 服务器对象(Server) func ListenAndServe ( addr string , handler Handler ) error { server := & Server { Addr : addr , Handler : handler } return server . ListenAndServe () } //***************************// type Server struct { Addr string Handler Handler ... } 自定义server1 调用 http.ListenAndServe 的时候创建了另一个 http.Serve 对象 package main import ( \"log\" \"net/http\" ) type customHandler struct {} func ( _ * customHandler ) ServeHTTP ( w http . ResponseWriter , r * http . Request ) { w . Write ([] byte ( \"hello custom server mux\" )) } func main () { mux := http . NewServeMux () mux . Handle ( \"/\" , & customHandler {}) serve := & http . Server { Addr : \":8000\" , Handler : mux , } log . Println ( \"starting HTTP serve...\" ) log . Fatal ( serve . ListenAndServe ()) } 自定义server2 // custome server 2 package main import ( \"log\" \"net/http\" \"time\" ) type customHandler struct {} func ( _ * customHandler ) ServeHTTP ( w http . ResponseWriter , r * http . Request ) { w . Write ([] byte ( \"hello custom server mux2\" )) } func main () { mux := http . NewServeMux () mux . Handle ( \"/\" , & customHandler {}) mux . HandleFunc ( \"/timeout\" , func ( w http . ResponseWriter , r * http . Request ) { // 超时 time . Sleep ( 2 * time . Second ) w . Write ([] byte ( \"Timeout\" )) }) server := & http . Server { Addr : \":8000\" , Handler : mux , WriteTimeout : 2 * time . Second , } log . Println ( \"starting HTTP server...\" ) log . Fatal ( server . ListenAndServe ()) } 1. 无法访问到 localhost:8000/timeout 2. 执行函数休眠2秒, 被 http.Serve 对象认为已经超时,提前关闭与客户端之间的连接, 后面无法像响应体写入任何信息 优雅地停止服务 通过捕捉系统信号(Signal)、goroutine和通道(Channel)实现 捕捉 os.Interrupt 信号(ctrl+c)然后调用 server.Shutdown 方法g告知服务器停止接受新请求 http.ErrServerClosed 根据该错误类型判断服务器是否正常关闭 package main import ( \"context\" \"log\" \"net/http\" \"os\" \"os/signal\" ) type customHandler struct {} func ( _ * customHandler ) ServeHTTP ( w http . ResponseWriter , r * http . Request ) { w . Write ([] byte ( \"hello custom server mux2\" )) } func main () { mux := http . NewServeMux () mux . Handle ( \"/\" , & customHandler {}) server := & http . Server { Addr : \":8000\" , Handler : mux , } // 创建系统信号接收器 quit := make ( chan os . Signal ) signal . Notify ( quit , os . Interrupt ) go func () { <- quit if err := server . Shutdown ( context . Background ()); err != nil { log . Fatal ( \"Shutdown server:\" , err ) } }() log . Println ( \"start HTTP server...\" ) err := server . ListenAndServe () if err != nil { if err == http . ErrServerClosed { log . Print ( \"Server Closed under request\" ) } else { log . Fatal ( \"Server closed unexpected\" ) } } }","text_tokens":["_","带有","entries","体等","server","与","访问","函数","关闭","客户端","address","writetimeout","了","告知","创建","new","error","tcp","type","enable","和","pattern","中",".","缺陷","err","方法","-","f","<","01","handler","requests","notify","main","已经","network","func","..","处理","为","将","sleep","用器","s","*","r","custom","matched","documentation","given","appropriate","byte","handle","print","of","任何","serve","端口","超时","addr","实例","定义","by","nil","log","returns","string","通道","第一个","自己","whether","which","：","server2","g","认为","write","second","(","所","to","keep","第一","as","struct","像","muxentry","context","w","自定义","之前","启动","另","到","interface","sorted","shutdown","替代","端口号",",","hostnames","对象","+","/","goroutine","rwmutex","被","timeout","functions",";","新","starting","handlefunc","are","用户","接口","传入","sync","}","基本","handlerfunc","longest","on","时","在","2","是否","case","功能","接受","hosts","休眠","实现","体","的","正常","else","调用","listenandserve","defaultservemux","chan","复用","秒","写入","mu","used","包含","listens","map","ordinary","处理器","var","make",":","world","if","连接","shortest","for","=","签名","...","serverhttp","function","connections","接收器","import","use","响应","server1","参数","os","mux","接收","建立","二个","is","servemux","customhandler","servehttp","hello","必须","quit","an","类型","务器","localhost","\"","contain","interrupt","mux2","地址","复用器","执行","操作","go","信号","m","头","under","ctrl","请求","服务","request","符合","explains","字符串","错误","第二","监听","理器","'","根据","自定","绑定","字符","&","提前","这里","cutsomerhandler","[","上","signal","always","from","calls","bool","后面","之间","!","捕捉","判断",")","fatl","the","errserverclosed","incoming","优雅","3","不同","少","无法","多种","hadnlefunc","服务器","系统","responsewriter","口号","封装","net","步骤","that","in","1","该","然后","es","with","当","background","non","adapter","alives","是","无法访问","时候","{","不能","]","http","defaultmux","any","accepted","patterns","typically","mian"," ","unexpected","客户","通过","对应","、","println","路由","multiplexer","a","停止","then","configured","closed","信息","time","package","how","8000","newservemux","第二个","signature","指定","slice","custome","registers","c","fatal","default","start","allow","转换","handlers","channel","一个","and","地","规则","码","return"],"title":"01：建立HTTP服务器的多种方法","title_tokens":["的","01","多种","服务器","务器","建立","方法","：","服务","http"]},{"location":"Golang/Go-Web/01 HTTPServe/#01http","text":"","text_tokens":[],"title":"01：建立HTTP服务器的多种方法","title_tokens":["的","01","多种","服务器","务器","建立","方法","：","服务","http"]},{"location":"Golang/Go-Web/01 HTTPServe/#_1","text":"package mian import ( \"log\" \"net/http\" ) func main () { http . HadnleFunc ( \"/\" , func ( w http . ResponseWriter , r * http . Request ) { w . Write ([] byte ( \"hello world\" ) } log . Println ( \"starting HTTP server..\" ) log . Fatal ( http . ListenAndServe ( \":8000\" , nil )) } http.HandleFunc(pattern string, handler func(ResponseWriter, *Request) 根据一个==路由规则==绑定一个执行函数, 当用户访问到指定路由时执行. http.HandleFunc 的第二个参数必须符合函数签名 func(http.ResponseWriter, *http.Request) , 第一个参数是请求所对应的响应对象 http.ResponseWriter ,包含响应码、响应头和响应体, 在这里通过调用 响应对象 的 Write 方法像响应体写入字符串. 第二个参数是请求所对应的请求对象 *http.Request ,包含请求头、请求体等. http.ListenAndServe 启动HTTP服务器,监听 指定地址 和 端口号 的HTTP请求 http.HandleFunc 将传入的 绑定函数 转换为类型 http.HandleFunc (一个HTTP请求处理器对象),该对象类型实现 http.Handler 接口,接口方法调用自己 // net / http / server . go // The HandlerFunc type is an adapter to allow the use of // ordinary functions as HTTP handlers . If f is a function // with the appropriate signature , HandlerFunc ( f ) is a // Handler that calls f . type HandlerFunc func ( ResponseWriter , * Request ) // ServeHTTP calls f ( w , r ) . func ( f HandlerFunc ) ServeHTTP ( w ResponseWriter , r * Request ) { f ( w , r ) }","text_tokens":["体等","=","签名","hadnlefunc","write","server","function","(","import","服务器","访问","responsewriter","所","函数","口号","to","net","use","响应","第一","as","参数","that","像","w","该","启动","type","和","pattern","二个","is",".","到","方法","servehttp","hello","f","with","必须","当","handler","an","adapter","是","端口号",",","对象","类型","{","/","main","务器","]","func","..","functions","http","\"","处理","starting","地址","handlefunc","执行","用户","接口","为","mian","传入","将"," ","}","handlerfunc","go","通过","时","在","头","对应","*","r","、","请求","println","路由","a","服务","request","符合","字符串","appropriate","byte","第二","监听","理器","of","端口","实现","体","package","根据","8000","的","第二个","signature","绑定","调用","指定","listenandserve","字符","这里","写入","[","nil","calls","log","fatal","包含","string","allow","第一个","自己","转换","ordinary","handlers","一个",")","处理器","the",":","world","if","规则","码"],"title":"建立服务器","title_tokens":["务器","建立","服务","服务器"]},{"location":"Golang/Go-Web/01 HTTPServe/#handler","text":"package main import ( \"log\" \"net/http\" ) type customHandler {} // 将ServeHTTP方法绑定到customHandler上 func ( _ * customHandler ) ServeHTTP ( w http . ResponseWriter , r * http . Request ){ w . Write ([] byte ( \"hello custom Handler\" ) } func main () { http . Handle ( \"/\" , & cutsomerHandler {}) log . Println ( \"starting HTTP server...\" ) log . Fatl ( http . ListenAndServe ( \":8000\" , nil )) } 自定义类型 type customHandler{} 类型绑定 ServerHTTP(w http.ResponseWriter, r *http.Request) 方法 http.Handle 调用, 通过 &customHandler{} 传入该自定义类型的地址 少了将绑定函数转换为 type HandleFunc 的步骤","text_tokens":[".","_","的","绑定","到","调用","listenandserve","&","通过","customhandler","方法","cutsomerhandler","servehttp","...","hello","[","write","定义","serverhttp"," ","*","(","上","r","server","println","import","custom","handler","nil","log","responsewriter","函数","net","步骤",",","request","类型","{","/","了","main","转换","byte","handle","自定","]","func",")","fatl","http","\"",":","starting","w","自定义","地址","handlefunc","该","为","package","type","8000","传入","将","}","少"],"title":"自定义Handler","title_tokens":["handler","自定义","自定","定义"]},{"location":"Golang/Go-Web/01 HTTPServe/#servemux","text":"// ListenAndServe listens on the TCP network address addr and then calls // Serve with handler to handle requests on incoming connections. // Accepted connections are configured to enable TCP keep-alives. // // The handler is typically nil, in which case the DefaultServeMux is used. // // ListenAndServe always returns a non-nil error. func ListenAndServe ( addr string , handler Handler ) error { server := & Server { Addr : addr , Handler : handler } return server . ListenAndServe () } //*****************************// type Handler interface { ServeHTTP ( ResponseWriter , * Request ) } 1. 实例中 http.ListenAndServe 的nil替代了实现了 http.Handler 接口的对象 2. http.Handler 实现 ServeHTTP 接口 3. 缺陷 该方法不能像之前调用的 http.HandleFunc 和 http.Handle 为不同路由规则绑定不同的函数处理 package main import ( \"log\" \"net/http\" ) type customHandler struct {} func ( _ * customHandler ) ServeHTTP ( w http . ResponseWriter , r * http . Request ) { w . Write ([] byte ( \"hello custom server mux's ServeHTTP\" )) } func main () { log . Println ( \"starting HTTP server... \" ) log . Fatal ( http . ListenAndServe ( \":8000\" , & customHandler {})) }","text_tokens":["_","=","...","write","server","connections","(","import","responsewriter","函数","to","net","address","了","keep","struct","像","in","error","w","1","该","mux","之前","tcp","type","enable","和","中","is",".","缺陷","customhandler","方法","servehttp","hello","-","interface","with","handler","non","requests","alives","替代",",","对象","{","/","不能","main","]","network","func","http","\"","accepted","处理","typically","starting","handlefunc","are","接口","为","}"," ","on","s","2","*","r","println","custom","路由","a","case","request","then","handle","byte","configured","'","serve","实现","package","8000","的","绑定","调用","addr","listenandserve","&","defaultservemux","实例","[","used","always","nil","calls","log","returns","fatal","string","listens","which","and",")","the","incoming",":","规则","3","不同","return"],"title":"服务复用器(ServeMux)","title_tokens":["(","servemux","复用器","复用","用器",")","服务"]},{"location":"Golang/Go-Web/01 HTTPServe/#serve-mux","text":"// HandleFunc registers the handler function for the given pattern // in the DefaultServeMux. // The documentation for ServeMux explains how patterns are matched. func HandleFunc ( pattern string , handler func ( ResponseWriter , * Request )) { DefaultServeMux . HandleFunc ( pattern , handler ) } //*****************************// // DefaultServeMux is the default ServeMux used by Serve. var DefaultServeMux = & defaultServeMux var defaultServeMux ServeMux //*****************************// type ServeMux struct { mu sync . RWMutex m map [ string ] muxEntry es [] muxEntry // slice of entries sorted from longest to shortest. hosts bool // whether any patterns contain hostnames } handle.Handle 调用 DefaultServeMux ,该 DefaultMux 是 http.ServeMux 的封装 http.ServeMux 带有基本路由功能的服务复用器(Serve Multiplexer) 通过 http.NewServeMux 操作 http.ServeMux 对象, 调用 http.NewServeMux 的 .Handle 方法 package main import ( \"log\" \"net/http\" ) type customHandler struct {} func ( _ * customHandler ) ServeHTTP ( w http . ResponseWriter , r * http . Request ) { w . Write ([] byte ( \"hello new custom server mux\" )) } func main () { mux := http . NewServeMux () mux . Handle ( \"/\" , & customHandler {}) log . Println ( \"starting HTTP serve...\" ) log . Fatal ( http . ListenAndServe ( \":8000\" , mux )) }","text_tokens":["_","带有","entries","=","...","write","server","function","(","import","responsewriter","to","封装","net","struct","in","muxentry","new","w","该","mux","type","pattern","is",".","servemux","es","customhandler","方法","servehttp","hello","sorted","handler","是",",","hostnames","对象","{","/","main","rwmutex","]","func","http","defaultmux","any","contain","patterns","\"","starting","复用器","handlefunc","are","sync","}"," ","操作","基本","longest","通过","m","用器","*","r","println","custom","路由","multiplexer","matched","服务","documentation","request","given","explains","handle","byte","功能","of","hosts","serve","how","package","8000","newservemux","的","调用","slice","listenandserve","&","defaultservemux","复用","by","registers","[","mu","used","from","log","bool","fatal","default","string","map","whether","var",")","the",":","shortest","for"],"title":"自定义Serve Mux","title_tokens":["自定义","serve","mux","定义","自定"," "]},{"location":"Golang/Go-Web/01 HTTPServe/#server","text":"func ListenAndServe ( addr string , handler Handler ) error { server := & Server { Addr : addr , Handler : handler } return server . ListenAndServe () } //***************************// type Server struct { Addr string Handler Handler ... }","text_tokens":[".","addr","listenandserve","&","=","..."," ","server","(","*","handler","string",",","{","/","func","struct",")","error",":","return","type","}"],"title":"服务器对象(Server)","title_tokens":["(","对象","服务器","务器",")","服务","server"]},{"location":"Golang/Go-Web/01 HTTPServe/#server1","text":"调用 http.ListenAndServe 的时候创建了另一个 http.Serve 对象 package main import ( \"log\" \"net/http\" ) type customHandler struct {} func ( _ * customHandler ) ServeHTTP ( w http . ResponseWriter , r * http . Request ) { w . Write ([] byte ( \"hello custom server mux\" )) } func main () { mux := http . NewServeMux () mux . Handle ( \"/\" , & customHandler {}) serve := & http . Server { Addr : \":8000\" , Handler : mux , } log . Println ( \"starting HTTP serve...\" ) log . Fatal ( serve . ListenAndServe ()) }","text_tokens":[".","_","另","调用","addr","listenandserve","&","customhandler","=","servehttp","...","hello","[","write"," ","*","(","r","server","println","import","custom","handler","log","responsewriter","fatal","时候","net",",","对象","request","了","{","/","main","创建","byte","handle","]","struct","一个",")","func","http","\"",":","starting","w","serve","mux","package","type","8000","newservemux","的","}"],"title":"自定义server1","title_tokens":["server1","自定义","自定","定义"]},{"location":"Golang/Go-Web/01 HTTPServe/#server2","text":"// custome server 2 package main import ( \"log\" \"net/http\" \"time\" ) type customHandler struct {} func ( _ * customHandler ) ServeHTTP ( w http . ResponseWriter , r * http . Request ) { w . Write ([] byte ( \"hello custom server mux2\" )) } func main () { mux := http . NewServeMux () mux . Handle ( \"/\" , & customHandler {}) mux . HandleFunc ( \"/timeout\" , func ( w http . ResponseWriter , r * http . Request ) { // 超时 time . Sleep ( 2 * time . Second ) w . Write ([] byte ( \"Timeout\" )) }) server := & http . Server { Addr : \":8000\" , Handler : mux , WriteTimeout : 2 * time . Second , } log . Println ( \"starting HTTP server...\" ) log . Fatal ( server . ListenAndServe ()) } 1. 无法访问到 localhost:8000/timeout 2. 执行函数休眠2秒, 被 http.Serve 对象认为已经超时,提前关闭与客户端之间的连接, 后面无法像响应体写入任何信息","text_tokens":["_","无法","=","认为","...","write","server","second","(","与","import","访问","responsewriter","函数","关闭","net","客户端","响应","writetimeout","struct","像","w","1","mux","type",".","到","customhandler","servehttp","hello","handler","无法访问",",","对象","{","/","main","已经","]","localhost","func","timeout","被","http","\"","mux2","starting","handlefunc","执行"," ","}","客户","sleep","2","*","r","println","custom","request","byte","handle","休眠","任何","信息","serve","体","time","package","8000","newservemux","超时","的","addr","listenandserve","&","提前","秒","custome","写入","[","log","fatal","后面","之间",")",":","连接"],"title":"自定义server2","title_tokens":["server2","自定义","自定","定义"]},{"location":"Golang/Go-Web/01 HTTPServe/#_2","text":"通过捕捉系统信号(Signal)、goroutine和通道(Channel)实现 捕捉 os.Interrupt 信号(ctrl+c)然后调用 server.Shutdown 方法g告知服务器停止接受新请求 http.ErrServerClosed 根据该错误类型判断服务器是否正常关闭 package main import ( \"context\" \"log\" \"net/http\" \"os\" \"os/signal\" ) type customHandler struct {} func ( _ * customHandler ) ServeHTTP ( w http . ResponseWriter , r * http . Request ) { w . Write ([] byte ( \"hello custom server mux2\" )) } func main () { mux := http . NewServeMux () mux . Handle ( \"/\" , & customHandler {}) server := & http . Server { Addr : \":8000\" , Handler : mux , } // 创建系统信号接收器 quit := make ( chan os . Signal ) signal . Notify ( quit , os . Interrupt ) go func () { <- quit if err := server . Shutdown ( context . Background ()); err != nil { log . Fatal ( \"Shutdown server:\" , err ) } }() log . Println ( \"start HTTP server...\" ) err := server . ListenAndServe () if err != nil { if err == http . ErrServerClosed { log . Print ( \"Server Closed under request\" ) } else { log . Fatal ( \"Server closed unexpected\" ) } } }","text_tokens":["_","g","=","...","write","server","(","接收器","import","服务器","系统","responsewriter","关闭","net","告知","创建","struct","context","os","w","该","mux","接收","type","然后","和",".","customhandler","err","方法","servehttp","hello","-","<","background","handler","shutdown","quit","notify","+",",","类型","{","/","goroutine","main","务器","]","func","http",";","新","\"","interrupt","mux2"," ","}","unexpected","go","信号","通过","是否","under","*","r","、","ctrl","请求","println","custom","服务","停止","request","错误","byte","handle","print","接受","closed","实现","根据","package","8000","newservemux","正常","else","调用","addr","listenandserve","&","chan","[","signal","c","nil","log","fatal","通道","!","start","捕捉","判断","channel",")","make","errserverclosed",":","if"],"title":"优雅地停止服务","title_tokens":["地","停止","服务","优雅"]},{"location":"Golang/Go-Web/02 BasicTemplateUsage/","text":"02：基础模板 为什么要用模板 HTTP服务器响应固定的字符串不符合实际环境, 通过 text/template 包向客户端 响应动态内容 . 特性 将模板应用于给定的数据结构来执行模板，模板的编码与 Go 语言源代码文件相同，需为 UTF-8 编码 模板中的注解（Annotation）会根据数据结构中的元素来执行并派生具体的显示结构，这些元素一般指结构体中的字段或 map 中的键名 模板的执行逻辑会依据点（Dot，\".\"）操作符来设定当前的执行位置，并按序完成所有逻辑的执行。 模板中的行为（Action）包括数据评估（Data Evaluation）和控制逻辑，且需要使用双层大括号（{{ 和 }}）包裹。除行为以外的任何内容都会原样输出不做修改。 模板解析完成后，从设计上可以并发地进行渲染，但要注意被渲染对象的并发安全性。例如，一个模板可以同时为多个客户端的响应进行渲染，因为输出对象（Writer）是相互独立的，但是被渲染的对象可能有各自的状态和时效性。 如何使用模板 实例 package main import ( \"fmt\" \"text/template\" \"log\" \"net/http\" ) func main () { http . HandleFunc ( \"/\" , func ( w http . ResponseWriter , r * http . Request ) { // 创建模板对象并解析模板内容 tmpl , err := template . New ( \"test\" ). Parse ( \"Hello world!\" ) if err != nil { fmt . Fprintf ( w , \"Parse: %v\" , err ) return } // 调用模板对象的渲染方法 err = tmpl . Execute ( w , nil ) if err != nil { fmt . Fprintf ( w , \"Excute: %v\" , err ) return } }) log . Println ( \"starting HTTP server...\" ) log . Fatal ( http . ListenAndServe ( \":8000\" , nil )) } 1. 引入 text/template 包. 2. 调用 template.New 方法根据给定的名称新建模板, 返回一个 *template.Template 对象. 3. *template.Template 对象的 Parse 方法接受字符串参数(文本模板内容), 解析并返回解析中遇到的错误. 4. 调用 template.Execute 渲染模板, 参数分别为 输出对象 和 指定数据对象 , 实现了 io.Writer 接口的实例都可以作为输出对象. 渲染变量 package main import ( \"net/http\" \"log\" ) func main () { http . HandleFunc ( \"/\" , func ( w http . ResponseWriter , r * http . Reqeust ){ w . Write ([] byte ( r . URL . QUERY (). GET ( \"val\" ))) }) log . Println ( \"starting HTTP serve...\" ) log . Fatal ( http . ListenAndServe ( \":8000\" , nil )) } HTTP协议通过 GET 请求获取URL参数(URL中?后的值). 调用 *http.Request 对象的 URL.QUERY().GET() 方法. package main import ( \"fmt\" \"text/template\" \"log\" \"net/http\" ) func main () { http . HandleFunc ( \"/\" , func ( w http . ResponseWriter , r * http . Request ) { // 创建模板并解析内容 tmpl , err := template . New ( \"test\" ). Parse ( \"The value is: {{.}}\" ) if err != nil { fmt . Fprintf ( w , \"Parse: %v\" , err ) return } // 获取URL参数的值 val := r . URL . Query (). Get ( \"val\" ) // 调用模板对象渲染方法 err = tmpl . Execute ( w , val ) if err != nil { fmt . Fprintf ( w , \"Execute: %v\" , err ) return } }) log . Println ( \"starting HTTP server...\" ) log . Fatal ( http . ListenAndServe ( \":8000\" , nil )) } 模板内容修改成 The value is : {{.}} , 用了 分隔符 将 . 操作符包裹起来, . 操作符默认指向 根对象 , 即 template.Execute 中的第二个参数. 在 template.Execute 方法中传入 val , . 操作符渲染该变量 val 实现动态输出. 渲染复杂对象 package main import ( \"fmt\" \"text/template\" \"log\" \"net/http\" \"strconv\" ) // Inventory 库存 type Inventory struct { SKU string Name string UnitPrice float64 Quantity int64 , } func main () { http . HandleFunc ( \"/\" , func ( w http . ResponseWriter , r * http . Request ) { tmpl , err := template . New ( \"test\" ). Parse ( `Inventory SKU: {{.SKU}} Name: {{.Name}} UnitPrice: {{.UnitPrice}} Quantity: {{.Quantity}} ` ) if err != nil { fmt . Fprintf ( w , \"Parse:%v\" , err ) return } // 根据URL查询参数的值创建Inventory实例 inventory := & Inventory { SKU : r . URL . Query (). Get ( \"sku\" ), Name : r . URL . Query (). Get ( \"name\" ), } // 数据处理 inventory . UnitPrice , _ = strconv . ParseFloat ( r . URL . Query (). Get ( \"unitPrice\" ), 64 ) inventory . Quantity , _ = strconv . ParseInt ( r . URL . Query (). Get ( \"quantity\" ), 10 , 64 ) // 渲染 err = tmpl . Execute ( w , inventory ) if err != nil { fmt . Fprintf ( w , \"Execute: %v\" , err ) return } }) log . Println ( \"start HTTP serve...\" ) log . Fatal ( http . ListenAndServe ( \":8000\" , nil )) } template.Execute 的第二个参数类型为 interface{} , 可以传入任何类型的参数. func ( t * Template ) Execute ( wr io . Writer , data interface {}) error { if err := t . escape (); err != nil { return err } return t . text . Execute ( wr , data ) } http/template 会根据传入的 根对象 进行底层类型分析, 自动识别变量, 此时的 . 操作符代表 inventory 结构体, 因此可以调用 inventory 的各个属性. 在 Parse 的时候用反引号``将结构体包起来. 渲染中调用结构体的方法 func ( i * Inventory ) Subtotal () float64 { return i . UnitPrice * float64 ( i . Quantity ) } //******************************// http . HandleFunc ( \"/\" , func ( w http . ResponseWriter , r * http . Request ) { tmpl , err := template . New ( \"test\" ). Parse ( `Inventory SKU: {{.SKU}} Name: {{.Name}} UnitPrice: {{.UnitPrice}} Quantity: {{.Quantity}} Subtotal: {{.Subtotal}} ` ) map类型作为模板跟对象 package main import ( \"fmt\" \"log\" \"net/http\" \"strconv\" \"text/template\" ) func main () { http . HandleFunc ( \"/\" , func ( w http . ResponseWriter , r * http . Request ) { // 创建模板对象并解析模板内容 tmpl , err := template . New ( \"test\" ). Parse ( `Inventory SKU: {{.SKU}} Name: {{.Name}} UnitPrice: {{.UnitPrice}} Quantity: {{.Quantity}} ` ) if err != nil { fmt . Fprintf ( w , \"Parse: %v\" , err ) return } // 直接将URL 查询参数的值赋值给变量 sku := r . URL . Query (). Get ( \"sku\" ) name := r . URL . Query (). Get ( \"name\" ) unitPrice , _ := strconv . ParseFloat ( r . URL . Query (). Get ( \"unitPrice\" ), 64 ) quantity , _ := strconv . ParseInt ( r . URL . Query (). Get ( \"quantity\" ), 10 , 64 ) err = tmpl . Execute ( w , map [ string ] interface {}{ \"SKU\" : sku , \"Name\" : name , \"UnitPrice\" : unitPrice , \"Quantity\" : quantity , }) if err != nil { fmt . Fprintf ( w , \"Execute: %v\" , err ) return } }) log . Println ( \"Starting HTTP server...\" ) log . Fatal ( http . ListenAndServe ( \"localhost:8000\" , nil )) } 1. 传递给 Execute 一个 map[string]interface{} 作为模板对象,可以传入任意类型的值, 将结构体的所有值都传入. 2. 不再需要单独创建实例, 只需要通过 r.URL.Query().Get(valName) 获取URL查询参数的值. 3. 其中数值需要用到 strconv.ParseInt/ParseFloat 进行转化 注释 tmpl , err := template . New ( \"test\" ). Parse ( `Inventory{{/* 打印参数的值 */}} SKU: {{.SKU}} Name: {{.Name}} UnitPrice: {{.UnitPrice}} Quantity: {{.Quantity}} ` ) 1. 通过 {{}} 双层大括号和 /**/ 括起来的值是注释 模板流程 template.New 新建模板, 返回 *template.Template 对象 调用 *template.Template 对象的 Parse 方法解析模板 传入模板实例 数据处理 strconv 调用 *template.Template 对象的 Execute 方法渲染模板","text_tokens":["_","进行","各个","同时","sku","server","除","与","utf","可能","需要","客户端","且","了","8","创建","语言","new","反","error","从","注释","type","unitprice","和","tmpl","中",".","新建","数值","属性","err","方法","-","给","独立","输出","文件","查询","或","main","func","action","处理","显示","为","将","数据结构","当前","*","r","值","dot","fprintf","包括","给定","固定","v","行为","byte","内容","任意","annotation","template","使用","任何","serve","双层","为什么","括","strconv","02","设定","状态","实例","位置","nil","log","传递","赋值","相互","string","）","float64","64","：","依据","inventory","4","都","派生","write","parse","(","元素","有","指","并发","时效性","struct","分隔","修改","w","一般","如何","大括号","但是","subtotal","协议","所有","默认","interface","操作符",",","对象","/","此时","编码","被","相同","val","代表","（",";","多个","starting","handlefunc","接口","传入","}","具体","在","2","`","quantity","括号","复杂","query","?","自动","接受","环境","实现","体","引入","实际","的","调用","识别","listenandserve","打印","包裹","parseint","map","键名","i",":","wr","world","if","特性","可以","体中","=","io","excute","...","于","import","例如","响应","但","用","参数","因为","评估","需为","符合实际","二个","is","不","字","execute","跟","%","hello","因此","段","自动识别","要","结构","。","类型","底层","设计","包向","务器","localhost","体包","\"","源代码","valname","注解","执行","并","操作","来","go","后","直接","请求","时效","应用","服务","控制","起来","writer","指向","request","符合","字符串","数据处理","错误","引号","第二","t","注意","根据","字符","&","10","[","reqeust","text","上","基础","!",")","the","只","会","data","3","包","不再","分别","点","parsefloat","int64","分隔符","代码","escape","服务器","responsewriter","net","，","完成","url","名称","1","该","变量","各自","文本","evaluation","按序","原样","是","时候","单独","{","分析","]","根","http","以外","逻辑","即"," ","这些","fmt","客户","通过","安全性","什么","获取","用到","作为","println","成","其中","返回","安全","渲染","value","做","模板","package","8000","第二个","test","指定","数据","fatal","库存","start","遇到","解析","动态","流程","一个","地","转化","get","return","name"],"title":"02：基础模板","title_tokens":["：","模板","02","基础"]},{"location":"Golang/Go-Web/02 BasicTemplateUsage/#02","text":"","text_tokens":[],"title":"02：基础模板","title_tokens":["：","模板","02","基础"]},{"location":"Golang/Go-Web/02 BasicTemplateUsage/#_1","text":"HTTP服务器响应固定的字符串不符合实际环境, 通过 text/template 包向客户端 响应动态内容 .","text_tokens":[".","不","字符","通过"," ","text","服务器","服务","客户端",",","响应","固定","符合","/","字符串","包向","务器","动态","内容","template","http","环境","符合实际","实际","的","客户"],"title":"为什么要用模板","title_tokens":["模板","要","用","什么","为什么"]},{"location":"Golang/Go-Web/02 BasicTemplateUsage/#_2","text":"将模板应用于给定的数据结构来执行模板，模板的编码与 Go 语言源代码文件相同，需为 UTF-8 编码 模板中的注解（Annotation）会根据数据结构中的元素来执行并派生具体的显示结构，这些元素一般指结构体中的字段或 map 中的键名 模板的执行逻辑会依据点（Dot，\".\"）操作符来设定当前的执行位置，并按序完成所有逻辑的执行。 模板中的行为（Action）包括数据评估（Data Evaluation）和控制逻辑，且需要使用双层大括号（{{ 和 }}）包裹。除行为以外的任何内容都会原样输出不做修改。 模板解析完成后，从设计上可以并发地进行渲染，但要注意被渲染对象的并发安全性。例如，一个模板可以同时为多个客户端的响应进行渲染，因为输出对象（Writer）是相互独立的，但是被渲染的对象可能有各自的状态和时效性。","text_tokens":["都","进行","可以","同时","派生","体中","点","于","代码","除","元素","与","utf","可能","有","指","需要","并发","例如","客户端","且","，","响应","时效性","但","8","语言","完成","因为","修改","评估","从","需为","一般","和","大括号","中",".","但是","不","字","各自","所有","-","段","evaluation","独立","操作符","按序","原样","要","输出","结构","文件","是","。","对象","或","{","设计","编码","被","相同","（","action","\"","源代码","多个","注解","显示","执行","并","以外","逻辑","为","将"," ","操作","这些","}","来","客户","数据结构","具体","当前","go","安全性","后","dot","时效","包括","安全","括号","应用","控制","writer","给定","渲染","行为","做","内容","annotation","使用","模板","任何","注意","双层","根据","的","设定","状态","包裹","上","位置","数据","相互","）","解析","map","键名","一个","地","依据","会","data"],"title":"特性","title_tokens":["特性"]},{"location":"Golang/Go-Web/02 BasicTemplateUsage/#_3","text":"","text_tokens":[],"title":"如何使用模板","title_tokens":["模板","如何","使用"]},{"location":"Golang/Go-Web/02 BasicTemplateUsage/#_4","text":"package main import ( \"fmt\" \"text/template\" \"log\" \"net/http\" ) func main () { http . HandleFunc ( \"/\" , func ( w http . ResponseWriter , r * http . Request ) { // 创建模板对象并解析模板内容 tmpl , err := template . New ( \"test\" ). Parse ( \"Hello world!\" ) if err != nil { fmt . Fprintf ( w , \"Parse: %v\" , err ) return } // 调用模板对象的渲染方法 err = tmpl . Execute ( w , nil ) if err != nil { fmt . Fprintf ( w , \"Excute: %v\" , err ) return } }) log . Println ( \"starting HTTP server...\" ) log . Fatal ( http . ListenAndServe ( \":8000\" , nil )) } 1. 引入 text/template 包. 2. 调用 template.New 方法根据给定的名称新建模板, 返回一个 *template.Template 对象. 3. *template.Template 对象的 Parse 方法接受字符串参数(文本模板内容), 解析并返回解析中遇到的错误. 4. 调用 template.Execute 渲染模板, 参数分别为 输出对象 和 指定数据对象 , 实现了 io.Writer 接口的实例都可以作为输出对象.","text_tokens":["4","包","都","可以","分别","=","io","excute","...","parse","server","(","import","responsewriter","net","了","创建","参数","new","名称","w","1","和","tmpl","中",".","新建","err","方法","execute","文本","%","hello","输出",",","对象","{","/","main","func","http","\"","starting","handlefunc","并","接口","为"," ","}","fmt","2","*","r","作为","println","fprintf","返回","writer","给定","request","v","渲染","字符串","错误","内容","template","接受","模板","实现","引入","package","根据","8000","的","test","调用","指定","listenandserve","字符","实例","text","nil","数据","log","fatal","!","遇到","解析","一个",")",":","world","if","3","return"],"title":"实例","title_tokens":["实例"]},{"location":"Golang/Go-Web/02 BasicTemplateUsage/#_5","text":"package main import ( \"net/http\" \"log\" ) func main () { http . HandleFunc ( \"/\" , func ( w http . ResponseWriter , r * http . Reqeust ){ w . Write ([] byte ( r . URL . QUERY (). GET ( \"val\" ))) }) log . Println ( \"starting HTTP serve...\" ) log . Fatal ( http . ListenAndServe ( \":8000\" , nil )) } HTTP协议通过 GET 请求获取URL参数(URL中?后的值). 调用 *http.Request 对象的 URL.QUERY().GET() 方法. package main import ( \"fmt\" \"text/template\" \"log\" \"net/http\" ) func main () { http . HandleFunc ( \"/\" , func ( w http . ResponseWriter , r * http . Request ) { // 创建模板并解析内容 tmpl , err := template . New ( \"test\" ). Parse ( \"The value is: {{.}}\" ) if err != nil { fmt . Fprintf ( w , \"Parse: %v\" , err ) return } // 获取URL参数的值 val := r . URL . Query (). Get ( \"val\" ) // 调用模板对象渲染方法 err = tmpl . Execute ( w , val ) if err != nil { fmt . Fprintf ( w , \"Execute: %v\" , err ) return } }) log . Println ( \"starting HTTP server...\" ) log . Fatal ( http . ListenAndServe ( \":8000\" , nil )) } 模板内容修改成 The value is : {{.}} , 用了 分隔符 将 . 操作符包裹起来, . 操作符默认指向 根对象 , 即 template.Execute 中的第二个参数. 在 template.Execute 方法中传入 val , . 操作符渲染该变量 val 实现动态输出.","text_tokens":["=","分隔符","...","write","parse","server","(","import","responsewriter","net","了","创建","用","参数","url","new","分隔","修改","w","该","变量","tmpl","二个","is","中",".","err","方法","execute","协议","%","默认","操作符","输出",",","对象","{","/","main","]","根","func","val","http","\"","starting","handlefunc","并","即","传入","将"," ","}","fmt","操作","通过","获取","后","在","*","r","值","请求","println","fprintf","成","起来","指向","query","?","request","v","渲染","value","byte","内容","第二","template","模板","serve","实现","package","8000","的","第二个","test","调用","listenandserve","包裹","[","reqeust","text","nil","log","fatal","!","解析","动态",")","the",":","if","get","return"],"title":"渲染变量","title_tokens":["渲染","变量"]},{"location":"Golang/Go-Web/02 BasicTemplateUsage/#_6","text":"package main import ( \"fmt\" \"text/template\" \"log\" \"net/http\" \"strconv\" ) // Inventory 库存 type Inventory struct { SKU string Name string UnitPrice float64 Quantity int64 , } func main () { http . HandleFunc ( \"/\" , func ( w http . ResponseWriter , r * http . Request ) { tmpl , err := template . New ( \"test\" ). Parse ( `Inventory SKU: {{.SKU}} Name: {{.Name}} UnitPrice: {{.UnitPrice}} Quantity: {{.Quantity}} ` ) if err != nil { fmt . Fprintf ( w , \"Parse:%v\" , err ) return } // 根据URL查询参数的值创建Inventory实例 inventory := & Inventory { SKU : r . URL . Query (). Get ( \"sku\" ), Name : r . URL . Query (). Get ( \"name\" ), } // 数据处理 inventory . UnitPrice , _ = strconv . ParseFloat ( r . URL . Query (). Get ( \"unitPrice\" ), 64 ) inventory . Quantity , _ = strconv . ParseInt ( r . URL . Query (). Get ( \"quantity\" ), 10 , 64 ) // 渲染 err = tmpl . Execute ( w , inventory ) if err != nil { fmt . Fprintf ( w , \"Execute: %v\" , err ) return } }) log . Println ( \"start HTTP serve...\" ) log . Fatal ( http . ListenAndServe ( \":8000\" , nil )) } template.Execute 的第二个参数类型为 interface{} , 可以传入任何类型的参数. func ( t * Template ) Execute ( wr io . Writer , data interface {}) error { if err := t . escape (); err != nil { return err } return t . text . Execute ( wr , data ) } http/template 会根据传入的 根对象 进行底层类型分析, 自动识别变量, 此时的 . 操作符代表 inventory 结构体, 因此可以调用 inventory 的各个属性. 在 Parse 的时候用反引号``将结构体包起来.","text_tokens":["_","进行","各个","可以","parsefloat","=","int64","io","...","sku","parse","(","escape","import","responsewriter","net","创建","用","struct","参数","url","new","反","error","w","type","unitprice","变量","tmpl","二个",".","属性","err","execute","%","因此","interface","自动识别","操作符","查询","结构","时候",",","对象","类型","{","/","底层","main","此时","分析","根","func","体包","代表","http",";","\"","处理","handlefunc","为","传入","将","}"," ","fmt","操作","在","*","r","`","值","println","fprintf","quantity","起来","writer","request","query","v","渲染","数据处理","自动","引号","第二","template","t","任何","serve","体","package","根据","8000","strconv","的","第二个","test","调用","识别","listenandserve","&","实例","10","parseint","text","nil","数据","log","fatal","string","库存","!","start","float64","64",")",":","wr","if","会","data","inventory","get","return","name"],"title":"渲染复杂对象","title_tokens":["渲染","对象","复杂"]},{"location":"Golang/Go-Web/02 BasicTemplateUsage/#_7","text":"func ( i * Inventory ) Subtotal () float64 { return i . UnitPrice * float64 ( i . Quantity ) } //******************************// http . HandleFunc ( \"/\" , func ( w http . ResponseWriter , r * http . Request ) { tmpl , err := template . New ( \"test\" ). Parse ( `Inventory SKU: {{.SKU}} Name: {{.Name}} UnitPrice: {{.UnitPrice}} Quantity: {{.Quantity}} Subtotal: {{.Subtotal}} ` )","text_tokens":["test",".","subtotal","err","=","sku"," ","*","(","r","parse","`","quantity","responsewriter","float64",",","request","name","{","/","func",")","template","http","new","i","\"",":","w","handlefunc","unitprice","inventory","return","tmpl","}"],"title":"渲染中调用结构体的方法","title_tokens":["调用","渲染","结构","体","方法","的","中"]},{"location":"Golang/Go-Web/02 BasicTemplateUsage/#map","text":"package main import ( \"fmt\" \"log\" \"net/http\" \"strconv\" \"text/template\" ) func main () { http . HandleFunc ( \"/\" , func ( w http . ResponseWriter , r * http . Request ) { // 创建模板对象并解析模板内容 tmpl , err := template . New ( \"test\" ). Parse ( `Inventory SKU: {{.SKU}} Name: {{.Name}} UnitPrice: {{.UnitPrice}} Quantity: {{.Quantity}} ` ) if err != nil { fmt . Fprintf ( w , \"Parse: %v\" , err ) return } // 直接将URL 查询参数的值赋值给变量 sku := r . URL . Query (). Get ( \"sku\" ) name := r . URL . Query (). Get ( \"name\" ) unitPrice , _ := strconv . ParseFloat ( r . URL . Query (). Get ( \"unitPrice\" ), 64 ) quantity , _ := strconv . ParseInt ( r . URL . Query (). Get ( \"quantity\" ), 10 , 64 ) err = tmpl . Execute ( w , map [ string ] interface {}{ \"SKU\" : sku , \"Name\" : name , \"UnitPrice\" : unitPrice , \"Quantity\" : quantity , }) if err != nil { fmt . Fprintf ( w , \"Execute: %v\" , err ) return } }) log . Println ( \"Starting HTTP server...\" ) log . Fatal ( http . ListenAndServe ( \"localhost:8000\" , nil )) } 1. 传递给 Execute 一个 map[string]interface{} 作为模板对象,可以传入任意类型的值, 将结构体的所有值都传入. 2. 不再需要单独创建实例, 只需要通过 r.URL.Query().Get(valName) 获取URL查询参数的值. 3. 其中数值需要用到 strconv.ParseInt/ParseFloat 进行转化","text_tokens":["_","都","进行","不再","可以","parsefloat","=","...","sku","parse","server","(","import","responsewriter","需要","net","创建","参数","url","new","w","1","unitprice","变量","tmpl",".","数值","err","execute","所有","%","interface","给","查询","结构",",","对象","类型","{","/","单独","main","]","localhost","func","http","\"","valname","starting","handlefunc","并","传入","将"," ","}","fmt","通过","获取","用到","2","直接","*","r","`","值","作为","println","fprintf","quantity","其中","request","query","v","内容","任意","template","模板","体","package","8000","strconv","的","test","listenandserve","实例","10","[","parseint","text","nil","log","传递","fatal","赋值","string","!","解析","map","64","一个",")","只","转化",":","if","3","inventory","get","return","name"],"title":"map类型作为模板跟对象","title_tokens":["模板","对象","map","作为","类型","跟"]},{"location":"Golang/Go-Web/02 BasicTemplateUsage/#_8","text":"tmpl , err := template . New ( \"test\" ). Parse ( `Inventory{{/* 打印参数的值 */}} SKU: {{.SKU}} Name: {{.Name}} UnitPrice: {{.UnitPrice}} Quantity: {{.Quantity}} ` ) 1. 通过 {{}} 双层大括号和 /**/ 括起来的值是注释","text_tokens":["test",".","的","通过","err","=","打印","sku","parse","`","(","*","值","括","quantity","括号","是","起来",",","name","{","/","参数",")","template","new","\"",":","注释","1","双层","unitprice","inventory","和"," ","tmpl","大括号","}"],"title":"注释","title_tokens":["注释"]},{"location":"Golang/Go-Web/02 BasicTemplateUsage/#_9","text":"template.New 新建模板, 返回 *template.Template 对象 调用 *template.Template 对象的 Parse 方法解析模板 传入模板实例 数据处理 strconv 调用 *template.Template 对象的 Execute 方法渲染模板","text_tokens":[".","调用","新建","方法","实例","execute"," ","*","parse","数据","返回",",","解析","对象","渲染","数据处理","template","new","模板","处理","传入","strconv","的"],"title":"模板流程","title_tokens":["流程","模板"]},{"location":"Golang/Go-Web/03 AdvanceTemplateUsage/","text":"03：进阶模板用法 在模板中定义变量 package main import ( \"fmt\" \"log\" \"net/http\" \"text/template\" ) func main () { http . HandleFunc ( \"/\" , func ( w http . ResponseWriter , r * http . Request ) { tmpl , err := template . New ( \"test\" ). Parse ( ` {{$name := \"Alice\"}} {{$age := 18}} {{$round2 := true}} Name: {{$name}} Age: {{$age}} Round2: {{$round2}} ` ) if err != nil { fmt . Fprintf ( w , \"Parse: %v\" , err ) return } err = tmpl . Execute ( w , nil ) if err != nil { fmt . Fprintf ( w , \"Execute: %v\" , err ) return } }) log . Println ( \"starting HTTP serve...\" ) log . Fatal ( http . ListenAndServe ( \":8000\" , nil )) } 用美元符号 $ 作为前缀表示变 $name , $age 变量的定义/赋值必须使用 := 语法 直接通过 {{$VarName}} 调用 所有变量的操作都属于模板语法的一部分,需要用 {{}} 括起来 修改变量的值 ... tmpl , err := template . New ( \"test\" ). Parse ( ` {{$name := \"Alice\"}} {{$age := 18}} {{$round2 := true}} Name: {{$name}} Age: {{$age}} Round2: {{$round2}} {{$name = \"K\"}} Name: {{$name}} ` ) ... 类似赋值, 用 = 号直接修改变量值 在模板中使用条件判断(if) package main import ( \"fmt\" \"log\" \"net/http\" \"strconv\" \"text/template\" ) func main () { http . HandleFunc ( \"/\" , func ( w http . ResponseWriter , r * http . Request ) { tmpl , err := template . New ( \"test\" ). Parse ( ` {{if .yIsZero}} 除数不能为0 {{else}} {{.result}} {{end}} ` ) if err != nil { fmt . Fprintf ( w , \"Parse: %v\" , err ) return } x , _ := strconv . ParseInt ( r . URL . Query (). Get ( \"x\" ), 10 , 64 ) y , _ := strconv . ParseInt ( r . URL . Query (). Get ( \"y\" ), 10 , 64 ) yIsZero := y == 0 result := 0.0 if ! yIsZero { result = float64 ( x ) / float64 ( y ) } err = tmpl . Execute ( w , map [ string ] interface {}{ \"yIsZero\" : yIsZero , \"result\" : result , }) if err != nil { fmt . Fprintf ( w , \"Execute: %v\" , err ) } }) log . Println ( \"starting HTTP serve...\" ) log . Fatal ( http . ListenAndServe ( \":8000\" , nil )) } 用 {{}} 将 if 逻辑语句括起来, if 后面必须返回一个 bool 值 if 语句包括 {{if}} , {{else}} , {{end}} 等式和不等式 eq ：当等式 arg1 == arg2 成立时，返回 true，否则返回 false ne ：当不等式 arg1 != arg2 成立时，返回 true，否则返回 false lt ：当不等式 arg1 < arg2 成立时，返回 true，否则返回 false le ：当不等式 arg1 <= arg2 成立时，返回 true，否则返回 false gt ：当不等式 arg1 > arg2 成立时，返回 true，否则返回 false ge ：当不等式 arg1 >= arg2 成立时，返回 true，否则返回 false package main import ( \"fmt\" \"log\" \"net/http\" \"text/template\" ) func main () { http . HandleFunc ( \"/\" , func ( w http . ResponseWriter , r * http . Request ) { tmpl , err := template . New ( \"test\" ). Parse ( ` {{$name1 := \"alice\"}} {{$name2 := \"bob\"}} {{$age1 := 18}} {{$age2 := 23}} {{if eq $age1 $age2}} 年龄相同 {{else}} 年龄不同 {{end}} {{if ne $name1 $name2}} 名字不相同 {{end}} ` ) if err != nil { fmt . Fprintf ( w , \"Parse: %v\" , err ) return } err = tmpl . Execute ( w , nil ) if err != nil { fmt . Fprintf ( w , \"Execute: %v\" , err ) return } }) log . Println ( \"Starting HTTP server...\" ) log . Fatal ( http . ListenAndServe ( \"localhost:8000\" , nil )) } 迭代操作(range) Go 语言中一般来说有三种类型可以进行迭代操作，数组（Array）、切片（Slice）和 map 类型 package main import ( \"fmt\" \"log\" \"net/http\" \"text/template\" ) func main () { http . HandleFunc ( \"/\" , func ( w http . ResponseWriter , r * http . Request ) { tmpl , err := template . New ( \"test\" ). Parse ( ` {{range $name := .Names}} {{$name}} {{end}} ` ) if err != nil { fmt . Fprintf ( w , \"Parse: %v\" , err ) return } err = tmpl . Execute ( w , map [ string ] interface {}{ \"Names\" : [] string { \"Alice\" , \"Bob\" , \"Carol\" , \"David\" , }, }) if err != nil { fmt . Fprintf ( w , \"Execute: %v\" , err ) return } }) log . Println ( \"Starting HTTP server...\" ) log . Fatal ( http . ListenAndServe ( \"localhost:8000\" , nil )) } 获得迭代元素的索引 ... func main () { http . HandleFunc ( \"/\" , func ( w http . ResponseWriter , r * http . Request ) { // 创建模板对象并解析模板内容 tmpl , err := template . New ( \"test\" ). Parse ( ` {{range $i, $name := .Names}} {{$i}}. {{$name}} {{end}} ` ) ... map类型 ... func main () { http . HandleFunc ( \"/\" , func ( w http . ResponseWriter , r * http . Request ) { // 创建模板对象并解析模板内容 tmpl , err := template . New ( \"test\" ). Parse ( ` {{range $name, $val := .}} {{$name}}: {{$val}} {{end}} ` ) ... // 调用模板对象的渲染方法 err = tmpl . Execute ( w , map [ string ] interface {}{ \"Names\" : [] string { \"Alice\" , \"Bob\" , \"Carol\" , \"David\" , }, \"Numbers\" : [] int { 1 , 3 , 5 , 7 }, }) ... } with tmpl , err := template . New ( \"test\" ). Parse ( `Inventory {{with .Inventory}} SKU: {{.SKU}} Name: {{.Name}} UnitPrice: {{.UnitPrice}} Quantity: {{.Quantity}} {{end}} ` ) //****************************// err = tmpl . Execute ( w , map [ string ] interface {}{ \"Inventory\" : Inventory { // 类型 SKU : \"11000\" , Name : \"Phone\" , UnitPrice : 699.99 , Quantity : 666 , }, }) 1. 用 {{with}} 来替代相关实例\" Inventory \". 空白符号处理 {{- 表示剔除模板内容 左侧 的所有空白符号, -}} 表示剔除模板内容 右侧 的所有空白符号. ... func main () { http . HandleFunc ( \"/\" , func ( w http . ResponseWriter , r * http . Request ) { // 创建模板对象并解析模板内容 tmpl , err := template . New ( \"test\" ). Parse ( `Inventory {{- with .Inventory}} SKU: {{.SKU}} Name: {{.Name}} UnitPrice: {{.UnitPrice}} Quantity: {{.Quantity}} {{- end}} ` ) ...","text_tokens":["_","都","进行","等式","可以","=","...","sku","y","parse","server","(","否则","元素","import","true","age2","range","le","有","responsewriter","需要","变","net","语句","david","，","round2","arg1","切片","用","创建","$","语言","右侧","url","new","修改","0","w","23","条件","1","699.99","一般","变量","unitprice","和","tmpl","x","中","varname",".","age","号","names","不","err","空白","方法","execute","所有","%","-","interface","<","end","result","with","必须","当","array","arg2","0.0","替代","除数",",","对象","类型","{","/","不能","main","成立","]","localhost","func","相同","val","666","索引","http","（","\"","numbers","处理","starting","handlefunc","gt","并","逻辑","为","将","}"," ","fmt","操作","来","剔除","来说","go","通过","获得","时","迭代","在","符号","一般来说","int","直接","相关","语法","*","r","`","、","值","作为","println","fprintf","quantity","美元","返回","包括","起来","request","query","v","渲染","不等","alice","内容","bob","使用","template","k","模板","serve","7","package","不等式","8000","age1","括","strconv","的","左侧","三种","lt","test","18","部分","else","调用","ge","listenandserve","slice","carol","yiszero","表示","实例","定义","10","[","11000","parseint","text","name2","nil","log","bool","用法","fatal","属于","赋值","一部","量值","03","后面","string","!","名字","5","phone","）","float64","解析","map","数组","64","判断","年龄","一部分","name1","：","一个",")","false","类似","i","前缀",":","ne","if","变量值","进阶",">","3","inventory","get","不同","return","eq","name"],"title":"03：进阶模板用法","title_tokens":["模板","用法","进阶","：","03"]},{"location":"Golang/Go-Web/03 AdvanceTemplateUsage/#03","text":"","text_tokens":[],"title":"03：进阶模板用法","title_tokens":["模板","用法","进阶","：","03"]},{"location":"Golang/Go-Web/03 AdvanceTemplateUsage/#_1","text":"package main import ( \"fmt\" \"log\" \"net/http\" \"text/template\" ) func main () { http . HandleFunc ( \"/\" , func ( w http . ResponseWriter , r * http . Request ) { tmpl , err := template . New ( \"test\" ). Parse ( ` {{$name := \"Alice\"}} {{$age := 18}} {{$round2 := true}} Name: {{$name}} Age: {{$age}} Round2: {{$round2}} ` ) if err != nil { fmt . Fprintf ( w , \"Parse: %v\" , err ) return } err = tmpl . Execute ( w , nil ) if err != nil { fmt . Fprintf ( w , \"Execute: %v\" , err ) return } }) log . Println ( \"starting HTTP serve...\" ) log . Fatal ( http . ListenAndServe ( \":8000\" , nil )) } 用美元符号 $ 作为前缀表示变 $name , $age 变量的定义/赋值必须使用 := 语法 直接通过 {{$VarName}} 调用 所有变量的操作都属于模板语法的一部分,需要用 {{}} 括起来","text_tokens":["都","=","...","parse","(","import","true","responsewriter","需要","变","net","round2","用","$","new","w","变量","tmpl","varname",".","age","err","execute","所有","%","必须",",","{","/","main","func","http","\"","starting","handlefunc","操作","}"," ","fmt","通过","符号","直接","语法","*","r","`","作为","println","fprintf","美元","起来","request","v","alice","使用","template","模板","serve","package","8000","括","的","test","18","部分","调用","listenandserve","表示","定义","text","nil","log","fatal","属于","赋值","一部","!","一部分",")","前缀",":","if","return","name"],"title":"在模板中定义变量","title_tokens":["模板","在","变量","定义","中"]},{"location":"Golang/Go-Web/03 AdvanceTemplateUsage/#_2","text":"... tmpl , err := template . New ( \"test\" ). Parse ( ` {{$name := \"Alice\"}} {{$age := 18}} {{$round2 := true}} Name: {{$name}} Age: {{$age}} Round2: {{$round2}} {{$name = \"K\"}} Name: {{$name}} ` ) ... 类似赋值, 用 = 号直接修改变量值","text_tokens":["test",".","age","18","号","err","=","...","直接","parse","`","(","true","赋值","量值",",","round2","{","用","$","alice",")","类似","template","k","new","\"","修改",":","}","变量值","变量"," ","tmpl","name"],"title":"修改变量的值","title_tokens":["值","变量","的","修改"]},{"location":"Golang/Go-Web/03 AdvanceTemplateUsage/#if","text":"package main import ( \"fmt\" \"log\" \"net/http\" \"strconv\" \"text/template\" ) func main () { http . HandleFunc ( \"/\" , func ( w http . ResponseWriter , r * http . Request ) { tmpl , err := template . New ( \"test\" ). Parse ( ` {{if .yIsZero}} 除数不能为0 {{else}} {{.result}} {{end}} ` ) if err != nil { fmt . Fprintf ( w , \"Parse: %v\" , err ) return } x , _ := strconv . ParseInt ( r . URL . Query (). Get ( \"x\" ), 10 , 64 ) y , _ := strconv . ParseInt ( r . URL . Query (). Get ( \"y\" ), 10 , 64 ) yIsZero := y == 0 result := 0.0 if ! yIsZero { result = float64 ( x ) / float64 ( y ) } err = tmpl . Execute ( w , map [ string ] interface {}{ \"yIsZero\" : yIsZero , \"result\" : result , }) if err != nil { fmt . Fprintf ( w , \"Execute: %v\" , err ) } }) log . Println ( \"starting HTTP serve...\" ) log . Fatal ( http . ListenAndServe ( \":8000\" , nil )) } 用 {{}} 将 if 逻辑语句括起来, if 后面必须返回一个 bool 值 if 语句包括 {{if}} , {{else}} , {{end}}","text_tokens":["_","=","...","y","parse","(","import","responsewriter","net","语句","用","url","new","0","w","x","tmpl",".","err","execute","%","interface","end","result","必须","0.0","除数",",","{","/","不能","main","]","func","http","\"","starting","handlefunc","逻辑","为","将"," ","}","fmt","*","r","`","值","println","fprintf","返回","包括","起来","request","query","v","template","serve","package","8000","括","strconv","test","else","listenandserve","yiszero","10","[","parseint","text","nil","log","bool","fatal","后面","string","!","float64","map","64","一个",")",":","if","get","return"],"title":"在模板中使用条件判断(if)","title_tokens":["(","模板","条件","if","判断","在",")","使用","中"]},{"location":"Golang/Go-Web/03 AdvanceTemplateUsage/#_3","text":"eq ：当等式 arg1 == arg2 成立时，返回 true，否则返回 false ne ：当不等式 arg1 != arg2 成立时，返回 true，否则返回 false lt ：当不等式 arg1 < arg2 成立时，返回 true，否则返回 false le ：当不等式 arg1 <= arg2 成立时，返回 true，否则返回 false gt ：当不等式 arg1 > arg2 成立时，返回 true，否则返回 false ge ：当不等式 arg1 >= arg2 成立时，返回 true，否则返回 false package main import ( \"fmt\" \"log\" \"net/http\" \"text/template\" ) func main () { http . HandleFunc ( \"/\" , func ( w http . ResponseWriter , r * http . Request ) { tmpl , err := template . New ( \"test\" ). Parse ( ` {{$name1 := \"alice\"}} {{$name2 := \"bob\"}} {{$age1 := 18}} {{$age2 := 23}} {{if eq $age1 $age2}} 年龄相同 {{else}} 年龄不同 {{end}} {{if ne $name1 $name2}} 名字不相同 {{end}} ` ) if err != nil { fmt . Fprintf ( w , \"Parse: %v\" , err ) return } err = tmpl . Execute ( w , nil ) if err != nil { fmt . Fprintf ( w , \"Execute: %v\" , err ) return } }) log . Println ( \"Starting HTTP server...\" ) log . Fatal ( http . ListenAndServe ( \"localhost:8000\" , nil )) }","text_tokens":["等式","=","...","parse","server","(","否则","import","true","age2","le","responsewriter","net","，","arg1","$","new","w","23","tmpl",".","不","err","execute","%","<","end","当","arg2",",","{","/","成立","main","localhost","func","相同","http","\"","starting","handlefunc","gt","}"," ","fmt","时","*","r","`","println","fprintf","返回","request","v","不等","alice","bob","template","不等式","package","8000","age1","lt","test","18","else","ge","listenandserve","text","name2","nil","log","fatal","!","名字","年龄","name1","：","false",")",":","ne","if",">","不同","return","eq"],"title":"等式和不等式","title_tokens":["等式","和","不等","不等式"]},{"location":"Golang/Go-Web/03 AdvanceTemplateUsage/#range","text":"Go 语言中一般来说有三种类型可以进行迭代操作，数组（Array）、切片（Slice）和 map 类型 package main import ( \"fmt\" \"log\" \"net/http\" \"text/template\" ) func main () { http . HandleFunc ( \"/\" , func ( w http . ResponseWriter , r * http . Request ) { tmpl , err := template . New ( \"test\" ). Parse ( ` {{range $name := .Names}} {{$name}} {{end}} ` ) if err != nil { fmt . Fprintf ( w , \"Parse: %v\" , err ) return } err = tmpl . Execute ( w , map [ string ] interface {}{ \"Names\" : [] string { \"Alice\" , \"Bob\" , \"Carol\" , \"David\" , }, }) if err != nil { fmt . Fprintf ( w , \"Execute: %v\" , err ) return } }) log . Println ( \"Starting HTTP server...\" ) log . Fatal ( http . ListenAndServe ( \"localhost:8000\" , nil )) }","text_tokens":["进行","可以","=","...","parse","server","(","import","range","有","responsewriter","net","david","，","切片","语言","$","new","w","一般","和","tmpl","中",".","names","err","execute","%","interface","end","array",",","类型","{","/","main","]","localhost","func","（","http","\"","starting","handlefunc"," ","}","操作","fmt","来说","go","迭代","一般来说","*","r","、","`","println","fprintf","request","v","alice","bob","template","package","8000","三种","test","slice","listenandserve","carol","[","text","nil","log","fatal","string","!","）","map","数组",")",":","if","return","name"],"title":"迭代操作(range)","title_tokens":["(","range","迭代",")","操作"]},{"location":"Golang/Go-Web/03 AdvanceTemplateUsage/#_4","text":"... func main () { http . HandleFunc ( \"/\" , func ( w http . ResponseWriter , r * http . Request ) { // 创建模板对象并解析模板内容 tmpl , err := template . New ( \"test\" ). Parse ( ` {{range $i, $name := .Names}} {{$i}}. {{$name}} {{end}} ` ) ...","text_tokens":["test",".","names","err","=","...","parse","*","(","r","`","end","range","responsewriter",",","解析","对象","request","{","/","main","创建","$","内容","func",")","template","http","new","\"","模板","i",":","}","w","handlefunc","并"," ","tmpl","name"],"title":"获得迭代元素的索引","title_tokens":["元素","获得","迭代","的","索引"]},{"location":"Golang/Go-Web/03 AdvanceTemplateUsage/#map","text":"... func main () { http . HandleFunc ( \"/\" , func ( w http . ResponseWriter , r * http . Request ) { // 创建模板对象并解析模板内容 tmpl , err := template . New ( \"test\" ). Parse ( ` {{range $name, $val := .}} {{$name}}: {{$val}} {{end}} ` ) ... // 调用模板对象的渲染方法 err = tmpl . Execute ( w , map [ string ] interface {}{ \"Names\" : [] string { \"Alice\" , \"Bob\" , \"Carol\" , \"David\" , }, \"Numbers\" : [] int { 1 , 3 , 5 , 7 }, }) ... }","text_tokens":["test",".","names","的","调用","carol","err","方法","=","execute","...","int","[","interface","parse","*","(","r","`","end","range","responsewriter","5","string","david",",","解析","对象","map","request","{","/","main","渲染","创建","$","alice","内容","]","func","val",")","bob","template","http","new","\"","模板","numbers",":","}","w","handlefunc","1","并","7","3"," ","tmpl","name"],"title":"map类型","title_tokens":["类型","map"]},{"location":"Golang/Go-Web/03 AdvanceTemplateUsage/#with","text":"tmpl , err := template . New ( \"test\" ). Parse ( `Inventory {{with .Inventory}} SKU: {{.SKU}} Name: {{.Name}} UnitPrice: {{.UnitPrice}} Quantity: {{.Quantity}} {{end}} ` ) //****************************// err = tmpl . Execute ( w , map [ string ] interface {}{ \"Inventory\" : Inventory { // 类型 SKU : \"11000\" , Name : \"Phone\" , UnitPrice : 699.99 , Quantity : 666 , }, }) 1. 用 {{with}} 来替代相关实例\" Inventory \".","text_tokens":["test",".","err","=","execute","来","实例","sku","[","interface","11000"," ","`","(","parse","end","*","with","quantity","phone","string","替代",",","map","类型","{","/","用","]","666",")","template","new","\"",":","w","1","699.99","unitprice","inventory","相关","}","tmpl","name"],"title":"with","title_tokens":["with"]},{"location":"Golang/Go-Web/03 AdvanceTemplateUsage/#_5","text":"{{- 表示剔除模板内容 左侧 的所有空白符号, -}} 表示剔除模板内容 右侧 的所有空白符号. ... func main () { http . HandleFunc ( \"/\" , func ( w http . ResponseWriter , r * http . Request ) { // 创建模板对象并解析模板内容 tmpl , err := template . New ( \"test\" ). Parse ( `Inventory {{- with .Inventory}} SKU: {{.SKU}} Name: {{.Name}} UnitPrice: {{.UnitPrice}} Quantity: {{.Quantity}} {{- end}} ` ) ...","text_tokens":["test",".","表示","空白","err","=","符号","所有","...","-","sku"," ","*","(","r","parse","`","with","end","quantity","tmpl","responsewriter",",","解析","对象","request","name","{","/","main","创建","右侧","内容","func",")","template","http","new","\"","模板",":","w","handlefunc","并","剔除","unitprice","inventory","的","左侧","}"],"title":"空白符号处理","title_tokens":["空白","处理","符号"]},{"location":"Golang/Project/gee/05 HTMLTemplate/","text":"实现静态资源服务（Static Resource） 支持HTML模板渲染 后端专注数据生成，RESTful接口返回结构化数值；前端专注界面设计实现，只需要考虑拿到数据后如何渲染的问题，前后端解耦。 todo: 通过 filepath 的相对地址映射到 /usr/web 目录下的真实地址，将真实地址交给 net/http 的 http.FileServer 处理","text_tokens":[".","的","到","目录","通过","数值","静态","后","下","耦","问题","restful"," ","html","界面","界面设计","todo","数据","static","返回","结构","web","filepath","支持","真实","resource","前后","需要","usr","服务","如何","net","）","；","。","，","fileserver","端解","/","设计","渲染","地址映射","生成","前端","考虑","（","http","映射","模板","只","处理",":","地址","端","结构化","实现","专注","接口","交给","将","资源","相对","拿到"],"title":"05 HTMLTemplate","title_tokens":["05"," ","htmltemplate"]},{"location":"Golang/Project/go-gin-example/01 Config/","text":"go-gin-example 01：配置 Golang 环境安装配置 下载 配置环境变量 文件配置 $ mkdir go-gin-example && cd go-gin-example $ go env -w GO111MODULE = on $ go env -w GOPROXY = https://goproxy.cn,direct $ go mod init [ MODULE_PATH ] $ ls > go.mod mkdir go-gin-example && cd go-gin-example ：创建并切换到项目目录。 go env -w GO111MUDOLE=on ：打开Go module 开关。 go env -w GOPROXY=... ：设置GOPROXY代理，第一个为七牛Go代理， direct 为Go在拉取模块遇到错误会回源到原模块版本的源地址去抓取。 go mod init [Module_Path] ：初始化Go module，产生go.mod文件 module go-gin-example go 1 .12 GOMODULE基础使用 go get ：拉取新的依赖 拉取最新的版本： go get golang/org/x/text@lastest 拉取 master 分支的最新commit： go get golang.org/x/text@master go tidy ：整理依","text_tokens":["_","=","...","master","依赖","配置","代理","，","创建","抓取","@","安装","$","第一","commit","gomodule","w","环境变量","初始","1","开关","下载","变量","x","gin","mkdir",".","到","module","切换","-","最新","01","path","org","文件","env","golang","。",",","设置","模块","/","打开","]","依","cn","go111mudole","新","direct","地址","去","并","拉取","为"," ","mod","为七牛","分支","目录","go","go111module","on","example","ls","在","初始化","tidy","回源","版本","产生","https","cd","整理","错误","项目","使用","源地址","原","环境","的","&&","[","text","基础","init","lastest","环境变","遇到","源地","第一个","：","一个","12",":","会",">","get","goproxy"],"title":"go-gin-example 01：配置","title_tokens":["01","配置","go","example","：","-","gin"," "]},{"location":"Golang/Project/go-gin-example/01 Config/#go-gin-example-01","text":"","text_tokens":[],"title":"go-gin-example 01：配置","title_tokens":["01","配置","go","example","：","-","gin"," "]},{"location":"Golang/Project/go-gin-example/01 Config/#golang","text":"","text_tokens":[],"title":"Golang 环境安装配置","title_tokens":["环境","安装"," ","golang","配置"]},{"location":"Golang/Project/go-gin-example/01 Config/#_1","text":"","text_tokens":[],"title":"下载","title_tokens":["下载"]},{"location":"Golang/Project/go-gin-example/01 Config/#_2","text":"","text_tokens":[],"title":"配置环境变量","title_tokens":["环境变量","环境","变量","环境变","配置"]},{"location":"Golang/Project/go-gin-example/01 Config/#_3","text":"$ mkdir go-gin-example && cd go-gin-example $ go env -w GO111MODULE = on $ go env -w GOPROXY = https://goproxy.cn,direct $ go mod init [ MODULE_PATH ] $ ls > go.mod mkdir go-gin-example && cd go-gin-example ：创建并切换到项目目录。 go env -w GO111MUDOLE=on ：打开Go module 开关。 go env -w GOPROXY=... ：设置GOPROXY代理，第一个为七牛Go代理， direct 为Go在拉取模块遇到错误会回源到原模块版本的源地址去抓取。 go mod init [Module_Path] ：初始化Go module，产生go.mod文件 module go-gin-example go 1 .12","text_tokens":["mkdir",".","_","为七牛","的","到","module","目录","go","go111module","on","切换","example","=","ls","在","...","初始化","-","[","回源","版本","产生","init","path","文件","env","https","cd","代理","。",",","设置","，","模块","遇到","第一个","源地","/","打开","创建","错误","抓取","$","第一","]","：","一个","cn","项目","12","go111mudole","direct","源地址",":","原","w","mod","地址","去","初始","1","并","开关","会","拉取",">","为","goproxy"," ","&&","gin"],"title":"文件配置","title_tokens":["文件","配置"]},{"location":"Golang/Project/go-gin-example/01 Config/#gomodule","text":"go get ：拉取新的依赖 拉取最新的版本： go get golang/org/x/text@lastest 拉取 master 分支的最新commit： go get golang.org/x/text@master go tidy ：整理依","text_tokens":[".","分支","go","tidy","master","最新"," ","版本","text","依赖","org","lastest","golang","整理","/","@","依","：","commit","新","拉取","get","的","x"],"title":"GOMODULE基础使用","title_tokens":["基础","gomodule","使用"]},{"location":"Golang/Project/go-gin-example/02 API-1/","text":"go-gin-example 02：API-1 初始设置 项目目录 go-gin-example/ ├─conf ├─middleware ├─models ├─pkg ├─routers └─runtime conf：用于存储配置文件 middleware：应用中间件 models：应用数据库模型 pkg：第三方包 routers：路由逻辑处理 runtime：应用运行时数据 添加Go Modules Replace配置本地模块路径 （好像不必要） module go - gin - example go 1.12 require ( ··· ) replace ( . / go - gin - example / conf => . / go - gin - example / pkg / conf . / go - gin - example / middleware => . / go - gin - example / middleware . / go - gin - example / models => . / go - gin - example / models . / go - gin - example / pkg / e => . / go - gin - example / pkg / e . / go - gin - example / pkg / setting => . / go - gin - example / pkg / setting . / go - gin - example / pkg / util => . / go - gin - example / pkg / util . / go - gin - example / routers => . / go - gin - example / routers ) # 用 replace 将其指定读取本地的模块路径 ， 这样子就可以解决本地模块读取的问题 使用ini配置文件库/编写项目配置包 应用配置文件 将公共配置部分提取出来，写成专门的配置文件，统一写数据库环境、服务器环境等。 在 ./conf 目录下新建 app.ini 文件 定义RUN_MODE 定义数据库端口、账号、表格等 定义公共参数：分页 定义服务器端口、TIMEOUT时间等 # debug or release RUN_MODE = debug [app] PAGE_SIZE = 10 JWT_SECRET = 23347$040412 [server] HTTP_PORT = 8000 READ_TIMEOUT = 60 WRITE_TIMEOUT = 60 [database] TYPE = mysql USER = root # 数据库账号 PASSWORD = root # 数据库密码 HOST = 127.0.0.1:3306 # 数据库IP:数据库端口号 NAME = blog TABLE_PREFIX = blog_ 调用配置的setting模块 负责调用app.ini go get -u github.com/go-ini/ini 在 ./pkg/setting 目录下新建 setting.go 文件 package setting import ( \"log\" \"time\" \"github.com/go-ini/ini\" ) var ( Cfg * ini . File // Cfg为ini文件类型 // 声明app.ini文件写好的各种配置的类型 RunMode string HTTPPort int ReadTimeout time . Duration WriteTimeout time . Duration PageSize int JwtSecret string ) func init () { var err error // 加载初始化文件 Cfg , err = ini . Load ( \"conf/app.ini\" ) if err != nil { log . Fatalf ( \"Fail to parse 'conf/app.ini`: %v\" , err ) } LoadBase () LoadServer () LoadApp () } // 加载基础设置 func LoadBase () { // 设置RUN_MODE为'debug' RunMode = Cfg . Section ( \"\" ). Key ( \"RUN_MODE\" ). MustString ( \"debug\" ) } // LoadServer 加载服务器配置 func LoadServer () { // 获取'server'的section信息 // 这里的section包含'server'的各种信息, 由./config/app,ini配置文件提供 sec , err := Cfg . GetSection ( \"server\" ) if err != nil { log . Fatalf ( \"Fail to get section 'server':%v\" , err ) } RunMode = Cfg . Section ( \"\" ). Key ( \"RUN_MODE\" ). MustString ( \"debug\" ) // 自动类型转换 HTTPPort = sec . Key ( \"HTTP_PORT\" ). MustInt ( 8000 ) ReadTimeout = time . Duration ( sec . Key ( \"READ_TIMEOUT\" ). MustInt ( 60 )) * time . Second WriteTimeout = time . Duration ( sec . Key ( \"WRITE_TIMEOUT\" ). MustInt ( 60 )) * time . Second } // LoadApp 加载APP配置 func LoadApp () { // 获取./config/app.ini配置文件的APP配置 sec , err := Cfg . GetSection ( \"app\" ) if err != nil { log . Fatalf ( \"Fail to get section 'app':%v\" , err ) } JwtSecret = sec . Key ( \"JWT_SECRET\" ). MustString ( \"!@)*#)!@U#@*!@!)\" ) PageSize = sec . Key ( \"PAGE_SIZE\" ). MustInt ( 10 ) } API错误码包 建立错误码e模块 在 ./pkg/e 目录下新建 code.go 和 msg.go 文件 code.go package e // API错误代码 const ( SUCCESS = 200 ERROR = 500 INVALID_PARAMS = 400 ERROR_EXIST_TAG = 10001 ERROR_NOT_EXIST_TAG = 10002 ERROR_NOT_EXIST_ARTICLE = 10003 ERROR_AUTH_CHECK_TOKEN_FAIL = 20001 ERROR_AUTH_CHECK_TOKEN_TIMEOUT = 20002 ERROR_AUTH_TOKEN = 20003 ERROR_AUTH = 20004 ) msg.go package e //msg.go // MsgFlags 错误信息 var MsgFlags = map [ int ] string { SUCCESS : \"ok\" , ERROR : \"fail\" , INVALID_PARAMS : \"请求参数错误\" , ERROR_EXIST_TAG : \"已存在该标签名称\" , ERROR_NOT_EXIST_TAG : \"该标签不存在\" , ERROR_NOT_EXIST_ARTICLE : \"该文章不存在\" , ERROR_AUTH_CHECK_TOKEN_FAIL : \"Token鉴权失败\" , ERROR_AUTH_CHECK_TOKEN_TIMEOUT : \"Token鉴权超时\" , ERROR_AUTH_TOKEN : \"Token生成失败\" , ERROR_AUTH : \"Token错误\" , } // GetMsg 获取错误信息 func GetMsg ( code int ) string { msg , ok := MsgFlags [ code ] if ok { return msg } return MsgFlags [ ERROR ] } 工具包 公共方法：例如获取分页页码等 go get -u github.com/unknwon/com 在 ./pkg/util 目录下新建 pagination.go 文件 package util import ( setting \"go-gin-example/pkg/settings\" \"github.com/gin-gonic/gin\" \"github.com/unknwon/com\" ) // GetPage 获取page数量 func GetPage ( c * gin . Context ) int { result := 0 // page转换为int page , _ := com . StrTo ( c . Query ( \"page\" )). Int () if page > 0 { result = ( page - 1 ) * setting . PageSize } return result } 数据库模型映射 通过gorm将golang结构体映射到数据库中自动生成模型 go get -u github.com/jinzhu/gorm go get -u github.com/go-sql-driver/mysql 在 ./models 目录下新建 models.go 文件。 package models import ( \"fmt\" setting \"go-gin-example/pkg/settings\" \"log\" \"github.com/jinzhu/gorm\" ) var db * gorm . DB // Model 数据库模型 type Model struct { ID int `gorm:\"primary_key\" json:id` CreatedOn int `json:\"created_on\"` ModifiedOn int `json:\"modified_on\"` } func init () { var ( err error dbType , dbName , user , password , host , tablePrefix string ) // 获取配置文件的数据库配置 sec , err := setting . Cfg . GetSection ( \"database\" ) if err != nil { log . Fatal ( 2 , \"Fail to get get scetion `database`:%v\" , err ) } dbType = sec . Key ( \"TYPE\" ). String () dbName = sec . Key ( \"NAME\" ). String () user = sec . Key ( \"USER\" ). String () password = sec . Key ( \"PASSWORD\" ). String () host = sec . Key ( \"HOST\" ). String () tablePrefix = sec . Key ( \"TABLE_PREFIX\" ). String () db , err = gorm . Open ( dbtype , fmt . Sprintf ( \"%s:%s@tcp(%s)/%s?charset=utf8&parseTime=True&loc=Local\" , user , password , dbName )) if err != nil { log . Println ( err ) } gorm . DefaultTableNameHandler = func ( db * gorm . DB , defaultTableName string ) string { return tablePrefix + defaultTableName } db . SingularTable ( true ) db . LogMode ( true ) db . DB (). SetMaxIdleConns ( 10 ) db . DB (). SetMaxOpenConns ( 100 ) } // CloseDB 关闭数据库连接 func CloseDB () { defer db . Close () } Demo 实例程序 在 ./ 目录下新建 main.go 文件 package main import ( \"fmt\" setting \"go-gin-example/pkg/settings\" \"net/http\" \"github.com/gin-gonic/gin\" ) func main () { router := gin . Default () router . GET ( \"/test\" , func ( c * gin . Context ) { c . JSON ( 200 , gin . H { \"message\" : \"test\" , }) }) s := & http . Server { Addr : fmt . Sprintf ( \":%d\" , setting . HTTPPort ), Handler : router , ReadTimeout : setting . ReadTimeout , WriteTimeout : setting . WriteTimeout , MaxHeaderBytes : 1 << 20 , } // 调用在&http.Server中设置的参数,因此上面要用&,要改变参数的值 s . ListenAndServe () } 浏览器输入 localhost：8000/test 返回 {\"message\":\"test\"} 则成功 从main.go中分离路由 在 ./routers 目录下新建 router.go 文件 package routers import ( setting \"go-gin-example/pkg/settings\" \"github.com/gin-gonic/gin\" ) func InitRouter () * gin . Engine { r := gin . New () r . Use ( gin . Logger ()) r . Use ( gin . Recovery ()) gin . SetMode ( setting . RunMode ) r . GET ( \"/test\" , func ( c * gin . Context ) { c . JSON ( 200 , gin . H { \"message\" : \"test\" , }) }) return r } 修改 main.go 文件 package main import ( \"fmt\" setting \"go-gin-example/pkg/settings\" \"go-gin-example/routers\" \"net/http\" ) func main () { router := routers . InitRouter () s := & http . Server { Addr : fmt . Sprintf ( \":%d\" , setting . HTTPPort ), Handler : router , ReadTimeout : setting . ReadTimeout , WriteTimeout : setting . WriteTimeout , MaxHeaderBytes : 1 << 20 , } s . ListenAndServer () } 当前目录结构 go-gin-example/ ├── conf │ └── app.ini ├── main.go ├── middleware ├── models │ └── models.go ├── pkg │ ├── e │ │ ├── code.go │ │ └── msg.go │ ├── setting │ │ └── setting.go │ └── util │ └── pagination.go ├── routers │ └── router.go ├── runtime","text_tokens":["_","or","table","不必","声明","server","logmode","getmsg","router","关闭","20003","040412","writetimeout","article","统一","code","$","new","error","从","tcp","type","改变","password","运行","和","util","gin","中",".","token","新建","好像","loc","err","方法","浏览器","-","这","<","存在","getsection","result","handler","文件","logger","必要","·","main","提供","func","处理","config","settings","为","db","将","当前","runmode","example","账号","s","invalid","*","r","值","app","routers","v","文件类型","使用","engine","20002","端口","超时","02","10001","误信","loadserver","addr","blog","实例","定义","数量","httpport","init","exist","nil","log","string","127.0","）","浏览","400","：","setmaxidleconns","dbname","mode","配置文件","20004","sprintf","closedb","e","程序","write","parse","second","(","jwt","true","id","to","配置","check","20","database","release","@","1.12","struct","tag","等","修改","context","标签","demo","读取","本地","到","用于","由","model","tableprefix","20001","primary","工具","prefix","golang","密码","defaulttablenamehandler","端口号",",","设置","+","/","created","fatalf","错误信息","timeout","（","muststring","映射","duration","}","on","时","initrouter","在","2","误码","`","页码","mysql","setmaxopenconns","写","parsetime","上面","query","表格","?","msg","load","自动","则","500","环境","体","的","模型","section","调用","listenandserve","json","modules","包含","鉴权","100","map","出来","200","var","第三方","middleware",":","setting","if","连接","maxheaderbytes","23347","modified","mustint","可以","close","=","0.1","import","库","debug","加载","例如","工具包","use","message","utf8","用","参数","0","错误码","不必要","存储配置","建立","listenandserver","auth","open","不","charset","user","h","%","因此","输入","要","60","结构","api","好","unknwon","。","类型","负责","u","务器","localhost","添加","\"","conf","loadapp","host","分离","要用","go","中间","read","10002","下","初始化","请求","10003","singulartable","应用","专门","服务","失败","secret","存储","3306","错误","服务器端","'","公共","解决","时间","page","&","这里","10","[","据库","基础","setmode","ini","!","jwtsecret","生成","已",")","success","file","fail","├",">","#","包","defer","ip","strto","路径","defaulttablename","问题","当前目录","代码","size","服务器","loadbase","getpage","其","口号","net","jinzhu","，","sql","com","modifiedon","pagination","gonic","就","名称","初始","1","runtime","口","该","github","driver","msgflags","module","中间件","run","文章","ok","分页","数据库","d","模块","{","样子","]","gorm","http","readtimeout","逻辑"," ","fmt","pagesize","目录","通过","编写","获取","recovery","require","int","类型转换","、","println","params","createdon","路由","返回","not","各种","key","local","port","项目","└","三方","信息","time","package","8000","test","部分","const","指定","第三","scetion","cfg","sec","c","数据","models","fatal","default","写成","root","─","转换","提取","pkg","dbtype","成功","错误代码","│","get","return","replace","name"],"title":"go-gin-example 02：API-1","title_tokens":["1","go","example","api","：","-","02","gin"," "]},{"location":"Golang/Project/go-gin-example/02 API-1/#go-gin-example-02api-1","text":"初始设置","text_tokens":["初始","设置"],"title":"go-gin-example 02：API-1","title_tokens":["1","go","example","api","：","-","02","gin"," "]},{"location":"Golang/Project/go-gin-example/02 API-1/#_1","text":"go-gin-example/ ├─conf ├─middleware ├─models ├─pkg ├─routers └─runtime conf：用于存储配置文件 middleware：应用中间件 models：应用数据库模型 pkg：第三方包 routers：路由逻辑处理 runtime：应用运行时数据","text_tokens":["包","用于","中间件","第三","go","中间","时","模型","example","-","据库","数据库","路由","routers","models","数据","文件","应用","配置","─","/","存储","：","第三方","middleware","pkg","└","处理","conf","三方","runtime","├","存储配置","逻辑","运行"," ","gin"],"title":"项目目录","title_tokens":["项目","目录"]},{"location":"Golang/Project/go-gin-example/02 API-1/#go-modules-replace","text":"module go - gin - example go 1.12 require ( ··· ) replace ( . / go - gin - example / conf => . / go - gin - example / pkg / conf . / go - gin - example / middleware => . / go - gin - example / middleware . / go - gin - example / models => . / go - gin - example / models . / go - gin - example / pkg / e => . / go - gin - example / pkg / e . / go - gin - example / pkg / setting => . / go - gin - example / pkg / setting . / go - gin - example / pkg / util => . / go - gin - example / pkg / util . / go - gin - example / routers => . / go - gin - example / routers ) # 用 replace 将其指定读取本地的模块路径 ， 这样子就可以解决本地模块读取的问题","text_tokens":[".","的","module","指定","go","解决","可以","路径","example","=","require","问题","-","这","(","routers","models","其","util","模块","，","·","/","本地","用","样子","1.12",")","middleware","pkg","就","setting","conf",">","#","e","将","gin"," ","replace","读取"],"title":"添加Go Modules Replace配置本地模块路径 （好像不必要）","title_tokens":["）","模块","配置","好像","不必要","go","modules","本地","路径","（","必要","添加","不必","replace"," "]},{"location":"Golang/Project/go-gin-example/02 API-1/#ini","text":"","text_tokens":[],"title":"使用ini配置文件库/编写项目配置包","title_tokens":["包","配置文件","项目","/","库","编写","文件","ini","使用","配置"]},{"location":"Golang/Project/go-gin-example/02 API-1/#_2","text":"将公共配置部分提取出来，写成专门的配置文件，统一写数据库环境、服务器环境等。 在 ./conf 目录下新建 app.ini 文件 定义RUN_MODE 定义数据库端口、账号、表格等 定义公共参数：分页 定义服务器端口、TIMEOUT时间等 # debug or release RUN_MODE = debug [app] PAGE_SIZE = 10 JWT_SECRET = 23347$040412 [server] HTTP_PORT = 8000 READ_TIMEOUT = 60 WRITE_TIMEOUT = 60 [database] TYPE = mysql USER = root # 数据库账号 PASSWORD = root # 数据库密码 HOST = 127.0.0.1:3306 # 数据库IP:数据库端口号 NAME = blog TABLE_PREFIX = blog_","text_tokens":["_","or","23347","ip","table","=","0.1","write","size","server","jwt","服务器","debug","口号","配置","，","040412","database","release","统一","$","参数","等","口","type","password",".","新建","run","user","分页","数据库","60","文件","prefix","密码","端口号","。","/","务器","]","timeout","http","conf","将"," ","host","目录","read","账号","下","在","、","mysql","写","app","专门","服务","secret","表格","3306","port","服务器端","环境","端口","8000","的","部分","blog","公共","时间","page","定义","10","[","据库","数据","写成","root","ini","127.0","出来","提取","：","mode","配置文件",":","#","name"],"title":"应用配置文件","title_tokens":["配置","文件","配置文件","应用"]},{"location":"Golang/Project/go-gin-example/02 API-1/#setting","text":"负责调用app.ini go get -u github.com/go-ini/ini 在 ./pkg/setting 目录下新建 setting.go 文件 package setting import ( \"log\" \"time\" \"github.com/go-ini/ini\" ) var ( Cfg * ini . File // Cfg为ini文件类型 // 声明app.ini文件写好的各种配置的类型 RunMode string HTTPPort int ReadTimeout time . Duration WriteTimeout time . Duration PageSize int JwtSecret string ) func init () { var err error // 加载初始化文件 Cfg , err = ini . Load ( \"conf/app.ini\" ) if err != nil { log . Fatalf ( \"Fail to parse 'conf/app.ini`: %v\" , err ) } LoadBase () LoadServer () LoadApp () } // 加载基础设置 func LoadBase () { // 设置RUN_MODE为'debug' RunMode = Cfg . Section ( \"\" ). Key ( \"RUN_MODE\" ). MustString ( \"debug\" ) } // LoadServer 加载服务器配置 func LoadServer () { // 获取'server'的section信息 // 这里的section包含'server'的各种信息, 由./config/app,ini配置文件提供 sec , err := Cfg . GetSection ( \"server\" ) if err != nil { log . Fatalf ( \"Fail to get section 'server':%v\" , err ) } RunMode = Cfg . Section ( \"\" ). Key ( \"RUN_MODE\" ). MustString ( \"debug\" ) // 自动类型转换 HTTPPort = sec . Key ( \"HTTP_PORT\" ). MustInt ( 8000 ) ReadTimeout = time . Duration ( sec . Key ( \"READ_TIMEOUT\" ). MustInt ( 60 )) * time . Second WriteTimeout = time . Duration ( sec . Key ( \"WRITE_TIMEOUT\" ). MustInt ( 60 )) * time . Second } // LoadApp 加载APP配置 func LoadApp () { // 获取./config/app.ini配置文件的APP配置 sec , err := Cfg . GetSection ( \"app\" ) if err != nil { log . Fatalf ( \"Fail to get section 'app':%v\" , err ) } JwtSecret = sec . Key ( \"JWT_SECRET\" ). MustString ( \"!@)*#)!@U#@*!@!)\" ) PageSize = sec . Key ( \"PAGE_SIZE\" ). MustInt ( 10 ) }","text_tokens":["_","mustint","=","write","声明","parse","server","(","second","size","jwt","import","服务器","loadbase","debug","to","加载","配置","writetimeout","com","@","error","初始","github",".","由","新建","run","err","%","-","getsection","60","文件","好",",","设置","类型","负责","/","u","{","提供","务器","fatalf","func","timeout","http","muststring","\"","readtimeout","duration","config","conf","为","loadapp","}"," ","pagesize","目录","go","runmode","read","获取","下","在","初始化","int","类型转换","*","`","app","写","服务","secret","各种","key","v","load","文件类型","自动","port","信息","'","time","package","8000","的","section","调用","loadserver","page","这里","cfg","sec","10","httpport","基础","init","nil","log","包含","ini","string","!","jwtsecret","转换","var",")","pkg","file","mode","配置文件",":","setting","fail","if","#","get"],"title":"调用配置的setting模块","title_tokens":["模块","调用","setting","的","配置"]},{"location":"Golang/Project/go-gin-example/02 API-1/#api","text":"建立错误码e模块 在 ./pkg/e 目录下新建 code.go 和 msg.go 文件 code.go package e // API错误代码 const ( SUCCESS = 200 ERROR = 500 INVALID_PARAMS = 400 ERROR_EXIST_TAG = 10001 ERROR_NOT_EXIST_TAG = 10002 ERROR_NOT_EXIST_ARTICLE = 10003 ERROR_AUTH_CHECK_TOKEN_FAIL = 20001 ERROR_AUTH_CHECK_TOKEN_TIMEOUT = 20002 ERROR_AUTH_TOKEN = 20003 ERROR_AUTH = 20004 ) msg.go package e //msg.go // MsgFlags 错误信息 var MsgFlags = map [ int ] string { SUCCESS : \"ok\" , ERROR : \"fail\" , INVALID_PARAMS : \"请求参数错误\" , ERROR_EXIST_TAG : \"已存在该标签名称\" , ERROR_NOT_EXIST_TAG : \"该标签不存在\" , ERROR_NOT_EXIST_ARTICLE : \"该文章不存在\" , ERROR_AUTH_CHECK_TOKEN_FAIL : \"Token鉴权失败\" , ERROR_AUTH_CHECK_TOKEN_TIMEOUT : \"Token鉴权超时\" , ERROR_AUTH_TOKEN : \"Token生成失败\" , ERROR_AUTH : \"Token错误\" , } // GetMsg 获取错误信息 func GetMsg ( code int ) string { msg , ok := MsgFlags [ code ] if ok { return msg } return MsgFlags [ ERROR ] }","text_tokens":["_","=","代码","(","getmsg","20003","check","article","code","参数","tag","名称","错误码","error","该","建立","标签","和","auth",".","msgflags","token","不","新建","文章","20001","存在","ok","文件","api","模块",",","{","/","]","错误信息","func","timeout","\""," ","}","目录","go","10002","获取","下","在","int","invalid","误码","请求","params","10003","not","失败","msg","错误","20002","500","信息","package","超时","10001","误信","const","[","exist","鉴权","string","map","400","200","生成","已","var","success",")","pkg","20004",":","fail","if","错误代码","e","return"],"title":"API错误码包","title_tokens":["包","错误码","错误","api","误码"]},{"location":"Golang/Project/go-gin-example/02 API-1/#_3","text":"公共方法：例如获取分页页码等 go get -u github.com/unknwon/com 在 ./pkg/util 目录下新建 pagination.go 文件 package util import ( setting \"go-gin-example/pkg/settings\" \"github.com/gin-gonic/gin\" \"github.com/unknwon/com\" ) // GetPage 获取page数量 func GetPage ( c * gin . Context ) int { result := 0 // page转换为int page , _ := com . StrTo ( c . Query ( \"page\" )). Int () if page > 0 { result = ( page - 1 ) * setting . PageSize } return result }","text_tokens":[".","_","pagesize","目录","公共","新建","go","strto","page","方法","获取","example","=","下","在","int","-","页码","*","(","数量","c","result","import","分页","文件","getpage","例如","unknwon",",","query","com","/","u","{","转换","pagination","：","gonic","等",")","func","pkg","\"","0","context",":","setting","}","1","return","if","settings","为",">","package","get","gin"," ","util","github"],"title":"工具包","title_tokens":["工具","工具包"]},{"location":"Golang/Project/go-gin-example/02 API-1/#_4","text":"通过gorm将golang结构体映射到数据库中自动生成模型 go get -u github.com/jinzhu/gorm go get -u github.com/go-sql-driver/mysql 在 ./models 目录下新建 models.go 文件。 package models import ( \"fmt\" setting \"go-gin-example/pkg/settings\" \"log\" \"github.com/jinzhu/gorm\" ) var db * gorm . DB // Model 数据库模型 type Model struct { ID int `gorm:\"primary_key\" json:id` CreatedOn int `json:\"created_on\"` ModifiedOn int `json:\"modified_on\"` } func init () { var ( err error dbType , dbName , user , password , host , tablePrefix string ) // 获取配置文件的数据库配置 sec , err := setting . Cfg . GetSection ( \"database\" ) if err != nil { log . Fatal ( 2 , \"Fail to get get scetion `database`:%v\" , err ) } dbType = sec . Key ( \"TYPE\" ). String () dbName = sec . Key ( \"NAME\" ). String () user = sec . Key ( \"USER\" ). String () password = sec . Key ( \"PASSWORD\" ). String () host = sec . Key ( \"HOST\" ). String () tablePrefix = sec . Key ( \"TABLE_PREFIX\" ). String () db , err = gorm . Open ( dbtype , fmt . Sprintf ( \"%s:%s@tcp(%s)/%s?charset=utf8&parseTime=True&loc=Local\" , user , password , dbName )) if err != nil { log . Println ( err ) } gorm . DefaultTableNameHandler = func ( db * gorm . DB , defaultTableName string ) string { return tablePrefix + defaultTableName } db . SingularTable ( true ) db . LogMode ( true ) db . DB (). SetMaxIdleConns ( 10 ) db . DB (). SetMaxOpenConns ( 100 ) } // CloseDB 关闭数据库连接 func CloseDB () { defer db . Close () }","text_tokens":["_","defer","modified","table","defaulttablename","close","=","(","import","true","logmode","id","to","关闭","配置","jinzhu","sql","com","utf8","modifiedon","database","@","struct","error","tcp","type","password","gin","github","driver",".","中","open","到","charset","新建","user","loc","model","err","tableprefix","%","-","primary","getsection","数据库","结构","文件","prefix","golang","defaulttablenamehandler","。",",","+","{","/","u","created","func","gorm","映射","\"","settings","db","将","}"," ","fmt","host","目录","go","通过","on","example","获取","下","在","s","int","2","*","`","mysql","setmaxopenconns","println","createdon","singulartable","parsetime","?","key","v","自动","local","体","package","的","模型","json","&","scetion","cfg","sec","10","据库","init","nil","数据","models","log","fatal","string","!","100","生成","var",")","setmaxidleconns","dbname","pkg","dbtype","配置文件",":","sprintf","setting","fail","if","closedb","连接","get","return","name"],"title":"数据库模型映射","title_tokens":["映射","据库","数据库","数据","模型"]},{"location":"Golang/Project/go-gin-example/02 API-1/#demo","text":"实例程序 在 ./ 目录下新建 main.go 文件 package main import ( \"fmt\" setting \"go-gin-example/pkg/settings\" \"net/http\" \"github.com/gin-gonic/gin\" ) func main () { router := gin . Default () router . GET ( \"/test\" , func ( c * gin . Context ) { c . JSON ( 200 , gin . H { \"message\" : \"test\" , }) }) s := & http . Server { Addr : fmt . Sprintf ( \":%d\" , setting . HTTPPort ), Handler : router , ReadTimeout : setting . ReadTimeout , WriteTimeout : setting . WriteTimeout , MaxHeaderBytes : 1 << 20 , } // 调用在&http.Server中设置的参数,因此上面要用&,要改变参数的值 s . ListenAndServe () } 浏览器输入 localhost：8000/test 返回 {\"message\":\"test\"} 则成功","text_tokens":["=","server","(","import","router","net","message","writetimeout","20","com","gonic","参数","context","1","改变","gin","中","github",".","新建","h","浏览器","%","-","因此","<","输入","handler","要","d","文件",",","设置","{","/","main","localhost","func","http","\"","readtimeout","settings"," ","}","fmt","要用","目录","go","example","下","在","s","*","值","返回","上面","则","package","8000","的","test","调用","addr","listenandserve","json","&","实例","c","httpport","default","浏览","200","：",")","pkg",":","sprintf","setting","成功","maxheaderbytes","get","程序"],"title":"Demo","title_tokens":["demo"]},{"location":"Golang/Project/go-gin-example/02 API-1/#maingo","text":"在 ./routers 目录下新建 router.go 文件 package routers import ( setting \"go-gin-example/pkg/settings\" \"github.com/gin-gonic/gin\" ) func InitRouter () * gin . Engine { r := gin . New () r . Use ( gin . Logger ()) r . Use ( gin . Recovery ()) gin . SetMode ( setting . RunMode ) r . GET ( \"/test\" , func ( c * gin . Context ) { c . JSON ( 200 , gin . H { \"message\" : \"test\" , }) }) return r } 修改 main.go 文件 package main import ( \"fmt\" setting \"go-gin-example/pkg/settings\" \"go-gin-example/routers\" \"net/http\" ) func main () { router := routers . InitRouter () s := & http . Server { Addr : fmt . Sprintf ( \":%d\" , setting . HTTPPort ), Handler : router , ReadTimeout : setting . ReadTimeout , WriteTimeout : setting . WriteTimeout , MaxHeaderBytes : 1 << 20 , } s . ListenAndServer () }","text_tokens":["test",".","addr","目录","新建","go","json","&","runmode","initrouter","example","=","h","下","在","recovery","s","%","-","server","*","(","r","<","c","httpport","import","handler","d","routers","setmode","文件","logger","router","use","net","message",",","writetimeout","20","com","/","{","main","200","gonic","func",")","http","pkg","new","\"","engine","修改",":","context","setting","}","return","sprintf","readtimeout","1","settings","package","maxheaderbytes","listenandserver","get"," ","fmt","gin","github"],"title":"从main.go中分离路由","title_tokens":[".","分离","从","main","go","路由","中"]},{"location":"Golang/Project/go-gin-example/02 API-1/#_5","text":"go-gin-example/ ├── conf │ └── app.ini ├── main.go ├── middleware ├── models │ └── models.go ├── pkg │ ├── e │ │ ├── code.go │ │ └── msg.go │ ├── setting │ │ └── setting.go │ └── util │ └── pagination.go ├── routers │ └── router.go ├── runtime","text_tokens":[".","go","example","-","app","routers","models","router","ini","util","─","/","main","msg","code","pagination","middleware","pkg","└","setting","conf","runtime","├","│","e"," ","gin"],"title":"当前目录结构","title_tokens":["当前目录","结构","当前","目录"]},{"location":"Golang/Project/go-gin-example/03 API-2/","text":"go-gin-example 03：API-2 完成博客的标签类接口定义和编写 定义接口 定义文章标签的路由分发操作 获取标签列表：GET(“/tags”) 新建标签：POST(“/tags”) 更新指定标签：PUT(“/tags/:id”) 删除指定标签：DELETE(“/tags/:id”) 空壳路由 注册路由将请求分发到该路由中，由该API路由中函数处理 在./routers/api 下新建 v1 目录，目录内新建 tag.go 文件代表第一个API大版本 package v1 import ( \"github.com/gin-gonic/gin\" ) // GetTags 获取多个文章标签 func GetTags ( c * gin . Context ) { } // AddTag 新增文章标签 func AddTag ( c * gin . Context ) { } // EditTag 修改文章标签 func EditTag ( c * gin . Context ) { } // DeleteTag 删除文章标签 func DeleteTag ( c * gin . Context ) { } 注册路由 该路由负责分发各个api请求给相应的 handler 者 打开 ./routers 下的 router.go 文件，修改为： package routers import ( setting \"go-gin-example/pkg/settings\" v1 \"go-gin-example/routers/api/v1\" \"github.com/gin-gonic/gin\" ) // InitRouter 初始化路由 func InitRouter () * gin . Engine { r := gin . New () r . Use ( gin . Logger ()) r . Use ( gin . Recovery ()) gin . SetMode ( setting . RunMode ) apiv1 := r . Group ( \"/api/v1\" ) { apiv1 . GET ( \"/tags\" , v1 . GetTags ) apiv1 . POST ( \"/tags\" , v1 . AddTag ) apiv1 . PUT ( \"/tags/:id\" , v1 . EditTag ) apiv1 . DELETE ( \"/tags/:id\" , v1 . DeleteTag ) } return r } 用 go run main.go 检测是否成功注册路由 表单验证 用beego的validation来进行表单校验数据 该 tag.go 模型中继承了 model.Model 结构体外新增了标签结构体中的一些属性，在该文件下除了通过 gorm 映射数据库模型外还添加了对标签的CRUD操作方法，在 ./routers/api/v1/tag.go 中可以调用这些CRUD方法 go get -u github.com/astaxie/beego/validation 在 models 目录下的 tag.go 写入 package models import ( \"time\" \"github.com/jinzhu/gorm\" ) // Tag 标签结构体 // 给结构体赋予json属性, 在c.JSON中会自动转换 type Tag struct { // 继承Model的结构体 Model Name string `json:\"name\"` CreatedBy string `json:\"created_by\"` ModifiedBy string `json:\"modified_by\"` State int `json:\"state\"` } // BeforeCreate 创建标签之前自动补全CreatedOn时间 func ( tag * Tag ) BeforeCreate ( scope * gorm . Scope ) error { scope . SetColumn ( \"CreatedOn\" , time . Now (). Unix ()) return nil } // BeforeUpdate 更新标签之前自动补全ModifiedOn时间 func ( tag * Tag ) BeforeUpdate ( scope * gorm . Scope ) error { scope . SetColumn ( \"ModifiedOn\" , time . Now (). Unix ()) return nil } // GetTags 获取文章标签 func GetTags ( pageNum int , pageSize int , maps interface {}) ( tags [] Tag ) { db . Where ( maps ). Offset ( pageNum ). Limit ( pageSize ). Find ( & tags ) return } // GetTagTotal 获取全部文章标签 func GetTagTotal ( maps interface {}) ( count int ) { db . Model ( & Tag {}). Where ( maps ). Count ( & count ) return } // ExistTagByName 查询文章标签是否存在 func ExistTagByName ( name string ) bool { var tag Tag db . Select ( \"id\" ). Where ( \"name = ?\" , name ). First ( & tag ) if tag . ID > 0 { return true } return false } // ExistTagByID 查询ID文章是否存在 func ExistTagByID ( id int ) bool { var tag Tag db . Select ( \"id\" ). Where ( \"id = ?\" , id ). First ( & tag ) if tag . ID > 0 { return true } return false } // AddTag 添加文章标签 func AddTag ( name string , state int , createdBy string ) bool { db . Create ( & Tag { Name : name , State : state , CreatedBy : createdBy , }) return true } // DeleteTag 删除文章标签 func DeleteTag ( id int ) bool { db . Where ( \"id = ? \" , id ). Delete ( & Tag {}) return true } // EditTag 编辑文章标签 func EditTag ( id int , data interface {}) bool { db . Model ( & Tag {}). Where ( \"id = ? \" , id ). Update ( data ) return true } 编写标签列表的路由逻辑 完善空壳路由 通过 beego/validation 对URL传递进来的参数进行校验，操作为声明 validation.Validation 对象，调用其 .Required 、 .MaxSize 、 .Range 、 .Message 等方法 通过 c.Query 获取URL中 ?name=test&state=1 中的参数， c.DefaultQuery 则支持设置一个默认值 util.GetPage 确保各个接口的 page 处理是一致的 在 ./routers/v1/tag.go 写入 package v1 import ( \"go-gin-example/models\" \"go-gin-example/pkg/e\" setting \"go-gin-example/pkg/settings\" \"go-gin-example/pkg/util\" \"net/http\" \"github.com/astaxie/beego/validation\" \"github.com/gin-gonic/gin\" \"github.com/unknwon/com\" ) // GetTags 获取文章标签 func GetTags ( c * gin . Context ) { // 从URL获取参数 // localhost:8000/tags?name=test&state=1 name := c . Query ( \"name\" ) maps := make ( map [ string ] interface {}) data := make ( map [ string ] interface {}) if name != \"\" { // 如果存在name参数, 将其添加到maps中 maps [ \"name\" ] = name } var state = - 1 // should omit type , it will be inferred if arg := c . Query ( \"state\" ); arg != \"\" { // 如果URL中存在state参数, 且arg不等于空的时候 // 将state转换为int // 添加到maps[\"state\"]中 state = com . StrTo ( arg ). MustInt () maps [ \"state\" ] = state } code := e . SUCCESS // 找到该文章,将其添加到lists中返回 data [ \"lists\" ] = models . GetTags ( util . GetPage ( c ), setting . PageSize , maps ) data [ \"total\" ] = models . GetTagTotal ( maps ) c . JSON ( http . StatusOK , gin . H { \"code\" : code , \"msg\" : e . GetMsg ( code ), \"data\" : data , }) } // AddTag 增加文章标签 func AddTag ( c * gin . Context ) { name := c . Query ( \"name\" ) // state=0代表该标签不存在 // 设置默认值为0 state := com . StrTo ( c . DefaultQuery ( \"state\" , \"0\" )). MustInt () createdBy := c . Query ( \"created_by\" ) valid := validation . Validation {} valid . Required ( name , \"name\" ). Message ( \"名称不能为空\" ) valid . MaxSize ( name , 100 , \"name\" ). Message ( \"名称最长为100字符\" ) valid . Required ( createdBy , \"created_by\" ). Message ( \"创建人不能为空\" ) valid . MaxSize ( createdBy , 100 , \"created_by\" ). Message ( \"创建人最长为100字符\" ) valid . Range ( state , 0 , 1 , \"starte\" ). Message ( \"状态只允许0或1\" ) code := e . INVALID_PARAMS if ! valid . HasErrors () { if ! models . ExistTagByName ( name ) { code = e . SUCCESS models . AddTag ( name , state , createdBy ) } else { code = e . ERROR_EXIST_TAG } } c . JSON ( http . StatusOK , gin . H { \"code\" : code , \"msg\" : e . GetMsg ( code ), \"data\" : make ( map [ string ] string ), }) } // EditTag 修改文章标签 func EditTag ( c * gin . Context ) { id := com . StrTo ( c . Param ( \"id\" )). MustInt () name := c . Query ( \"name\" ) modifiedBy := c . Query ( \"modified_by\" ) valid := validation . Validation {} var state = - 1 if arg := c . Query ( \"state\" ); arg != \"\" { state = com . StrTo ( arg ). MustInt () valid . Range ( state , 0 , 1 , \"state\" ). Message ( \"状态只允许0或1\" ) } valid . Required ( id , \"id\" ). Message ( \"ID不能为空\" ) valid . Required ( modifiedBy , \"modiified_by\" ). Message ( \"修改人不能为空\" ) valid . MaxSize ( modifiedBy , 100 , \"modified_by\" ). Message ( \"修改人最长为100字符\" ) valid . MaxSize ( name , 100 , \"name\" ). Message ( \"名称最长为100字符\" ) code := e . INVALID_PARAMS if ! valid . HasErrors () { code = e . SUCCESS if models . ExistTagByID ( id ) { data := make ( map [ string ] interface {}) data [ \"modified_by\" ] = modifiedBy if name != \"\" { data [ \"name\" ] = name } if state != - 1 { data [ \"state\" ] = state } models . EditTag ( id , data ) } else { // 不存在, 无法修改标签 code = e . ERROR_NOT_EXIST_ARTICLE } } c . JSON ( http . StatusOK , gin . H { \"code\" : code , \"message\" : e . GetMsg ( code ), \"data\" : make ( map [ string ] string ), }) } // DeleteTag 删除文章标签 func DeleteTag ( c * gin . Context ) { id := com . StrTo ( c . Param ( \"id\" )). MustInt () valid := validation . Validation {} valid . Min ( id , 1 , \"id\" ). Message ( \"ID必须大于0\" ) code := e . INVALID_PARAMS if ! valid . HasErrors () { code = e . SUCCESS // 数据库操作 if models . ExistTagByID ( id ) { models . DeleteTag ( id ) } else { code = e . ERROR_NOT_EXIST_TAG } } c . JSON ( http . StatusOK , gin . H { \"code\" : code , \"msg\" : e . GetMsg ( code ), \"data\" : make ( map [ string ] string ), }) }","text_tokens":["_","各个","进行","声明","空壳","range","补全","getmsg","体外","gettags","函数","router","最长","且","了","will","article","一些","创建","code","new","error","从","modiified","type","和","gin","中","util",".","确保","arg","新建","属性","方法","-","给","存在","handler","tags","查询","文件","logger","或","打开","main","func","处理","state","settings","为","db","将","gettagtotal","runmode","example","者","invalid","*","r","版本","完善","routers","astaxie","should","crud","空","modifiedby","engine","状态","定义","by","valid","exist","nil","传递","支持","03","string","beforeupdate","第一个","一致","：","为空","e","(","true","id","人","required","更新","第一","struct","tag","等","修改","context","put","之前","标签","赋予","到","model","maxsize","starte","默认","interface","大","由该","中会",",","设置","对象","允许","/","created","v1","代表","inferred",";","映射","多个","分发","addtag","接口","内","}","haserrors","还","initrouter","在","编辑","2","是否","`","count","如果","find","?","query","msg","自动","则","体","”","的","模型","else","调用","json","新增","写入","lists","100","map","be","大于","var","false","make",":","setting","if","检测","找到","modified","mustint","可以","=","体中","group","now","import","use","setcolumn","message","it","用","参数","删除","0","不","h","existtagbyid","必须","omit","结构","api","外","unknwon","负责","u","edittag","localhost","添加","select","\"","操作","来","first","注册","go","列表","下","初始化","对","请求","beforecreate","create","deletetag","defaultquery","post","existtagbyname","字符","时间","&","page","[","据库","操作方法","scope","setmode","bool","!","接口定义","全部","默认值","delete",")","success","只",">","data","验证","createdby","where","无法","strto","offset","limit","getpage","其","net","jinzhu","，","博客","com","“","modifiedon","gonic","param","完成","url","名称","初始","1","该","相应","github","run","文章","类","beego","数据库","min","total","validation","是","时候","{","不能","unix","]","maps","gorm","http","逻辑"," ","这些","等于","pagesize","目录","通过","编写","进来","获取","除了","recovery","int","校验","、","修改文章","createdon","params","路由","返回","not","apiv1","pagenum","time","package","8000","创建人","test","指定","增加","继承","update","c","数据","models","表单","转换","一个","statusok","pkg","成功","get","return","name"],"title":"go-gin-example 03：API-2","title_tokens":["go","example","：","03","2","-","api","gin"," "]},{"location":"Golang/Project/go-gin-example/03 API-2/#go-gin-example-03api-2","text":"完成博客的标签类接口定义和编写","text_tokens":["接口定义","博客","类","编写","接口","标签","定义","和","的","完成"],"title":"go-gin-example 03：API-2","title_tokens":["go","example","：","03","2","-","api","gin"," "]},{"location":"Golang/Project/go-gin-example/03 API-2/#_1","text":"定义文章标签的路由分发操作 获取标签列表：GET(“/tags”) 新建标签：POST(“/tags”) 更新指定标签：PUT(“/tags/:id”) 删除指定标签：DELETE(“/tags/:id”)","text_tokens":["的","指定","新建","文章","列表","获取","定义"," ","(","tags","路由","id","/","“","delete","更新","：",")","删除",":","分发","put","标签","post","”","get","操作"],"title":"定义接口","title_tokens":["接口","定义"]},{"location":"Golang/Project/go-gin-example/03 API-2/#_2","text":"注册路由将请求分发到该路由中，由该API路由中函数处理 在./routers/api 下新建 v1 目录，目录内新建 tag.go 文件代表第一个API大版本 package v1 import ( \"github.com/gin-gonic/gin\" ) // GetTags 获取多个文章标签 func GetTags ( c * gin . Context ) { } // AddTag 新增文章标签 func AddTag ( c * gin . Context ) { } // EditTag 修改文章标签 func EditTag ( c * gin . Context ) { } // DeleteTag 删除文章标签 func DeleteTag ( c * gin . Context ) { }","text_tokens":["注册",".","到","目录","新建","go","文章","新增","获取","下","在","-","*","(","版本","c","请求","修改文章","import","路由","routers","大","由该","文件","github","deletetag","gettags","函数","api","，","第一个","com","/","{","第一","edittag","v1","gonic","tag","一个",")","func","代表","删除","\"","处理","多个","context","}","修改","分发","该","addtag","标签","package","将","内"," ","gin","中"],"title":"空壳路由","title_tokens":["路由","空壳"]},{"location":"Golang/Project/go-gin-example/03 API-2/#_3","text":"该路由负责分发各个api请求给相应的 handler 者 打开 ./routers 下的 router.go 文件，修改为： package routers import ( setting \"go-gin-example/pkg/settings\" v1 \"go-gin-example/routers/api/v1\" \"github.com/gin-gonic/gin\" ) // InitRouter 初始化路由 func InitRouter () * gin . Engine { r := gin . New () r . Use ( gin . Logger ()) r . Use ( gin . Recovery ()) gin . SetMode ( setting . RunMode ) apiv1 := r . Group ( \"/api/v1\" ) { apiv1 . GET ( \"/tags\" , v1 . GetTags ) apiv1 . POST ( \"/tags\" , v1 . AddTag ) apiv1 . PUT ( \"/tags/:id\" , v1 . EditTag ) apiv1 . DELETE ( \"/tags/:id\" , v1 . DeleteTag ) } return r } 用 go run main.go 检测是否成功注册路由","text_tokens":["各个","=","group","(","import","id","router","gettags","use","，","com","用","gonic","new","修改","初始","put","该","相应","gin","github",".","run","-","给","handler","tags","文件","logger","api",",","负责","打开","/","{","main","edittag","v1","func","\"","分发","addtag","settings","为","}"," ","注册","go","runmode","initrouter","example","者","下","recovery","初始化","是否","*","r","请求","路由","routers","deletetag","apiv1","engine","post","package","的","setmode","delete","：",")","pkg",":","setting","成功","检测","get","return"],"title":"注册路由","title_tokens":["注册","路由"]},{"location":"Golang/Project/go-gin-example/03 API-2/#_4","text":"用beego的validation来进行表单校验数据 该 tag.go 模型中继承了 model.Model 结构体外新增了标签结构体中的一些属性，在该文件下除了通过 gorm 映射数据库模型外还添加了对标签的CRUD操作方法，在 ./routers/api/v1/tag.go 中可以调用这些CRUD方法 go get -u github.com/astaxie/beego/validation 在 models 目录下的 tag.go 写入 package models import ( \"time\" \"github.com/jinzhu/gorm\" ) // Tag 标签结构体 // 给结构体赋予json属性, 在c.JSON中会自动转换 type Tag struct { // 继承Model的结构体 Model Name string `json:\"name\"` CreatedBy string `json:\"created_by\"` ModifiedBy string `json:\"modified_by\"` State int `json:\"state\"` } // BeforeCreate 创建标签之前自动补全CreatedOn时间 func ( tag * Tag ) BeforeCreate ( scope * gorm . Scope ) error { scope . SetColumn ( \"CreatedOn\" , time . Now (). Unix ()) return nil } // BeforeUpdate 更新标签之前自动补全ModifiedOn时间 func ( tag * Tag ) BeforeUpdate ( scope * gorm . Scope ) error { scope . SetColumn ( \"ModifiedOn\" , time . Now (). Unix ()) return nil } // GetTags 获取文章标签 func GetTags ( pageNum int , pageSize int , maps interface {}) ( tags [] Tag ) { db . Where ( maps ). Offset ( pageNum ). Limit ( pageSize ). Find ( & tags ) return } // GetTagTotal 获取全部文章标签 func GetTagTotal ( maps interface {}) ( count int ) { db . Model ( & Tag {}). Where ( maps ). Count ( & count ) return } // ExistTagByName 查询文章标签是否存在 func ExistTagByName ( name string ) bool { var tag Tag db . Select ( \"id\" ). Where ( \"name = ?\" , name ). First ( & tag ) if tag . ID > 0 { return true } return false } // ExistTagByID 查询ID文章是否存在 func ExistTagByID ( id int ) bool { var tag Tag db . Select ( \"id\" ). Where ( \"id = ?\" , id ). First ( & tag ) if tag . ID > 0 { return true } return false } // AddTag 添加文章标签 func AddTag ( name string , state int , createdBy string ) bool { db . Create ( & Tag { Name : name , State : state , CreatedBy : createdBy , }) return true } // DeleteTag 删除文章标签 func DeleteTag ( id int ) bool { db . Where ( \"id = ? \" , id ). Delete ( & Tag {}) return true } // EditTag 编辑文章标签 func EditTag ( id int , data interface {}) bool { db . Model ( & Tag {}). Where ( \"id = ? \" , id ). Update ( data ) return true }","text_tokens":["_","进行","where","modified","可以","offset","体中","=","now","(","import","true","id","补全","limit","体外","gettags","setcolumn","jinzhu","，","了","com","modifiedon","用","一些","创建","更新","struct","tag","删除","0","error","该","之前","标签","type","赋予","github","中",".","文章","属性","model","方法","existtagbyid","-","beego","interface","给","存在","tags","数据库","查询","validation","结构","文件","外","api","中会",",","{","/","u","created","unix","edittag","]","v1","func","maps","添加","gorm","select","映射","\"","state","addtag","db"," ","操作","这些","来","}","gettagtotal","first","pagesize","目录","go","通过","还","获取","除了","下","在","编辑","int","校验","是否","对","`","*","count","beforecreate","createdon","createdby","routers","create","find","deletetag","astaxie","?","crud","modifiedby","自动","pagenum","体","time","package","existtagbyname","的","模型","调用","json","继承","时间","&","新增","update","写入","by","[","c","据库","操作方法","scope","nil","数据","models","表单","bool","string","beforeupdate","全部","delete","转换","var",")","false",":","if",">","data","get","return","name"],"title":"表单验证","title_tokens":["表单","验证"]},{"location":"Golang/Project/go-gin-example/03 API-2/#_5","text":"完善空壳路由 通过 beego/validation 对URL传递进来的参数进行校验，操作为声明 validation.Validation 对象，调用其 .Required 、 .MaxSize 、 .Range 、 .Message 等方法 通过 c.Query 获取URL中 ?name=test&state=1 中的参数， c.DefaultQuery 则支持设置一个默认值 util.GetPage 确保各个接口的 page 处理是一致的 在 ./routers/v1/tag.go 写入 package v1 import ( \"go-gin-example/models\" \"go-gin-example/pkg/e\" setting \"go-gin-example/pkg/settings\" \"go-gin-example/pkg/util\" \"net/http\" \"github.com/astaxie/beego/validation\" \"github.com/gin-gonic/gin\" \"github.com/unknwon/com\" ) // GetTags 获取文章标签 func GetTags ( c * gin . Context ) { // 从URL获取参数 // localhost:8000/tags?name=test&state=1 name := c . Query ( \"name\" ) maps := make ( map [ string ] interface {}) data := make ( map [ string ] interface {}) if name != \"\" { // 如果存在name参数, 将其添加到maps中 maps [ \"name\" ] = name } var state = - 1 // should omit type , it will be inferred if arg := c . Query ( \"state\" ); arg != \"\" { // 如果URL中存在state参数, 且arg不等于空的时候 // 将state转换为int // 添加到maps[\"state\"]中 state = com . StrTo ( arg ). MustInt () maps [ \"state\" ] = state } code := e . SUCCESS // 找到该文章,将其添加到lists中返回 data [ \"lists\" ] = models . GetTags ( util . GetPage ( c ), setting . PageSize , maps ) data [ \"total\" ] = models . GetTagTotal ( maps ) c . JSON ( http . StatusOK , gin . H { \"code\" : code , \"msg\" : e . GetMsg ( code ), \"data\" : data , }) } // AddTag 增加文章标签 func AddTag ( c * gin . Context ) { name := c . Query ( \"name\" ) // state=0代表该标签不存在 // 设置默认值为0 state := com . StrTo ( c . DefaultQuery ( \"state\" , \"0\" )). MustInt () createdBy := c . Query ( \"created_by\" ) valid := validation . Validation {} valid . Required ( name , \"name\" ). Message ( \"名称不能为空\" ) valid . MaxSize ( name , 100 , \"name\" ). Message ( \"名称最长为100字符\" ) valid . Required ( createdBy , \"created_by\" ). Message ( \"创建人不能为空\" ) valid . MaxSize ( createdBy , 100 , \"created_by\" ). Message ( \"创建人最长为100字符\" ) valid . Range ( state , 0 , 1 , \"starte\" ). Message ( \"状态只允许0或1\" ) code := e . INVALID_PARAMS if ! valid . HasErrors () { if ! models . ExistTagByName ( name ) { code = e . SUCCESS models . AddTag ( name , state , createdBy ) } else { code = e . ERROR_EXIST_TAG } } c . JSON ( http . StatusOK , gin . H { \"code\" : code , \"msg\" : e . GetMsg ( code ), \"data\" : make ( map [ string ] string ), }) } // EditTag 修改文章标签 func EditTag ( c * gin . Context ) { id := com . StrTo ( c . Param ( \"id\" )). MustInt () name := c . Query ( \"name\" ) modifiedBy := c . Query ( \"modified_by\" ) valid := validation . Validation {} var state = - 1 if arg := c . Query ( \"state\" ); arg != \"\" { state = com . StrTo ( arg ). MustInt () valid . Range ( state , 0 , 1 , \"state\" ). Message ( \"状态只允许0或1\" ) } valid . Required ( id , \"id\" ). Message ( \"ID不能为空\" ) valid . Required ( modifiedBy , \"modiified_by\" ). Message ( \"修改人不能为空\" ) valid . MaxSize ( modifiedBy , 100 , \"modified_by\" ). Message ( \"修改人最长为100字符\" ) valid . MaxSize ( name , 100 , \"name\" ). Message ( \"名称最长为100字符\" ) code := e . INVALID_PARAMS if ! valid . HasErrors () { code = e . SUCCESS if models . ExistTagByID ( id ) { data := make ( map [ string ] interface {}) data [ \"modified_by\" ] = modifiedBy if name != \"\" { data [ \"name\" ] = name } if state != - 1 { data [ \"state\" ] = state } models . EditTag ( id , data ) } else { // 不存在, 无法修改标签 code = e . ERROR_NOT_EXIST_ARTICLE } } c . JSON ( http . StatusOK , gin . H { \"code\" : code , \"message\" : e . GetMsg ( code ), \"data\" : make ( map [ string ] string ), }) } // DeleteTag 删除文章标签 func DeleteTag ( c * gin . Context ) { id := com . StrTo ( c . Param ( \"id\" )). MustInt () valid := validation . Validation {} valid . Min ( id , 1 , \"id\" ). Message ( \"ID必须大于0\" ) code := e . INVALID_PARAMS if ! valid . HasErrors () { code = e . SUCCESS // 数据库操作 if models . ExistTagByID ( id ) { models . DeleteTag ( id ) } else { code = e . ERROR_NOT_EXIST_TAG } } c . JSON ( http . StatusOK , gin . H { \"code\" : code , \"msg\" : e . GetMsg ( code ), \"data\" : make ( map [ string ] string ), }) }","text_tokens":["_","进行","各个","无法","modified","strto","mustint","=","声明","(","空壳","import","range","id","人","getmsg","getpage","其","gettags","required","最长","net","message","且","，","will","com","it","article","code","创建","参数","tag","等","gonic","param","url","删除","名称","0","context","error","修改","从","1","modiified","该","标签","type","gin","util","中",".","github","确保","到","arg","不","文章","maxsize","方法","h","starte","existtagbyid","默认","-","beego","interface","存在","必须","tags","数据库","omit","min","total","validation","是","时候","unknwon","允许",",","设置","对象","或","{","/","不能","created","edittag","localhost","v1","func","maps","]","添加","inferred","代表","http",";","\"","处理","state","接口","settings","addtag","为","将"," ","操作","}","gettagtotal","等于","haserrors","pagesize","go","通过","进来","获取","example","在","int","校验","invalid","对","*","、","完善","修改文章","params","createdby","路由","routers","如果","返回","deletetag","defaultquery","not","astaxie","should","query","?","msg","空","modifiedby","则","package","8000","existtagbyname","创建人","的","test","else","调用","增加","状态","字符","json","&","page","写入","by","[","valid","c","据库","exist","数据","models","lists","传递","支持","string","!","100","map","默认值","转换","一致","be","大于","一个",")","var","success","statusok","make","pkg","只",":","为空","setting","if","data","e","找到","name"],"title":"编写标签列表的路由逻辑","title_tokens":["路由","编写","列表","逻辑","标签","的"]},{"location":"Golang/Project/go-gin-example/04 API-3/","text":"go-gin-example 04：API-3 完成博客的文章类接口定义和编写 定义接口 定义文章的路由分发操作 获取文章列表：GET(“/articles”) 获取单篇文章：GET(“/articles/:id”) 更新文章：PUT(“/articles/:id”) 新建文章：POST(“/articles”) 删除文章：DELETE(“/tags/:id”) 空壳路由 文章请求处理API 在 ./routers/api/v1 下新建 article.go 文件 package v1 import ( \"go-gin-example/models\" \"go-gin-example/pkg/e\" setting \"go-gin-example/pkg/settings\" \"go-gin-example/pkg/util\" \"log\" \"net/http\" \"github.com/astaxie/beego/validation\" \"github.com/gin-gonic/gin\" \"github.com/unknwon/com\" ) // GetArticle 获取单个文章 func GetArticle ( c * gin . Context ) { id := com . StrTo ( c . Param ( \"id\" )). MustInt () valid := validation . Validation {} valid . Min ( id , 1 , \"id\" ). Message ( \"ID必须大于0\" ) code := e . INVALID_PARAMS var data interface {} if ! valid . HasErrors () { if models . ExistArticleByID ( id ) { data = models . GetArticle ( id ) code = e . SUCCESS } else { code = e . ERROR_NOT_EXIST_ARTICLE } } else { for _ , err := range valid . Errors { log . Printf ( \"err.key: %s, err.message: %s\" , err . Key , err . Message ) } } c . JSON ( http . StatusOK , gin . H { \"code\" : code , \"msg\" : e . GetMsg ( code ), \"data\" : data , }) } // GetArticles 获取多个文章 func GetArticles ( c * gin . Context ) { data := make ( map [ string ] interface {}) maps := make ( map [ string ] interface {}) valid := validation . Validation {} var state = - 1 if arg := c . Query ( \"state\" ); arg != \"\" { state = com . StrTo ( arg ). MustInt () maps [ \"state\" ] = state valid . Range ( state , 0 , 1 , \"state\" ). Message ( \"状态只允许0或1\" ) } var tagID = - 1 if arg := c . Query ( \"tag_id\" ); arg != \"\" { tagID = com . StrTo ( arg ). MustInt () maps [ \"tag_id\" ] = tagID valid . Min ( tagID , 1 , \"tag_id\" ). Message ( \"标签ID必须大于0\" ) } code := e . INVALID_PARAMS if ! valid . HasErrors () { data [ \"list\" ] = models . GetArticles ( util . GetPage ( c ), setting . PageSize , maps ) data [ \"total\" ] = models . GetTagTotal ( maps ) code = e . SUCCESS } else { for _ , err := range valid . Errors { log . Printf ( \"err.key:%s, err.message:%s\" , err . Key , err . Message ) } } c . JSON ( http . StatusOK , gin . H { \"code\" : code , \"msg\" : e . GetMsg ( code ), \"data\" : data , }) } // AddArticle 增加文章 func AddArticle ( c * gin . Context ) { tagID := com . StrTo ( c . Query ( \"tag_id\" )). MustInt () title := c . Query ( \"title\" ) desc := c . Query ( \"desc\" ) content := c . Query ( \"content\" ) createdBy := c . Query ( \"created_by\" ) state := com . StrTo ( c . Query ( \"state\" )). MustInt () valid := validation . Validation {} valid . Min ( tagID , 1 , \"tagID\" ). Message ( \"标签ID必须大于0\" ) valid . Required ( title , \"title\" ). Message ( \"题目不能为空\" ) valid . Required ( desc , \"desc\" ). Message ( \"描述不能为空\" ) valid . Required ( content , \"content\" ). Message ( \"内容不能为空\" ) valid . Required ( createdBy , \"created_by\" ). Message ( \"创建人不能为空\" ) valid . Range ( state , 0 , 1 , \"state\" ). Message ( \"状态只能是0或1\" ) code := e . INVALID_PARAMS if ! valid . HasErrors () { if models . ExistTagByID ( tagID ) { data := make ( map [ string ] interface {}) data [ \"tag_id\" ] = tagID data [ \"title\" ] = title data [ \"desc\" ] = desc data [ \"content\" ] = content data [ \"created_by\" ] = createdBy data [ \"state\" ] = state models . AddArticle ( data ) code = e . SUCCESS } else { code = e . ERROR_NOT_EXIST_TAG } } else { for _ , err := range valid . Errors { log . Printf ( \"err.key:%s, err.message%s\" , err . Key , err . Message ) } } c . JSON ( http . StatusOK , gin . H { \"code\" : code , \"msg\" : e . GetMsg ( code ), \"data\" : make ( map [ string ] string ), }) } // EditArticle 修改文章 func EditArticle ( c * gin . Context ) { valid := validation . Validation {} id := com . StrTo ( c . Query ( \"id\" )). MustInt () tagID := com . StrTo ( c . Query ( \"tag_id\" )). MustInt () title := c . Query ( \"title\" ) desc := c . Query ( \"desc\" ) content := c . Query ( \"content\" ) modifiedBy := c . Query ( \"modified_by\" ) var state = - 1 if arg := c . Query ( \"state\" ); arg != \"\" { state = com . StrTo ( arg ). MustInt () valid . Range ( state , 0 , 1 , \"state\" ). Message ( \"状态只能是0或1\" ) } valid . Min ( id , 1 , \"id\" ). Message ( \"ID必须大于0\" ) valid . MaxSize ( title , 100 , \"title\" ). Message ( \"标题最长为100字符\" ) valid . MaxSize ( desc , 255 , \"desc\" ). Message ( \"简述最长为255字符\" ) valid . MaxSize ( content , 65535 , \"content\" ). Message ( \"内容最长为65535字符\" ) valid . Required ( modifiedBy , \"modified_by\" ). Message ( \"修改人不能为空\" ) valid . MaxSize ( modifiedBy , 100 , \"modified_by\" ). Message ( \"修改人最长为100字符\" ) code := e . INVALID_PARAMS if ! valid . HasErrors () { if models . ExistArticleByID ( id ) { if models . ExistTagByID ( tagID ) { data := make ( map [ string ] interface {}) if tagID > 0 { data [ \"tag_id\" ] = tagID } if title != \"\" { data [ \"title\" ] = title } if desc != \"\" { data [ \"desc\" ] = desc } if content != \"\" { data [ \"content\" ] = content } data [ \"modified_by\" ] = modifiedBy models . EditArticle ( id , data ) code = e . SUCCESS } else { code = e . ERROR_NOT_EXIST_TAG } } else { code = e . ERROR_NOT_EXIST_ARTICLE } } else { for _ , err := range valid . Errors { log . Printf ( \"err.key:%s err.Message:%s\" , err . Key , err . Message ) } } c . JSON ( http . StatusOK , gin . H { \"code\" : code , \"msg\" : e . GetMsg ( code ), \"data\" : make ( map [ string ] string ), }) } // DeleteArticle 删除文章 func DeleteArticle ( c * gin . Context ) { id := com . StrTo ( c . Query ( \"id\" )). MustInt () valid := validation . Validation {} valid . Min ( id , 1 , \"id\" ). Message ( \"ID必须大于0\" ) code := e . INVALID_PARAMS if ! valid . HasErrors () { if models . ExistArticleByID ( id ) { models . DeleteArticle ( id ) code = e . SUCCESS } else { code = e . ERROR_NOT_EXIST_ARTICLE } } else { for _ , err := range valid . Errors { log . Printf ( \"err.Key:%s err.Message:%s\" , err . Key , err . Message ) } } c . JSON ( http . StatusOK , gin . H { \"code\" : code , \"msg\" : e . GetMsg ( code ), \"data\" : make ( map [ string ] string ), }) } 定义文章的数据库模型 数据库模型和相关CRUD操作 在 ./models 下新建 article.go 文件 package models import ( \"time\" \"github.com/jinzhu/gorm\" ) // Article 文章结构体 type Article struct { Model // 声明该`TagID`为索引 TagID int `json:\"tag_id\" gorm:\"index\"` Tag Tag `json:tag` Title string `json:\"title\"` Desc string `json:\"desc\"` Content string `json:\"content\"` CreatedBy string `json:\"created_by\"` ModifiedBy string `json:\"modified_by\"` State int `json:state\"` } // BeforeCreate 创建数据前的操作 func ( article * Article ) BeforeCreate ( scope * gorm . Scope ) error { // scope 包含当前执行的所有信息 scope . SetColumn ( \"CreateOn\" , time . Now (). Unix ()) return nil } // BeforeUpdate 更新(编辑)之前添加修改时间 func ( article * Article ) BeforeUpdate ( scope * gorm . Scope ) error { scope . SetColumn ( \"ModifiedOn\" , time . Now (). Unix ()) return nil } // ExistArticleByID 判断是否存在文章 func ExistArticleByID ( id int ) bool { var article Article db . Select ( \"id\" ). Where ( \"id = ?\" , id ). Find ( & article ) if article . ID > 0 { return true } return false } // GetArticleTotal 计算文章数量 func GetArticleTotal ( maps interface {}) ( count int ) { // 在Article数据库中查询所有数据后计数返回给count db . Model ( & Article {}). Where ( maps ). Count ( & count ) return count } // GetArticles 获取所有文章列表 func GetArticles ( pageNum int , pageSize int , maps interface {}) ( articles [] Article ) { // 根据条件预加载 db . Preload ( \"Tag\" ). Where ( maps ). Offset ( pageNum ). Limit ( pageSize ). Find ( & articles ) return articles } // GetArticle 获取单篇文章 func GetArticle ( id int ) ( article Article ) { // 找到该片文章, 返回到article中 db . Where ( \"id = ?\" , id ). First ( & article ) // 获取与该篇文章有关的Tag // 通过.Related关联到嵌套在Article内的Tag结构体 db . Model ( & article ). Related ( & article . Tag ) return article } // EditArticle 编辑文章 func EditArticle ( id int , data interface {}) bool { db . Model ( & Article {}). Where ( \"id = ?\" , id ). Update ( data ) return true } // AddArticle 添加文章 func AddArticle ( data map [ string ] interface {}) bool { db . Create ( & Article { // v.(I)类型断言: 判断接口v的实际类型是否为(I)类型 TagID : data [ \"tag_id\" ].( int ), Title : data [ \"title\" ].( string ), Desc : data [ \"desc\" ].( string ), Content : data [ \"content\" ].( string ), CreatedBy : data [ \"created_by\" ].( string ), State : data [ \"state\" ].( int ), }) return true } // DeleteArticle 删除文章 func DeleteArticle ( id int ) bool { db . Where ( \"id = ?\" , id ). Delete ( Article {}) return true }","text_tokens":["_","where","modified","strto","mustint","offset","=","计数","now","声明","(","空壳","与","import","true","range","id","人","limit","getmsg","getpage","04","required","最长","加载","net","setcolumn","message","jinzhu","博客","com","65535","“","modifiedon","article","code","更新","创建","断言","gonic","param","tag","struct","完成","前","tagid","删除","嵌套","0","context","error","修改","1","简述","put","条件","该","单个","之前","标签","type","和","util","gin","github",".","中","预","message%","arg","到","新建","文章","类","err","model","maxsize","h","existtagbyid","所有","%","-","beego","interface","给","存在","必须","tags","数据库","min","total","文件","validation","255","结构","查询","是","index","api","unknwon","允许",",","或","类型","{","/","不能","created","unix","]","v1","func","maps","desc","添加","gorm","索引","http",";","select","\"","处理","多个","existarticlebyid","分发","执行","state","接口","settings","篇文章","为","content","db","内"," ","操作","}","gettagtotal","first","haserrors","题目","pagesize","当前","getarticletotal","go","通过","编写","related","列表","example","获取","后","下","在","s","int","编辑","invalid","相关","是否","*","editarticle","`","count","createon","请求","修改文章","beforecreate","params","createdby","路由","routers","create","返回","find","not","getarticles","astaxie","query","key","crud","?","v","msg","modifiedby","内容","单篇","errors","关联","信息","pagenum","deletearticle","体","有关","post","package","只能","”","time","根据","创建人","的","实际","模型","else","描述","状态","增加","字符","json","时间","&","update","list","定义","by","[","title","valid","标题","数量","c","据库","articles","exist","scope","nil","数据","models","log","bool","包含","getarticle","该片","string","!","100","接口定义","beforeupdate","map","printf","计算","delete","preload","判断","大于","：","var",")","success","statusok","addarticle","false","make","pkg","i","只",":","为空","setting","if",">","3","e","data","get","return","找到","for"],"title":"go-gin-example 04：API-3","title_tokens":["04","go","example","3","：","-","api","gin"," "]},{"location":"Golang/Project/go-gin-example/04 API-3/#go-gin-example-04api-3","text":"完成博客的文章类接口定义和编写","text_tokens":["接口定义","博客","文章","类","编写","接口","定义","和","的","完成"],"title":"go-gin-example 04：API-3","title_tokens":["04","go","example","3","：","-","api","gin"," "]},{"location":"Golang/Project/go-gin-example/04 API-3/#_1","text":"定义文章的路由分发操作 获取文章列表：GET(“/articles”) 获取单篇文章：GET(“/articles/:id”) 更新文章：PUT(“/articles/:id”) 新建文章：POST(“/articles”) 删除文章：DELETE(“/tags/:id”)","text_tokens":["的","新建","文章","列表","获取","定义"," ","(","articles","tags","路由","id","/","“","delete","更新","：","单篇",")","删除",":","分发","put","post","”","get","操作"],"title":"定义接口","title_tokens":["接口","定义"]},{"location":"Golang/Project/go-gin-example/04 API-3/#_2","text":"文章请求处理API 在 ./routers/api/v1 下新建 article.go 文件 package v1 import ( \"go-gin-example/models\" \"go-gin-example/pkg/e\" setting \"go-gin-example/pkg/settings\" \"go-gin-example/pkg/util\" \"log\" \"net/http\" \"github.com/astaxie/beego/validation\" \"github.com/gin-gonic/gin\" \"github.com/unknwon/com\" ) // GetArticle 获取单个文章 func GetArticle ( c * gin . Context ) { id := com . StrTo ( c . Param ( \"id\" )). MustInt () valid := validation . Validation {} valid . Min ( id , 1 , \"id\" ). Message ( \"ID必须大于0\" ) code := e . INVALID_PARAMS var data interface {} if ! valid . HasErrors () { if models . ExistArticleByID ( id ) { data = models . GetArticle ( id ) code = e . SUCCESS } else { code = e . ERROR_NOT_EXIST_ARTICLE } } else { for _ , err := range valid . Errors { log . Printf ( \"err.key: %s, err.message: %s\" , err . Key , err . Message ) } } c . JSON ( http . StatusOK , gin . H { \"code\" : code , \"msg\" : e . GetMsg ( code ), \"data\" : data , }) } // GetArticles 获取多个文章 func GetArticles ( c * gin . Context ) { data := make ( map [ string ] interface {}) maps := make ( map [ string ] interface {}) valid := validation . Validation {} var state = - 1 if arg := c . Query ( \"state\" ); arg != \"\" { state = com . StrTo ( arg ). MustInt () maps [ \"state\" ] = state valid . Range ( state , 0 , 1 , \"state\" ). Message ( \"状态只允许0或1\" ) } var tagID = - 1 if arg := c . Query ( \"tag_id\" ); arg != \"\" { tagID = com . StrTo ( arg ). MustInt () maps [ \"tag_id\" ] = tagID valid . Min ( tagID , 1 , \"tag_id\" ). Message ( \"标签ID必须大于0\" ) } code := e . INVALID_PARAMS if ! valid . HasErrors () { data [ \"list\" ] = models . GetArticles ( util . GetPage ( c ), setting . PageSize , maps ) data [ \"total\" ] = models . GetTagTotal ( maps ) code = e . SUCCESS } else { for _ , err := range valid . Errors { log . Printf ( \"err.key:%s, err.message:%s\" , err . Key , err . Message ) } } c . JSON ( http . StatusOK , gin . H { \"code\" : code , \"msg\" : e . GetMsg ( code ), \"data\" : data , }) } // AddArticle 增加文章 func AddArticle ( c * gin . Context ) { tagID := com . StrTo ( c . Query ( \"tag_id\" )). MustInt () title := c . Query ( \"title\" ) desc := c . Query ( \"desc\" ) content := c . Query ( \"content\" ) createdBy := c . Query ( \"created_by\" ) state := com . StrTo ( c . Query ( \"state\" )). MustInt () valid := validation . Validation {} valid . Min ( tagID , 1 , \"tagID\" ). Message ( \"标签ID必须大于0\" ) valid . Required ( title , \"title\" ). Message ( \"题目不能为空\" ) valid . Required ( desc , \"desc\" ). Message ( \"描述不能为空\" ) valid . Required ( content , \"content\" ). Message ( \"内容不能为空\" ) valid . Required ( createdBy , \"created_by\" ). Message ( \"创建人不能为空\" ) valid . Range ( state , 0 , 1 , \"state\" ). Message ( \"状态只能是0或1\" ) code := e . INVALID_PARAMS if ! valid . HasErrors () { if models . ExistTagByID ( tagID ) { data := make ( map [ string ] interface {}) data [ \"tag_id\" ] = tagID data [ \"title\" ] = title data [ \"desc\" ] = desc data [ \"content\" ] = content data [ \"created_by\" ] = createdBy data [ \"state\" ] = state models . AddArticle ( data ) code = e . SUCCESS } else { code = e . ERROR_NOT_EXIST_TAG } } else { for _ , err := range valid . Errors { log . Printf ( \"err.key:%s, err.message%s\" , err . Key , err . Message ) } } c . JSON ( http . StatusOK , gin . H { \"code\" : code , \"msg\" : e . GetMsg ( code ), \"data\" : make ( map [ string ] string ), }) } // EditArticle 修改文章 func EditArticle ( c * gin . Context ) { valid := validation . Validation {} id := com . StrTo ( c . Query ( \"id\" )). MustInt () tagID := com . StrTo ( c . Query ( \"tag_id\" )). MustInt () title := c . Query ( \"title\" ) desc := c . Query ( \"desc\" ) content := c . Query ( \"content\" ) modifiedBy := c . Query ( \"modified_by\" ) var state = - 1 if arg := c . Query ( \"state\" ); arg != \"\" { state = com . StrTo ( arg ). MustInt () valid . Range ( state , 0 , 1 , \"state\" ). Message ( \"状态只能是0或1\" ) } valid . Min ( id , 1 , \"id\" ). Message ( \"ID必须大于0\" ) valid . MaxSize ( title , 100 , \"title\" ). Message ( \"标题最长为100字符\" ) valid . MaxSize ( desc , 255 , \"desc\" ). Message ( \"简述最长为255字符\" ) valid . MaxSize ( content , 65535 , \"content\" ). Message ( \"内容最长为65535字符\" ) valid . Required ( modifiedBy , \"modified_by\" ). Message ( \"修改人不能为空\" ) valid . MaxSize ( modifiedBy , 100 , \"modified_by\" ). Message ( \"修改人最长为100字符\" ) code := e . INVALID_PARAMS if ! valid . HasErrors () { if models . ExistArticleByID ( id ) { if models . ExistTagByID ( tagID ) { data := make ( map [ string ] interface {}) if tagID > 0 { data [ \"tag_id\" ] = tagID } if title != \"\" { data [ \"title\" ] = title } if desc != \"\" { data [ \"desc\" ] = desc } if content != \"\" { data [ \"content\" ] = content } data [ \"modified_by\" ] = modifiedBy models . EditArticle ( id , data ) code = e . SUCCESS } else { code = e . ERROR_NOT_EXIST_TAG } } else { code = e . ERROR_NOT_EXIST_ARTICLE } } else { for _ , err := range valid . Errors { log . Printf ( \"err.key:%s err.Message:%s\" , err . Key , err . Message ) } } c . JSON ( http . StatusOK , gin . H { \"code\" : code , \"msg\" : e . GetMsg ( code ), \"data\" : make ( map [ string ] string ), }) } // DeleteArticle 删除文章 func DeleteArticle ( c * gin . Context ) { id := com . StrTo ( c . Query ( \"id\" )). MustInt () valid := validation . Validation {} valid . Min ( id , 1 , \"id\" ). Message ( \"ID必须大于0\" ) code := e . INVALID_PARAMS if ! valid . HasErrors () { if models . ExistArticleByID ( id ) { models . DeleteArticle ( id ) code = e . SUCCESS } else { code = e . ERROR_NOT_EXIST_ARTICLE } } else { for _ , err := range valid . Errors { log . Printf ( \"err.Key:%s err.Message:%s\" , err . Key , err . Message ) } } c . JSON ( http . StatusOK , gin . H { \"code\" : code , \"msg\" : e . GetMsg ( code ), \"data\" : make ( map [ string ] string ), }) }","text_tokens":["_","modified","strto","mustint","=","(","import","range","id","人","getmsg","getpage","required","最长","net","message","com","65535","article","code","创建","gonic","param","tag","tagid","删除","0","context","error","修改","1","简述","单个","标签","util","gin","github",".","message%","arg","新建","文章","err","maxsize","h","existtagbyid","%","-","beego","interface","必须","min","total","文件","validation","255","是","api","unknwon","允许",",","或","{","/","不能","created","]","v1","func","maps","desc","http",";","\"","处理","多个","existarticlebyid","state","settings","为","content","}"," ","gettagtotal","haserrors","题目","pagesize","go","example","获取","下","在","s","invalid","*","editarticle","请求","修改文章","params","createdby","routers","not","getarticles","astaxie","query","key","msg","modifiedby","内容","errors","deletearticle","package","只能","创建人","else","描述","状态","增加","字符","json","list","by","[","title","valid","标题","c","exist","models","log","getarticle","string","!","100","map","printf","大于","addarticle","var",")","success","statusok","make","pkg","只",":","为空","setting","if",">","data","e","for"],"title":"空壳路由","title_tokens":["路由","空壳"]},{"location":"Golang/Project/go-gin-example/04 API-3/#_3","text":"数据库模型和相关CRUD操作 在 ./models 下新建 article.go 文件 package models import ( \"time\" \"github.com/jinzhu/gorm\" ) // Article 文章结构体 type Article struct { Model // 声明该`TagID`为索引 TagID int `json:\"tag_id\" gorm:\"index\"` Tag Tag `json:tag` Title string `json:\"title\"` Desc string `json:\"desc\"` Content string `json:\"content\"` CreatedBy string `json:\"created_by\"` ModifiedBy string `json:\"modified_by\"` State int `json:state\"` } // BeforeCreate 创建数据前的操作 func ( article * Article ) BeforeCreate ( scope * gorm . Scope ) error { // scope 包含当前执行的所有信息 scope . SetColumn ( \"CreateOn\" , time . Now (). Unix ()) return nil } // BeforeUpdate 更新(编辑)之前添加修改时间 func ( article * Article ) BeforeUpdate ( scope * gorm . Scope ) error { scope . SetColumn ( \"ModifiedOn\" , time . Now (). Unix ()) return nil } // ExistArticleByID 判断是否存在文章 func ExistArticleByID ( id int ) bool { var article Article db . Select ( \"id\" ). Where ( \"id = ?\" , id ). Find ( & article ) if article . ID > 0 { return true } return false } // GetArticleTotal 计算文章数量 func GetArticleTotal ( maps interface {}) ( count int ) { // 在Article数据库中查询所有数据后计数返回给count db . Model ( & Article {}). Where ( maps ). Count ( & count ) return count } // GetArticles 获取所有文章列表 func GetArticles ( pageNum int , pageSize int , maps interface {}) ( articles [] Article ) { // 根据条件预加载 db . Preload ( \"Tag\" ). Where ( maps ). Offset ( pageNum ). Limit ( pageSize ). Find ( & articles ) return articles } // GetArticle 获取单篇文章 func GetArticle ( id int ) ( article Article ) { // 找到该片文章, 返回到article中 db . Where ( \"id = ?\" , id ). First ( & article ) // 获取与该篇文章有关的Tag // 通过.Related关联到嵌套在Article内的Tag结构体 db . Model ( & article ). Related ( & article . Tag ) return article } // EditArticle 编辑文章 func EditArticle ( id int , data interface {}) bool { db . Model ( & Article {}). Where ( \"id = ?\" , id ). Update ( data ) return true } // AddArticle 添加文章 func AddArticle ( data map [ string ] interface {}) bool { db . Create ( & Article { // v.(I)类型断言: 判断接口v的实际类型是否为(I)类型 TagID : data [ \"tag_id\" ].( int ), Title : data [ \"title\" ].( string ), Desc : data [ \"desc\" ].( string ), Content : data [ \"content\" ].( string ), CreatedBy : data [ \"created_by\" ].( string ), State : data [ \"state\" ].( int ), }) return true } // DeleteArticle 删除文章 func DeleteArticle ( id int ) bool { db . Where ( \"id = ?\" , id ). Delete ( Article {}) return true }","text_tokens":["_","where","modified","offset","=","计数","now","声明","(","与","import","true","id","limit","加载","setcolumn","jinzhu","com","modifiedon","article","创建","更新","断言","struct","tag","前","tagid","删除","嵌套","修改","error","0","条件","该","之前","type","和","github","中",".","预","到","新建","文章","model","所有","interface","给","存在","数据库","查询","文件","结构","index",",","类型","{","/","created","unix","]","desc","func","maps","添加","gorm","索引","select","\"","existarticlebyid","执行","state","篇文章","接口","为","content","db","内"," ","}","操作","first","当前","getarticletotal","pagesize","go","通过","related","列表","获取","后","下","在","编辑","int","相关","是否","`","*","editarticle","count","createon","beforecreate","create","返回","find","getarticles","?","crud","v","modifiedby","单篇","关联","信息","pagenum","deletearticle","体","有关","time","package","根据","实际","的","模型","json","时间","&","update","by","[","title","数量","据库","scope","articles","nil","数据","models","bool","包含","getarticle","该片","string","beforeupdate","map","计算","delete","preload","判断","addarticle","var",")","false","i",":","if",">","data","return","找到","createdby"],"title":"定义文章的数据库模型","title_tokens":["据库","文章","数据库","数据","定义","的","模型"]},{"location":"Golang/Project/go-gin-example/05 JWT/","text":"go-gin-example 05：JWT 为什么要JWT 当前的API接口虽然编写好了，但是这些API可以被随意调用，这样子是不安全的。因此需要通过 jwt-go 的方式来解决 如何使用JWT 下载依赖包： go get -u github.com/dgrijalva/jwt-go 编写 ./pkg/util 下的新建 jwt.go 文件 其中该工具包主要包含 生成Token 、 解析Token 功能 NewWithClaims 中加密方法有 SigningMethodHS256 ， SigningMethodHS384 、 SigningMethodHS512 三种 cropto.Hash 方案 package util import ( setting \"go-gin-example/pkg/settings\" \"time\" \"github.com/dgrijalva/jwt-go\" ) var jwtSecret = [] byte ( setting . JwtSecret ) // Claims 声明Claims结构体 type Claims struct { Username string `json: \"username\"` Password string `json: \"password\"` jwt . StandardClaims } // GenerateToken 生成密钥 func GenerateToken ( username , password string ) ( string , error ) { nowTime := time . Now () expireTime := nowTime . Add ( 3 * time . Hour ) claims := Claims { username , password , jwt . StandardClaims { ExpiresAt : expireTime . Unix (), Issuer : \"gin-blog\" , }, } // 对claims 进行加密 tokenClaims := jwt . NewWithClaims ( jwt . SigningMethodHS256 , claims ) // 获得加密后的token // 猜测为生成一个加密后的字符串给jwtSecret token , err := tokenClaims . SignedString ( jwtSecret ) return token , err } // ParseToken 解析密钥 func ParseToken ( token string ) ( * Claims , error ) { tokenClaims , err := jwt . ParseWithClaims ( token , & Claims {}, func ( token * jwt . Token ) ( interface {}, error ) { return jwtSecret , nil }) if tokenClaims != nil { if claims , ok := tokenClaims . Claims .( * Claims ); ok && tokenClaims . Valid { return claims , nil } } return nil , err } 编写Gin中间件，在 middleware 下新建 jwt 目录，在其中新建 jwt.go 文件写入 package jwt import ( \"go-gin-example/pkg/e\" \"go-gin-example/pkg/util\" \"net/http\" \"time\" \"github.com/gin-gonic/gin\" ) // JWT json web token func JWT () gin . HandlerFunc { return func ( c * gin . Context ) { var code int var data interface {} code = e . SUCCESS token := c . Query ( \"token\" ) if token == \"\" { code = e . INVALID_PARAMS } else { claims , err := util . ParseToken ( token ) if err != nil { code = e . ERROR_AUTH_CHECK_TOKEN_FAIL } else if time . Now (). Unix () > claims . ExpiresAt { code = e . ERROR_AUTH_CHECK_TOKEN_TIMEOUT } } if code != e . SUCCESS { c . JSON ( http . StatusUnauthorized , gin . H { \"code\" : code , \"msg\" : e . GetMsg ( code ), \"data\" : data , }) // 通过Abort确保当前的handler未被调用, 即当验证不正确的时候丢弃掉该处理 c . Abort () return } c . Next () } } 获得token，在 ./models 下新建 auth.go 文件写入 package models // Auth Token认证 type Auth struct { ID int `gorm:\"primary_key\" json:\"id\"` Username string `json:\"username\"` Password string `json:\"password\"` } // CheckAuth 验证token func CheckAuth ( username , password string ) bool { var auth Auth db . Select ( \"id\" ). Where ( Auth { Username : username , Password : password }). First ( & auth ) if auth . ID > 0 { return true } return false } 在 ./api 下新建 auth.go 文件写入 package api import ( \"go-gin-example/models\" \"go-gin-example/pkg/e\" \"go-gin-example/pkg/util\" \"log\" \"net/http\" \"github.com/astaxie/beego/validation\" \"github.com/gin-gonic/gin\" ) type auth struct { Username string `valid: \"Required; MaxSize(50)\" ` Password string `valid: \"Required; MaxSize(50)\"` } // GetAuth 获取认证 func GetAuth ( c * gin . Context ) { username := c . Query ( \"username\" ) password := c . Query ( \"password\" ) valid := validation . Validation {} a := auth { Username : username , Password : password } ok , _ := valid . Valid ( & a ) data := make ( map [ string ] interface {}) code := e . INVALID_PARAMS if ok { isExist := models . CheckAuth ( username , password ) // 如果存在该账号 if isExist { token , err := util . GenerateToken ( username , password ) if err != nil { code = e . ERROR_AUTH_TOKEN } else { data [ \"token\" ] = token code = e . SUCCESS } } else { // 不存在账号 code = e . ERROR_AUTH } } else { for _ , err := range valid . Errors { log . Println ( err . Key , err . Message ) } } c . JSON ( http . StatusOK , gin . H { \"code\" : code , \"msg\" : e . GetMsg ( code ), \"data\" : data , }) } 修改 router.go 文件 package routers import ( \"go-gin-example/middleware/jwt\" setting \"go-gin-example/pkg/settings\" \"go-gin-example/routers/api\" v1 \"go-gin-example/routers/api/v1\" \"github.com/gin-gonic/gin\" ) // InitRouter 初始化路由 func InitRouter () * gin . Engine { r := gin . New () r . Use ( gin . Logger ()) r . Use ( gin . Recovery ()) gin . SetMode ( setting . RunMode ) // 调用认证接口 r . GET ( \"/auth\" , api . GetAuth ) apiv1 := r . Group ( \"/api/v1\" ) // Group内的所有请求都需要经过JWT apiv1 . Use ( jwt . JWT ()) { apiv1 . GET ( \"/tags\" , v1 . GetTags ) apiv1 . POST ( \"/tags\" , v1 . AddTag ) apiv1 . PUT ( \"/tags/:id\" , v1 . EditTag ) apiv1 . DELETE ( \"/tags/:id\" , v1 . DeleteTag ) apiv1 . GET ( \"/articles\" , v1 . GetArticles ) apiv1 . GET ( \"/articles/:id\" , v1 . GetArticle ) apiv1 . POST ( \"/articles\" , v1 . AddArticle ) apiv1 . PUT ( \"/articles/:id\" , v1 . EditTag ) apiv1 . DELETE ( \"/atricles/:id\" , v1 . DeleteTag ) } return r } 调用 访问 http://127.0.0.1:8000/auth?username=test&password=test123456 获得token 带着token访问api http://127.0.0.1:8000/api/v1/articles?token=eyJhbGci...","text_tokens":["_","包","expiresat","即当","进行","where","05","都","认证","可以","=","group","0.1","丢弃","...","signingmethodhs256","now","声明","(","jwt","依赖","import","true","range","signedstring","id","访问","getmsg","有","router","gettags","需要","dgrijalva","required","工具包","net","use","message","，","check","未","了","com","isexist","code","atricles","username","主要","struct","gonic","验证","nowtime","new","0","error","随意","expiretime","context","修改","初始","put","该","claims","下载","type","经过","password","auth","如何","util","中","gin",".","github","但是","不","token","中间件","确保","新建","err","方法","h","maxsize","方案","所有","-","这","因此","interface","给","next","primary","beego","存在","ok","要","handler","tags","工具","文件","结构","web","validation","logger","addarticle","是","test123456","api","好","时候","getauth","。","着",",","{","/","u","unix","newwithclaims","edittag","样子","被","]","func","timeout","v1","gorm","http","密钥",";","select","\"","方式","处理","addtag","接口","settings","为","db","掉","内"," ","这些","来","}","first","猜测","handlerfunc","当前","加密","目录","50","go","通过","编写","获得","中间","initrouter","runmode","example","什么","后","下","在","获取","账号","int","初始化","invalid","recovery","`","*","、","对","r","请求","println","params","eyjhbgci","路由","其中","routers","parsetoken","安全","如果","deletetag","a","hour","getarticles","astaxie","statusunauthorized","query","key","?","msg","字符串","byte","功能","apiv1","使用","add","engine","errors","正确","体","time","为什么","package","post","8000","的","&&","三种","checkauth","test","else","signingmethodhs384","调用","blog","字符","解决","json","&","虽然","写入","带","[","parsewithclaims","valid","c","articles","cropto","nil","setmode","models","log","bool","issuer","包含","getarticle","abort","string","!","127.0","standardclaims","解析","map","jwtsecret","delete","hash","生成","：","var",")","一个","success","false","statusok","middleware","pkg","make","signingmethodhs512","tokenclaims",":","setting","fail","if","generatetoken",">","3","e","data","get","return","for"],"title":"go-gin-example 05：JWT","title_tokens":["jwt","05","go","example","：","-","gin"," "]},{"location":"Golang/Project/go-gin-example/05 JWT/#go-gin-example-05jwt","text":"","text_tokens":[],"title":"go-gin-example 05：JWT","title_tokens":["jwt","05","go","example","：","-","gin"," "]},{"location":"Golang/Project/go-gin-example/05 JWT/#jwt","text":"当前的API接口虽然编写好了，但是这些API可以被随意调用，这样子是不安全的。因此需要通过 jwt-go 的方式来解决","text_tokens":["当前","但是","调用","不","go","通过","编写","虽然","可以","解决","-","这","因此"," ","jwt","安全","需要","是","api","好","。","，","了","样子","被","这些","方式","随意","接口","的","来"],"title":"为什么要JWT","title_tokens":["要","什么","jwt","为什么"]},{"location":"Golang/Project/go-gin-example/05 JWT/#jwt_1","text":"下载依赖包： go get -u github.com/dgrijalva/jwt-go 编写 ./pkg/util 下的新建 jwt.go 文件 其中该工具包主要包含 生成Token 、 解析Token 功能 NewWithClaims 中加密方法有 SigningMethodHS256 ， SigningMethodHS384 、 SigningMethodHS512 三种 cropto.Hash 方案 package util import ( setting \"go-gin-example/pkg/settings\" \"time\" \"github.com/dgrijalva/jwt-go\" ) var jwtSecret = [] byte ( setting . JwtSecret ) // Claims 声明Claims结构体 type Claims struct { Username string `json: \"username\"` Password string `json: \"password\"` jwt . StandardClaims } // GenerateToken 生成密钥 func GenerateToken ( username , password string ) ( string , error ) { nowTime := time . Now () expireTime := nowTime . Add ( 3 * time . Hour ) claims := Claims { username , password , jwt . StandardClaims { ExpiresAt : expireTime . Unix (), Issuer : \"gin-blog\" , }, } // 对claims 进行加密 tokenClaims := jwt . NewWithClaims ( jwt . SigningMethodHS256 , claims ) // 获得加密后的token // 猜测为生成一个加密后的字符串给jwtSecret token , err := tokenClaims . SignedString ( jwtSecret ) return token , err } // ParseToken 解析密钥 func ParseToken ( token string ) ( * Claims , error ) { tokenClaims , err := jwt . ParseWithClaims ( token , & Claims {}, func ( token * jwt . Token ) ( interface {}, error ) { return jwtSecret , nil }) if tokenClaims != nil { if claims , ok := tokenClaims . Claims .( * Claims ); ok && tokenClaims . Valid { return claims , nil } } return nil , err } 编写Gin中间件，在 middleware 下新建 jwt 目录，在其中新建 jwt.go 文件写入 package jwt import ( \"go-gin-example/pkg/e\" \"go-gin-example/pkg/util\" \"net/http\" \"time\" \"github.com/gin-gonic/gin\" ) // JWT json web token func JWT () gin . HandlerFunc { return func ( c * gin . Context ) { var code int var data interface {} code = e . SUCCESS token := c . Query ( \"token\" ) if token == \"\" { code = e . INVALID_PARAMS } else { claims , err := util . ParseToken ( token ) if err != nil { code = e . ERROR_AUTH_CHECK_TOKEN_FAIL } else if time . Now (). Unix () > claims . ExpiresAt { code = e . ERROR_AUTH_CHECK_TOKEN_TIMEOUT } } if code != e . SUCCESS { c . JSON ( http . StatusUnauthorized , gin . H { \"code\" : code , \"msg\" : e . GetMsg ( code ), \"data\" : data , }) // 通过Abort确保当前的handler未被调用, 即当验证不正确的时候丢弃掉该处理 c . Abort () return } c . Next () } } 获得token，在 ./models 下新建 auth.go 文件写入 package models // Auth Token认证 type Auth struct { ID int `gorm:\"primary_key\" json:\"id\"` Username string `json:\"username\"` Password string `json:\"password\"` } // CheckAuth 验证token func CheckAuth ( username , password string ) bool { var auth Auth db . Select ( \"id\" ). Where ( Auth { Username : username , Password : password }). First ( & auth ) if auth . ID > 0 { return true } return false } 在 ./api 下新建 auth.go 文件写入 package api import ( \"go-gin-example/models\" \"go-gin-example/pkg/e\" \"go-gin-example/pkg/util\" \"log\" \"net/http\" \"github.com/astaxie/beego/validation\" \"github.com/gin-gonic/gin\" ) type auth struct { Username string `valid: \"Required; MaxSize(50)\" ` Password string `valid: \"Required; MaxSize(50)\"` } // GetAuth 获取认证 func GetAuth ( c * gin . Context ) { username := c . Query ( \"username\" ) password := c . Query ( \"password\" ) valid := validation . Validation {} a := auth { Username : username , Password : password } ok , _ := valid . Valid ( & a ) data := make ( map [ string ] interface {}) code := e . INVALID_PARAMS if ok { isExist := models . CheckAuth ( username , password ) // 如果存在该账号 if isExist { token , err := util . GenerateToken ( username , password ) if err != nil { code = e . ERROR_AUTH_TOKEN } else { data [ \"token\" ] = token code = e . SUCCESS } } else { // 不存在账号 code = e . ERROR_AUTH } } else { for _ , err := range valid . Errors { log . Println ( err . Key , err . Message ) } } c . JSON ( http . StatusOK , gin . H { \"code\" : code , \"msg\" : e . GetMsg ( code ), \"data\" : data , }) } 修改 router.go 文件 package routers import ( \"go-gin-example/middleware/jwt\" setting \"go-gin-example/pkg/settings\" \"go-gin-example/routers/api\" v1 \"go-gin-example/routers/api/v1\" \"github.com/gin-gonic/gin\" ) // InitRouter 初始化路由 func InitRouter () * gin . Engine { r := gin . New () r . Use ( gin . Logger ()) r . Use ( gin . Recovery ()) gin . SetMode ( setting . RunMode ) // 调用认证接口 r . GET ( \"/auth\" , api . GetAuth ) apiv1 := r . Group ( \"/api/v1\" ) // Group内的所有请求都需要经过JWT apiv1 . Use ( jwt . JWT ()) { apiv1 . GET ( \"/tags\" , v1 . GetTags ) apiv1 . POST ( \"/tags\" , v1 . AddTag ) apiv1 . PUT ( \"/tags/:id\" , v1 . EditTag ) apiv1 . DELETE ( \"/tags/:id\" , v1 . DeleteTag ) apiv1 . GET ( \"/articles\" , v1 . GetArticles ) apiv1 . GET ( \"/articles/:id\" , v1 . GetArticle ) apiv1 . POST ( \"/articles\" , v1 . AddArticle ) apiv1 . PUT ( \"/articles/:id\" , v1 . EditTag ) apiv1 . DELETE ( \"/atricles/:id\" , v1 . DeleteTag ) } return r } 调用 访问 http://127.0.0.1:8000/auth?username=test&password=test123456 获得token 带着token访问api http://127.0.0.1:8000/api/v1/articles?token=eyJhbGci...","text_tokens":["_","包","expiresat","即当","进行","where","都","认证","=","group","0.1","丢弃","...","signingmethodhs256","now","声明","(","依赖","jwt","import","true","range","signedstring","id","访问","getmsg","有","router","gettags","需要","dgrijalva","required","工具包","net","use","message","，","check","未","com","isexist","code","atricles","username","主要","struct","gonic","验证","nowtime","new","0","error","context","expiretime","修改","初始","put","该","claims","下载","type","经过","password","auth","gin","中","util",".","github","token","确保","不","中间件","新建","err","方法","h","maxsize","方案","所有","-","next","interface","beego","给","primary","存在","ok","handler","tags","工具","文件","结构","web","validation","logger","addarticle","test123456","api","时候","getauth","着",",","{","/","u","unix","newwithclaims","edittag","]","被","func","timeout","v1","gorm","http","密钥",";","select","\"","处理","addtag","接口","settings","为","db","掉","内","}"," ","first","猜测","handlerfunc","当前","加密","目录","50","go","获得","编写","中间","通过","initrouter","runmode","example","后","获取","下","在","账号","初始化","int","recovery","invalid","`","*","、","对","r","请求","println","params","eyjhbgci","路由","其中","routers","parsetoken","如果","deletetag","a","hour","getarticles","astaxie","statusunauthorized","query","key","?","msg","字符串","byte","功能","apiv1","add","engine","errors","正确","体","time","package","post","8000","的","&&","三种","checkauth","test","else","signingmethodhs384","调用","blog","字符","json","&","写入","带","[","parsewithclaims","valid","c","articles","cropto","nil","setmode","models","log","bool","issuer","包含","getarticle","abort","string","!","127.0","standardclaims","解析","map","jwtsecret","delete","hash","生成","：","var",")","一个","success","false","statusok","middleware","pkg","make","signingmethodhs512","tokenclaims",":","setting","fail","if","generatetoken",">","3","e","data","get","return","for"],"title":"如何使用JWT","title_tokens":["如何","使用","jwt"]},{"location":"Golang/Project/go-gin-example/08 Swagger/","text":"go-gin-example 08： Swagger Swagger是什么? 接口生成器：自动生成接口文档 如何在golang中使用Swagger 安装 安装swag go get -u github.com/swaggo/swag/cmd/swag ，如果没有将 $GOROOT/bin 添加到 $PATH 中，则需要将swag的可执行文件移到 $GOBIN 中 验证是否安装成功 $ swag -v swag version v1.6.3 安装gin-swagger go get -u github.com/swaggo/gin-swagger go get -u github.com/swaggo/gin-swagger/swaggerFiles 编写swag // Response 定义 swag 文档返回的结构体 type Response struct { Code int ` json : \" code \" ` Msg string ` json : \" msg \" ` Data interface {} ` json : \" data \" ` } // GetArticles 获取多个文章 // @ Summary 获取多个文章 // @ Produce json // @ Param tag_id body int false \" TagID \" // @ Param state body int false \" State \" // @ Param created_by body int false \" CreatedBy \" // @ Success 200 { object } Response // @ Failure 500 { object } Response // @ Router / api / v1 / articles [ get ] func GetArticles ( c * gin . Context ) { data : = make ( map [ string ] interface {} ) maps : = make ( map [ string ] interface {} ) valid : = validation . Validation {} var state = - 1 if arg : = c . Query ( \" state \" ) ; arg != \"\" { state = com . StrTo ( arg ) . MustInt () maps [ \" state \" ] = state valid . Range ( state , 0 , 1 , \" state \" ) . Message ( \" 状态只允许0或1 \" ) } var tagID = - 1 if arg : = c . Query ( \" tag_id \" ) ; arg != \"\" { tagID = com . StrTo ( arg ) . MustInt () maps [ \" tag_id \" ] = tagID valid . Min ( tagID , 1 , \" tag_id \" ) . Message ( \" 标签ID必须大于0 \" ) } code : = e . INVALID_PARAMS if ! valid . HasErrors () { data [ \" list \" ] = models . GetArticles ( util . GetPage ( c ) , setting . PageSize , maps ) data [ \" total \" ] = models . GetTagTotal ( maps ) code = e . SUCCESS } else { for _ , err : = range valid . Errors { log . Printf ( \" err.key:%s, err.message:%s \" , err . Key , err . Message ) } } c . JSON ( http . StatusOK , gin . H { \" code \" : code , \" msg \" : e . GetMsg ( code ) , \" data \" : data , } ) } 格式 // @Summary API描述 // @Produce json[生成..内容] // @Param id path/body/query int[type] false/true \"ID\"[程序中对应变量名字] // @Success 200 string \"ok\" --成功返回信息 // @Failure 500 string \"bad\" --失败返回信息 // @Routers api/v1/article/{id} [GET] 请求id, 请求方法 效果 访问 http://127.0.0.1:8000/swagger/index.html","text_tokens":["_","strto","mustint","成器","=","0.1","行文","bad","html","(","生成器","true","range","id","没有","produce","访问","getmsg","summary","getpage","router","需要","message","，","com","article","code","@","安装","$","struct","param","tag","tagid","object","0","context","1","标签","type","变量","程序","如何","gin","github","中",".","util","到","arg","文章","err","方法","h","v1.6","%","-","interface","必须","ok","path","min","total","文件","结构","validation","是","golang","api","index","允许",",","或","{","/","u","可执行文件","created","]","v1","func","body","maps","添加","..","http",";","\"","多个","执行","state","接口","将"," ","}","gettagtotal","haserrors","pagesize","go","编写","example","什么","获取","在","s","int","for","invalid","是否","cmd","格式","`","*","对应","请求","params","routers","如果","返回","getarticles","失败","?","swag","query","v","key","msg","自动","内容","则","使用","swagger","效果","08","500","errors","信息","failure","swaggo","体","8000","的","文档","else","描述","状态","json","list","定义","by","[","version","bin","valid","c","articles","gobin","移","response","models","log","string","!","名字","127.0","map","printf","200","swaggerfiles","生成","大于","：","var","false","success",")","statusok","make","只",":","setting","goroot","if","成功","3","data","e","get","验证","createdby"],"title":"go-gin-example 08： Swagger","title_tokens":["swagger","08","go","example","：","-","gin"," "]},{"location":"Golang/Project/go-gin-example/08 Swagger/#go-gin-example-08-swagger","text":"","text_tokens":[],"title":"go-gin-example 08： Swagger","title_tokens":["swagger","08","go","example","：","-","gin"," "]},{"location":"Golang/Project/go-gin-example/08 Swagger/#swagger","text":"接口生成器：自动生成接口文档","text_tokens":["生成器","接口","成器","生成","自动","：","文档"],"title":"Swagger是什么?","title_tokens":["什么","swagger","是","?"]},{"location":"Golang/Project/go-gin-example/08 Swagger/#golangswagger","text":"","text_tokens":[],"title":"如何在golang中使用Swagger","title_tokens":["swagger","golang","在","如何","使用","中"]},{"location":"Golang/Project/go-gin-example/08 Swagger/#_1","text":"安装swag go get -u github.com/swaggo/swag/cmd/swag ，如果没有将 $GOROOT/bin 添加到 $PATH 中，则需要将swag的可执行文件移到 $GOBIN 中 验证是否安装成功 $ swag -v swag version v1.6.3 安装gin-swagger go get -u github.com/swaggo/gin-swagger go get -u github.com/swaggo/gin-swagger/swaggerFiles","text_tokens":[".","的","到","go","行文","v1.6","-","version","是否","cmd","bin","path","没有","移","如果","文件","gobin","需要","，","swag","com","/","u","v","swaggerfiles","可执行文件","安装","$","中","验证","则","添加","swagger","goroot","执行","成功","swaggo","3","get","将"," ","gin","github"],"title":"安装","title_tokens":["安装"]},{"location":"Golang/Project/go-gin-example/08 Swagger/#swag","text":"// Response 定义 swag 文档返回的结构体 type Response struct { Code int ` json : \" code \" ` Msg string ` json : \" msg \" ` Data interface {} ` json : \" data \" ` } // GetArticles 获取多个文章 // @ Summary 获取多个文章 // @ Produce json // @ Param tag_id body int false \" TagID \" // @ Param state body int false \" State \" // @ Param created_by body int false \" CreatedBy \" // @ Success 200 { object } Response // @ Failure 500 { object } Response // @ Router / api / v1 / articles [ get ] func GetArticles ( c * gin . Context ) { data : = make ( map [ string ] interface {} ) maps : = make ( map [ string ] interface {} ) valid : = validation . Validation {} var state = - 1 if arg : = c . Query ( \" state \" ) ; arg != \"\" { state = com . StrTo ( arg ) . MustInt () maps [ \" state \" ] = state valid . Range ( state , 0 , 1 , \" state \" ) . Message ( \" 状态只允许0或1 \" ) } var tagID = - 1 if arg : = c . Query ( \" tag_id \" ) ; arg != \"\" { tagID = com . StrTo ( arg ) . MustInt () maps [ \" tag_id \" ] = tagID valid . Min ( tagID , 1 , \" tag_id \" ) . Message ( \" 标签ID必须大于0 \" ) } code : = e . INVALID_PARAMS if ! valid . HasErrors () { data [ \" list \" ] = models . GetArticles ( util . GetPage ( c ) , setting . PageSize , maps ) data [ \" total \" ] = models . GetTagTotal ( maps ) code = e . SUCCESS } else { for _ , err : = range valid . Errors { log . Printf ( \" err.key:%s, err.message:%s \" , err . Key , err . Message ) } } c . JSON ( http . StatusOK , gin . H { \" code \" : code , \" msg \" : e . GetMsg ( code ) , \" data \" : data , } ) } 格式 // @Summary API描述 // @Produce json[生成..内容] // @Param id path/body/query int[type] false/true \"ID\"[程序中对应变量名字] // @Success 200 string \"ok\" --成功返回信息 // @Failure 500 string \"bad\" --失败返回信息 // @Routers api/v1/article/{id} [GET] 请求id, 请求方法","text_tokens":["_","strto","mustint","=","bad","(","true","range","id","produce","getmsg","summary","getpage","router","message","com","article","code","@","struct","param","tag","tagid","object","0","context","1","标签","type","变量","gin","util","中",".","arg","文章","err","方法","h","%","-","interface","必须","ok","path","min","total","结构","validation","api","允许",",","或","{","/","created","]","v1","maps","body","func","..","http",";","\"","多个","state"," ","}","gettagtotal","haserrors","pagesize","获取","s","int","for","invalid","对应","格式","`","*","请求","params","routers","返回","getarticles","失败","query","swag","key","msg","内容","500","errors","信息","failure","体","的","文档","else","描述","状态","json","list","定义","by","[","valid","c","articles","response","models","log","string","!","名字","map","printf","200","生成","大于","var","false","success",")","statusok","make","只",":","setting","if","成功","data","e","get","程序","createdby"],"title":"编写swag","title_tokens":["swag","编写"]},{"location":"Golang/Project/go-gin-example/08 Swagger/#_2","text":"访问 http://127.0.0.1:8000/swagger/index.html","text_tokens":["html",".","swagger",":","/","访问","0.1","8000"," ","index","127.0","http"],"title":"效果","title_tokens":["效果"]},{"location":"Golang/Project/go-gin-example/09 Docker/","text":"go-gin-example 09：Docker Docker是什么 Docker is a set of platform as a service (PaaS) products that use OS-level virtualization to deliver software in packages called containers.[6] Containers are isolated from one another and bundle their own software, libraries and configuration files; they can communicate with each other through well-defined channels.[7] All containers are run by a single operating-system kernel and are thus more lightweight than virtual machines.[8] Docker是Paas的产品, 通过被成为 容器 的 系统级别 的虚拟化交付软件. 如何使用Docker 安装Docker(WIN10 PRO) 右键WINDOWS - 应用和功能 - 程序和功能 - 启用或关闭WINDOS功能 - 开启Hyper-V 开启 Hyper-V 可能导致 ShadowSocksR 端口被占用 官网 Docker基本指令 编写Dockerfile FROM golang:latest ENV GOPROXY https://goproxy.cn,direct WORKDIR $GOPATH /src/go-gin-example COPY . $GOPATH /src/go-gin-example RUN go build . EXPOSE 8000 ENTRYPOINT [ \"./go-gin-example\" ] 1. FROM : 指定基础镜像, 该指令必须要有,且得为第一条 2. WORKDIR : 指定工作目录路径, 若目录不存在, 则会创建改目录 3. COPY : 源路径 ... 目标路径, COPY 指令将 Dockerfile 文件所存在的上下文目录 复制 到目标路径位置 4. RUN : 执行命令 5. EXPOSE : 声明 运行时容器 提供服务端口, 仅仅是一个 声明 , 不会因为这个声明而开启这个端口 6. ENTRYPOINT : 指定 容器 启动程序的及参数(执行 ./go-gin-example) 运行 docker build - t gin - blog - docker . docker images docker run - p 8000 : 8000 gin - blog - docker 1. 在 . 当前环境运行 docker build 创建/构建镜像, -t 指定名称 2. docker images 查看镜像是否创建成功 3. 在本地8000端口运行容器 4. 发现 dial tcp 127.0.0.1:3306: connect: connection refused 错误 配置Mysql Docker docker pull mysql docker run --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root -d mysql 1. 拉取mysql镜像 2. 配置mysql端口 修改配置文件 conf.ini [database] TYPE = mysql USER = root PASSWORD = rootroot HOST = mysql:3306 NAME = blog TABLE_PREFIX = blog_ 关联Golang容器和Mysql容器 docker run --link mysql:mysql -p 8000:8000 gin-blog-docker 效果","text_tokens":["4","_","复制","pro","docker","开启","占用","table","路径","=","0.1","...","上下文","镜像","声明","pull","执行命令","(","their","own","启用","copy","rootroot","系统","第一条","可能","set","shadowsocksr","有","called","所","to","than","关闭","defined","配置","use","且","virtual","软件","service","database","8","创建","安装","$","第一","as","products","virtualization","files","windos","that","参数","容器","in","因为","名称","修改","os","1","构建","该","而","启动","tcp","type","虚拟","和","运行","如何","password","gin","is","本地",".","不","到","user","run","hyper","上下","build","dockerfile","-","存在","with","必须","kernel","要","operating","d","目标","文件","env","prefix","是","golang","仅仅","system","another",",","each","官网","或","/","lightweight","提供","]","被","cn",";","communicate","machines","direct","\"","one","conf","windows","are","执行","拉取","为","将","查看"," ","不会","software","命令","基本","host","当前","through","目录","libraries","can","go","通过","指令","编写","时","images","example","什么","bundle","在","platform","containers","configuration","得","2","是否","源","若","mysql","一条","改","connection","https","packages","a","应用","产品","服务","v","workdir","3306","win10","错误","other","功能","all","则","导致","使用","工作","of","entrypoint","t","p","refused","效果","关联","端口","环境","7","8000","的","及","gopath","09","6","指定","blog","single","发现","这个","by","[","they","虚拟化","交付","位置","more","paas","channels","from","基础","级别","link","下文","5","connect","root","ini","dial","thus","src","127.0","level","expose","well","成为","deliver","isolated","：","and",")","一个","配置文件",":","成功","latest","会","3","e","右键","goproxy","程序","name"],"title":"go-gin-example 09：Docker","title_tokens":["09","docker","go","example","：","-","gin"," "]},{"location":"Golang/Project/go-gin-example/09 Docker/#go-gin-example-09docker","text":"","text_tokens":[],"title":"go-gin-example 09：Docker","title_tokens":["09","docker","go","example","：","-","gin"," "]},{"location":"Golang/Project/go-gin-example/09 Docker/#docker","text":"Docker is a set of platform as a service (PaaS) products that use OS-level virtualization to deliver software in packages called containers.[6] Containers are isolated from one another and bundle their own software, libraries and configuration files; they can communicate with each other through well-defined channels.[7] All containers are run by a single operating-system kernel and are thus more lightweight than virtual machines.[8] Docker是Paas的产品, 通过被成为 容器 的 系统级别 的虚拟化交付软件.","text_tokens":["docker","(","their","own","系统","set","called","to","than","defined","use","virtual","软件","service","8","virtualization","as","products","files","that","容器","in","os","虚拟","is",".","run","-","with","kernel","operating","是","system","another",",","each","lightweight","]","被",";","communicate","machines","one","are"," ","software","through","libraries","can","通过","bundle","platform","containers","configuration","packages","a","产品","other","all","of","7","的","6","single","by","[","they","虚拟化","交付","more","paas","channels","from","级别","thus","level","well","成为","deliver","isolated","and",")"],"title":"Docker是什么","title_tokens":["是","docker","什么"]},{"location":"Golang/Project/go-gin-example/09 Docker/#docker_1","text":"","text_tokens":[],"title":"如何使用Docker","title_tokens":["docker","如何","使用"]},{"location":"Golang/Project/go-gin-example/09 Docker/#dockerwin10-pro","text":"右键WINDOWS - 应用和功能 - 程序和功能 - 启用或关闭WINDOS功能 - 开启Hyper-V 开启 Hyper-V 可能导致 ShadowSocksR 端口被占用 官网","text_tokens":["开启","占用","hyper","-"," ","启用","可能","shadowsocksr","应用","关闭","官网","或","v","功能","windos","被","导致","windows","端口","右键","和","程序"],"title":"安装Docker(WIN10 PRO)","title_tokens":["(","pro","docker","win10","安装",")"," "]},{"location":"Golang/Project/go-gin-example/09 Docker/#docker_2","text":"","text_tokens":[],"title":"Docker基本指令","title_tokens":["docker","指令","基本"]},{"location":"Golang/Project/go-gin-example/09 Docker/#dockerfile","text":"FROM golang:latest ENV GOPROXY https://goproxy.cn,direct WORKDIR $GOPATH /src/go-gin-example COPY . $GOPATH /src/go-gin-example RUN go build . EXPOSE 8000 ENTRYPOINT [ \"./go-gin-example\" ] 1. FROM : 指定基础镜像, 该指令必须要有,且得为第一条 2. WORKDIR : 指定工作目录路径, 若目录不存在, 则会创建改目录 3. COPY : 源路径 ... 目标路径, COPY 指令将 Dockerfile 文件所存在的上下文目录 复制 到目标路径位置 4. RUN : 执行命令 5. EXPOSE : 声明 运行时容器 提供服务端口, 仅仅是一个 声明 , 不会因为这个声明而开启这个端口 6. ENTRYPOINT : 指定 容器 启动程序的及参数(执行 ./go-gin-example)","text_tokens":["4","复制","开启","路径","...","上下文","镜像","声明","执行命令","(","copy","第一条","有","所","且","创建","$","第一","参数","容器","因为","1","该","而","启动","运行","gin",".","不","到","run","上下","build","dockerfile","-","存在","必须","要","目标","文件","env","是","golang","仅仅",",","/","提供","]","cn","direct","\"","执行","为","将"," ","不会","命令","目录","go","指令","时","example","得","2","源","若","一条","改","https","服务","workdir","则","工作","entrypoint","端口","8000","的","及","gopath","6","指定","这个","[","位置","基础","from","下文","5","src","expose","一个",")",":","latest","会","3","goproxy","程序"],"title":"编写Dockerfile","title_tokens":["dockerfile","编写"]},{"location":"Golang/Project/go-gin-example/09 Docker/#_1","text":"docker build - t gin - blog - docker . docker images docker run - p 8000 : 8000 gin - blog - docker 1. 在 . 当前环境运行 docker build 创建/构建镜像, -t 指定名称 2. docker images 查看镜像是否创建成功 3. 在本地8000端口运行容器 4. 发现 dial tcp 127.0.0.1:3306: connect: connection refused 错误","text_tokens":[".","4","当前","指定","blog","docker","run","查看","发现","images","build","0.1","在","2","-","镜像","是否","connection","connect","dial","127.0",",","/","3306","创建","错误","容器","t","名称","p","refused",":","1","构建","成功","环境","端口","tcp","3","8000","运行"," ","gin","本地"],"title":"运行","title_tokens":["运行"]},{"location":"Golang/Project/go-gin-example/09 Docker/#mysql-docker","text":"docker pull mysql docker run --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root -d mysql 1. 拉取mysql镜像 2. 配置mysql端口","text_tokens":[".","_","docker","run","=","2","-","镜像","pull","mysql","d","root","配置","3306","p",":","1","端口","拉取","e","password"," ","name"],"title":"配置Mysql Docker","title_tokens":["docker"," ","mysql","配置"]},{"location":"Golang/Project/go-gin-example/09 Docker/#confini","text":"[database] TYPE = mysql USER = root PASSWORD = rootroot HOST = mysql:3306 NAME = blog TABLE_PREFIX = blog_","text_tokens":["_","blog","user","table","=","[","rootroot","mysql","prefix","root","database","3306","]",":","type","password"," ","host","name"],"title":"修改配置文件conf.ini","title_tokens":[".","配置文件","修改","conf","文件","ini","配置"]},{"location":"Golang/Project/go-gin-example/09 Docker/#golangmysql","text":"docker run --link mysql:mysql -p 8000:8000 gin-blog-docker","text_tokens":["mysql","p",":","blog","docker","run","-","link","8000"," ","gin"],"title":"关联Golang容器和Mysql容器","title_tokens":["mysql","关联","和","golang","容器"]},{"location":"Golang/Project/go-gin-example/09 Docker/#_2","text":"","text_tokens":[],"title":"效果","title_tokens":["效果"]},{"location":"Golang/Project/go-gin-example/10 GORM-Callback/","text":"go-gin-example 10： GORM-Callback 定制GORM Callbacks GORM Callback 是什么 You could define callback methods to pointer of model struct, it will be called when creating, updating, querying, deleting, if any callback returns an error, gorm will stop future operations and rollback all changes. 可以给模型结构体指针定义回调函数, 它将会在被创建/更新/查询/删除的时候调用, 如果回调返回了错误, gorm会停止未来行为操作并且回退所有改变. 之前程序未实现 Callback 方法, 需要为所有文件单独写一次 BeforeCreate 、 BeforeUpdate 方法 使用 gorm支持的callback方法 创建：BeforeSave、BeforeCreate、AfterCreate、AfterSave 更新：BeforeSave、BeforeUpdate、AfterUpdate、AfterSave 删除：BeforeDelete、AfterDelete 查询：AfterFind 定义callback 在 model.go 文件中定义 // updateTimeStampForCreateCallback will set `CreatedOn`, `ModifiedOn` when creating func updateTimeStampForCreateCallback ( scope * gorm . Scope ) { if ! scope . HasError () { nowTime := time . Now (). Unix () if createTimeField , ok := scope . FieldByName ( \"CreatedOn\" ); ok { if createTimeField . IsBlank { createTimeField . Set ( nowTime ) } } if modifyTimeField , ok := scope . FieldByName ( \"ModifiedOn\" ); ok { if modifyTimeField . IsBlank { modifyTimeField . Set ( nowTime ) } } } } // updateTimeStampForUpdateCallback will set `ModifyTime` when updating func updateTimeStampForUpdateCallback ( scope * gorm . Scope ) { if _ , ok := scope . Get ( \"gorm:update_column\" ); ! ok { scope . SetColumn ( \"ModifiedOn\" , time . Now (). Unix ()) } } 通过 scope.FieldByName(name) 判断是否存在相关字段, 该方法通过 scope.Fields() 获取所有字段 通过 .IsBlank 判断值是否为空 通过 .Set(interface{}) 设置相关值 通过 scope.Get() 获取参数的参数值, 案例中回去查找 gorm:update_column 这个字段的属性 通过 scope.SetColumn(Field, value) 设定字段的值 调用callback 在 model.go 的 ini 函数中注册callback db . Callback (). Create (). Replace ( \"gorm:update_time_stamp\" , updateTimeStampForCreateCallback ) db . Callback (). Update (). Replace ( \"gorm:update_time_stamp\" , updateTimeStampForUpdateCallback ) 效果 当程序写了 Callback 方法的时候, 当GORM执行到相关的操作会自动触发相应的 Callback 方法 拓展 软删除, 添加删除时间, 为 model.go 的 Model 结构体添加 DeletedOn 字段 type Model struct { ID int `gorm:\"primary_key\" json:\"id\"` CreatedOn int `json:\"created_on\"` ModifiedOn int `json:\"modified_on\"` DeletedOn int `json:\"deleted_on\"` } func deleteCallback ( scope * gorm . Scope ) { if ! scope . HasError () { var extraOption string if str , ok := scope . Get ( \"gorm:delete_option\" ); ok { extraOption = fmt . Sprint ( str ) } deletedOnField , hasDeletedOnField := scope . FieldByName ( \"DeletedOn\" ) if ! scope . Search . Unscoped && hasDeletedOnField { scope . Raw ( fmt . Sprintf ( \"UPDATE %v SET %v=%v%v%v\" , scope . QuotedTableName (), scope . Quote ( deletedOnField . DBName ), scope . AddToVars ( time . Now (). Unix ()), addExtraSpaceIfExist ( scope . CombinedConditionSql ()), addExtraSpaceIfExist ( extraOption ), )). Exec () } else { scope . Raw ( fmt . Sprintf ( \"DELETE FROM %v%v%v\" , scope . QuotedTableName (), addExtraSpaceIfExist ( scope . CombinedConditionSql ()), addExtraSpaceIfExist ( extraOption ), )). Exec () } } } func addExtraSpaceIfExist ( str string ) string { if str != \"\" { return \" \" + str } return \"\" } 在 model.go 的 ini函数 中添加 db.Callback().Delete().Replace(\"gorm:delete\", deleteCallback) 1. scope.QuotedTableName() 返回引用的表名 2. scope.Raw() 构建原生sql 3. fmt.Sprintf() 格式化并且返回格式化后的字符串数据 4. scope.AddToVars(value) 为字段添加参数 5. scope.Quote() 转义 6. scope 当你在数据库中文完成任何操作, scope包含了当前操作信息 // Scope contain current operation's information when you perform any operation on the database type Scope struct { Search * search Value interface {} SQL string SQLVars [] interface {} db * DB instanceID string primaryKeyField * Field skipLeft bool fields * [] * Field selectAttrs * [] string } REF: official: callback in gorm","text_tokens":["4","_","future","查找","s","modified","quote","可以","stamp","deleted","=","原生","now","回去","(","column","addtovars","并且","id","未来","stop","set","called","函数","to","需要","setcolumn","未","sql","will","了","modifiedon","database","it","创建","更新","aftercreate","querying","raw","addextraspaceifexist","information","struct","参数","中文","完成","nowtime","删除","in","creating","official","error","触发","return","1","构建","该","之前","str","type","改变","相应","isblank","gin","中",".","selectattrs","到","current","字","定制","数值","operations","model","beforedelete","方法","属性","unscoped","所有","%","-","interface","段","给","存在","changes","primary","当","ok","一次","when","数据库","operation","查询","结构","文件","an","exec","引用","是","modifytimefield","updating","时候","you","perform","表名",",","设置","+","单独","{","/","fieldbyname","modifytime","ref","option","v%","unix","created","extraoption","]","被","func","beforesave","添加","gorm","haserror",";","any","\"","contain","执行","为","pointer","db","将","操作"," ","}","fmt","deletedonfield","callbacks","注册","skipleft","could","当前","回退","combinedconditionsql","go","通过","on","example","什么","获取","aftersave","在","指针","field","int","2","相关","是否","格式化","格式","`","*","、","deletedon","sqlvars","值","写","beforecreate","createdon","create","如果","返回","字段","callback","停止","quotedtablename","key","v","案例","行为","后","value","字符串","错误","自动","参数值","all","fields","使用","of","primarykeyfield","效果","任何","信息","'","实现","体","search","time","你","的","&&","模型","rollback","deleting","else","设定","调用","6","updatetimestampforupdatecallback","字符","json","时间","instanceid","update","这个","10","定义","[","软","据库","afterupdate","scope","from","数据","returns","sprint","bool","支持","包含","转义","5","ini","string","!","beforeupdate","hasdeletedonfield","define","methods","delete","判断","be","：","and",")","afterfind","updatetimestampforcreatecallback","它","var","dbname","afterdelete","回调","the",":","为空","拓展","sprintf","deletecallback","if","会","3","createtimefield","get","程序","replace","name"],"title":"go-gin-example 10： GORM-Callback","title_tokens":["go","example","callback","10","：","-","gorm","gin"," "]},{"location":"Golang/Project/go-gin-example/10 GORM-Callback/#go-gin-example-10-gorm-callback","text":"","text_tokens":[],"title":"go-gin-example 10： GORM-Callback","title_tokens":["go","example","callback","10","：","-","gorm","gin"," "]},{"location":"Golang/Project/go-gin-example/10 GORM-Callback/#gorm-callbacks","text":"","text_tokens":[],"title":"定制GORM Callbacks","title_tokens":["callbacks","定制"," ","gorm"]},{"location":"Golang/Project/go-gin-example/10 GORM-Callback/#gorm-callback","text":"You could define callback methods to pointer of model struct, it will be called when creating, updating, querying, deleting, if any callback returns an error, gorm will stop future operations and rollback all changes. 可以给模型结构体指针定义回调函数, 它将会在被创建/更新/查询/删除的时候调用, 如果回调返回了错误, gorm会停止未来行为操作并且回退所有改变. 之前程序未实现 Callback 方法, 需要为所有文件单独写一次 BeforeCreate 、 BeforeUpdate 方法","text_tokens":["future","可以","并且","未来","stop","called","函数","to","需要","未","will","了","it","创建","更新","querying","struct","删除","creating","error","之前","改变",".","operations","model","方法","所有","给","changes","一次","when","查询","文件","结构","an","updating","时候","you",",","单独","/","被","gorm","any","为","pointer","将","操作"," ","could","回退","在","指针","、","写","beforecreate","返回","如果","callback","停止","行为","错误","all","of","实现","体","的","模型","rollback","deleting","调用","定义","returns","beforeupdate","define","methods","be","and","它","回调","if","会","程序"],"title":"GORM Callback 是什么","title_tokens":["什么","callback","是"," ","gorm"]},{"location":"Golang/Project/go-gin-example/10 GORM-Callback/#_1","text":"","text_tokens":[],"title":"使用","title_tokens":["使用"]},{"location":"Golang/Project/go-gin-example/10 GORM-Callback/#gormcallback","text":"创建：BeforeSave、BeforeCreate、AfterCreate、AfterSave 更新：BeforeSave、BeforeUpdate、AfterUpdate、AfterSave 删除：BeforeDelete、AfterDelete 查询：AfterFind","text_tokens":["beforeupdate","删除","、","afterdelete","beforecreate","afterupdate","查询","创建","aftercreate","更新","beforedelete","aftersave","afterfind","：","beforesave"," "],"title":"gorm支持的callback方法","title_tokens":["方法","callback","支持","的","gorm"]},{"location":"Golang/Project/go-gin-example/10 GORM-Callback/#callback","text":"在 model.go 文件中定义 // updateTimeStampForCreateCallback will set `CreatedOn`, `ModifiedOn` when creating func updateTimeStampForCreateCallback ( scope * gorm . Scope ) { if ! scope . HasError () { nowTime := time . Now (). Unix () if createTimeField , ok := scope . FieldByName ( \"CreatedOn\" ); ok { if createTimeField . IsBlank { createTimeField . Set ( nowTime ) } } if modifyTimeField , ok := scope . FieldByName ( \"ModifiedOn\" ); ok { if modifyTimeField . IsBlank { modifyTimeField . Set ( nowTime ) } } } } // updateTimeStampForUpdateCallback will set `ModifyTime` when updating func updateTimeStampForUpdateCallback ( scope * gorm . Scope ) { if _ , ok := scope . Get ( \"gorm:update_column\" ); ! ok { scope . SetColumn ( \"ModifiedOn\" , time . Now (). Unix ()) } } 通过 scope.FieldByName(name) 判断是否存在相关字段, 该方法通过 scope.Fields() 获取所有字段 通过 .IsBlank 判断值是否为空 通过 .Set(interface{}) 设置相关值 通过 scope.Get() 获取参数的参数值, 案例中回去查找 gorm:update_column 这个字段的属性 通过 scope.SetColumn(Field, value) 设定字段的值","text_tokens":["_","查找","=","now","回去","(","column","set","setcolumn","will","modifiedon","参数","nowtime","creating","该","isblank","中",".","字","数值","属性","model","方法","所有","interface","段","存在","ok","when","文件","modifytimefield","updating",",","设置","{","/","fieldbyname","modifytime","unix","func","gorm","haserror",";","\"","}"," ","go","通过","获取","field","在","相关","是否","`","*","值","createdon","字段","案例","value","参数值","fields","time","的","设定","updatetimestampforupdatecallback","update","这个","定义","scope","!","判断",")","updatetimestampforcreatecallback",":","为空","if","createtimefield","get","name"],"title":"定义callback","title_tokens":["callback","定义"]},{"location":"Golang/Project/go-gin-example/10 GORM-Callback/#callback_1","text":"在 model.go 的 ini 函数中注册callback db . Callback (). Create (). Replace ( \"gorm:update_time_stamp\" , updateTimeStampForCreateCallback ) db . Callback (). Update (). Replace ( \"gorm:update_time_stamp\" , updateTimeStampForUpdateCallback )","text_tokens":[".","注册","_","updatetimestampforupdatecallback","go","stamp","model","update","在"," ","(","create","callback","函数","ini",",",")","updatetimestampforcreatecallback","gorm","\"",":","time","db","的","replace","中"],"title":"调用callback","title_tokens":["callback","调用"]},{"location":"Golang/Project/go-gin-example/10 GORM-Callback/#_2","text":"当程序写了 Callback 方法的时候, 当GORM执行到相关的操作会自动触发相应的 Callback 方法","text_tokens":["到","方法","相关"," ","写","当","callback","时候",",","了","操作","自动","gorm","触发","执行","会","相应","程序","的"],"title":"效果","title_tokens":["效果"]},{"location":"Golang/Project/go-gin-example/10 GORM-Callback/#_3","text":"软删除, 添加删除时间, 为 model.go 的 Model 结构体添加 DeletedOn 字段 type Model struct { ID int `gorm:\"primary_key\" json:\"id\"` CreatedOn int `json:\"created_on\"` ModifiedOn int `json:\"modified_on\"` DeletedOn int `json:\"deleted_on\"` } func deleteCallback ( scope * gorm . Scope ) { if ! scope . HasError () { var extraOption string if str , ok := scope . Get ( \"gorm:delete_option\" ); ok { extraOption = fmt . Sprint ( str ) } deletedOnField , hasDeletedOnField := scope . FieldByName ( \"DeletedOn\" ) if ! scope . Search . Unscoped && hasDeletedOnField { scope . Raw ( fmt . Sprintf ( \"UPDATE %v SET %v=%v%v%v\" , scope . QuotedTableName (), scope . Quote ( deletedOnField . DBName ), scope . AddToVars ( time . Now (). Unix ()), addExtraSpaceIfExist ( scope . CombinedConditionSql ()), addExtraSpaceIfExist ( extraOption ), )). Exec () } else { scope . Raw ( fmt . Sprintf ( \"DELETE FROM %v%v%v\" , scope . QuotedTableName (), addExtraSpaceIfExist ( scope . CombinedConditionSql ()), addExtraSpaceIfExist ( extraOption ), )). Exec () } } } func addExtraSpaceIfExist ( str string ) string { if str != \"\" { return \" \" + str } return \"\" } 在 model.go 的 ini函数 中添加 db.Callback().Delete().Replace(\"gorm:delete\", deleteCallback) 1. scope.QuotedTableName() 返回引用的表名 2. scope.Raw() 构建原生sql 3. fmt.Sprintf() 格式化并且返回格式化后的字符串数据 4. scope.AddToVars(value) 为字段添加参数 5. scope.Quote() 转义 6. scope 当你在数据库中文完成任何操作, scope包含了当前操作信息 // Scope contain current operation's information when you perform any operation on the database type Scope struct { Search * search Value interface {} SQL string SQLVars [] interface {} db * DB instanceID string primaryKeyField * Field skipLeft bool fields * [] * Field selectAttrs * [] string }","text_tokens":["4","_","quote","modified","deleted","=","原生","now","(","addtovars","id","并且","set","函数","sql","了","modifiedon","database","information","raw","addextraspaceifexist","struct","参数","中文","完成","删除","1","构建","str","type","中",".","selectattrs","current","字","model","unscoped","%","interface","段","primary","当","ok","when","数据库","operation","结构","exec","引用","perform","you","表名",",","+","{","fieldbyname","/","option","v%","created","unix","extraoption","]","func","添加","gorm","haserror",";","\"","contain","any","为","db"," ","deletedonfield","fmt","}","操作","skipleft","当前","combinedconditionsql","go","on","后","field","在","s","int","2","格式化","格式","`","*","deletedon","sqlvars","createdon","返回","callback","quotedtablename","key","v","字符串","value","fields","primarykeyfield","任何","信息","'","体","search","time","你","的","&&","else","6","字符","json","时间","instanceid","update","[","软","据库","scope","from","数据","bool","sprint","包含","转义","5","ini","string","!","delete","get","var",")","dbname","the",":","sprintf","deletecallback","if","3","hasdeletedonfield","return","replace"],"title":"拓展","title_tokens":["拓展"]},{"location":"Golang/Project/go-gin-example/10 GORM-Callback/#ref","text":"official: callback in gorm","text_tokens":["in","official",":","callback"," ","gorm"],"title":"REF:","title_tokens":["ref",":"]},{"location":"Golang/Project/go-gin-example/FlowChart/","text":"流程图 请求流程图 URL 请求打到 gin ，由 gin 分发各个请求到相应的接口 接口对应 GET ， POST ， PUT ， DELETE 等多种请求方式 接口接收 URL 中的参数，构造相应的CRUD查询，查询数据库 将数据库返回的数据返回到前端调用者 JWT产生以及认证 生成JWT JWT认证","text_tokens":["流程图","到","调用","打","由","各个","多种","构造","认证","对应"," ","产生","jwt","据库","请求","以及","数据库","数据","查询数据库","查询","返回","，","crud","调用者","delete","流程","生成","前端","参数","等","用者","url","方式","分发","put","接口","接收","post","相应","get","将","的","gin","中"],"title":"流程图","title_tokens":["流程图","流程"]},{"location":"Golang/Project/go-gin-example/FlowChart/#_1","text":"","text_tokens":[],"title":"流程图","title_tokens":["流程图","流程"]},{"location":"Golang/Project/go-gin-example/FlowChart/#_2","text":"URL 请求打到 gin ，由 gin 分发各个请求到相应的接口 接口对应 GET ， POST ， PUT ， DELETE 等多种请求方式 接口接收 URL 中的参数，构造相应的CRUD查询，查询数据库 将数据库返回的数据返回到前端调用者","text_tokens":["到","调用","打","由","各个","多种","构造","对应"," ","据库","请求","数据库","数据","查询数据库","查询","返回","，","crud","调用者","delete","前端","参数","等","用者","url","方式","分发","put","接口","接收","post","相应","get","将","的","gin","中"],"title":"请求流程图","title_tokens":["流程图","流程","请求"]},{"location":"Golang/Project/go-gin-example/FlowChart/#jwt","text":"生成JWT JWT认证","text_tokens":["生成"," ","jwt","认证"],"title":"JWT产生以及认证","title_tokens":["以及","产生","jwt","认证"]},{"location":"Golang/Project/go-gin-example/InterfaceTestInstance/","text":"接口测试实例","text_tokens":["接口","测试","实例"],"title":"接口测试实例","title_tokens":["接口","测试","实例"]},{"location":"Golang/Project/go-gin-example/InterfaceTestInstance/#_1","text":"","text_tokens":[],"title":"接口测试实例","title_tokens":["接口","测试","实例"]},{"location":"Linux/01 FormattingUdisk/","text":"01: 彻底格式化U盘 在 cmd 下输入 diskpart 在弹出的窗口输出 list disk 选择目标磁盘 select disk 1 清除 clean","text_tokens":["clean","选择","list","下","在","磁盘","格式化","cmd","输入"," ","格式","01","目标","输出","清除","窗口","u盘","diskpart","彻底","select",":","1","弹出","的","disk"],"title":"01: 彻底格式化U盘","title_tokens":["u盘","彻底",":","01","格式化"," ","格式"]},{"location":"Linux/01 FormattingUdisk/#01-u","text":"在 cmd 下输入 diskpart 在弹出的窗口输出 list disk 选择目标磁盘 select disk 1 清除 clean","text_tokens":["clean","选择","list","下","在","cmd"," ","输入","目标","输出","清除","窗口","disk","diskpart","select","1","弹出","的","磁盘"],"title":"01: 彻底格式化U盘","title_tokens":["u盘","彻底",":","01","格式化"," ","格式"]},{"location":"Linux/02 ChangeSources/","text":"02: 更改Ubuntu源 备份源文件 添加源 更新 sudo cp /etc/apt/sources.list /etc/apt/sources_init.list sudo gedit /etc/apt/sources.list apt-get update","text_tokens":[".","_","update","apt","list","-","源","sources","init","ubuntu","文件","源文件","/","gedit","更新","etc","添加","备份","sudo","cp",":","更改","get"," ","02"],"title":"02: 更改Ubuntu源","title_tokens":["源",":","更改","ubuntu"," ","02"]},{"location":"Linux/02 ChangeSources/#02-ubuntu","text":"备份源文件 添加源 更新 sudo cp /etc/apt/sources.list /etc/apt/sources_init.list sudo gedit /etc/apt/sources.list apt-get update","text_tokens":[".","_","update","apt","list","-","源","sources","init","文件","源文件","/","gedit","更新","etc","添加","备份","sudo","cp","get"," "],"title":"02: 更改Ubuntu源","title_tokens":["源",":","更改","ubuntu"," ","02"]},{"location":"Linux/03 Linux安装Golang/","text":"03：Linux安装Golang 到官网下载源文件 mv tar /usr/local 将文件移到 /usr/local 目录下 tar -C /usr/local -xzf .tar 解压到当前目录 sudo vim ~/.bashrc 编辑环境变量 export GOROOT =/ usr / local / go export GOPATH = $ HOME / go export PATH = $ PATH :$ GOROOT / bin : $ GOPATH / bin export GOPAORXY = https : // goproxy . io , direct export GO111MODULE = on source ~/.bashrc 更新环境变量","text_tokens":[".","当前","gopath","到","mv","目录","go","go111module","on","=","io","下","编辑","-","当前目录","~","export","bin","gopaorxy","c","path","移","文件","https","03","usr","环境变","golang","tar","解压","官网","源文件",",","home","/","更新","安装","$","local","：","goproxy","sudo","direct","bashrc",":","环境变量","goroot","source","环境","xzf","vim","下载","变量","将"," ","linux"],"title":"03：Linux安装Golang","title_tokens":["安装","：","03","golang","linux"]},{"location":"Linux/03 Linux安装Golang/#03linuxgolang","text":"到官网下载源文件 mv tar /usr/local 将文件移到 /usr/local 目录下 tar -C /usr/local -xzf .tar 解压到当前目录 sudo vim ~/.bashrc 编辑环境变量 export GOROOT =/ usr / local / go export GOPATH = $ HOME / go export PATH = $ PATH :$ GOROOT / bin : $ GOPATH / bin export GOPAORXY = https : // goproxy . io , direct export GO111MODULE = on source ~/.bashrc 更新环境变量","text_tokens":[".","当前","gopath","到","mv","目录","go","go111module","on","=","io","下","编辑","-","当前目录","~","export","bin","gopaorxy","c","path","移","文件","https","usr","环境变","tar","解压","官网","源文件",",","home","/","更新","$","local","goproxy","sudo","direct","bashrc",":","环境变量","goroot","source","环境","xzf","vim","下载","变量","将"," "],"title":"03：Linux安装Golang","title_tokens":["安装","：","03","golang","linux"]},{"location":"Linux/0n Hello Manjaro/","text":"Hello Manjaro 安装 refus manjaro linux iso文件 U盘 / usr : 系统软件 / etc : 配置文件 / boot / efi : 300 mb ( 标记 boot esp ) + 引导 fat32 , 最前面 , / opt : 第三方软件 15 G 8 / : 25 G 10 / swap : 交换空间 , 虚拟内存 8 g 内存空间\\硬盘空间 8 g / home : 用户配置 基本配置 系统配置 添加国内源 sudo pacman-mirrors -c China 添加 archlinuxcn 中国源 sudo nvim /etc/pacman.conf [ archlinuxcn ] Server = https://mirrors.cloud.tencent.com/archlinuxcn/ $arch 更新 sudo pacman -Syyu 安装yay以安装AUR包 sudo pacman -Sy yay 修改系统时间 sudo timedatectl set-local-rtc true 配置Github 生成ssh-key, 添加 id_rsa.pub 到Github ssh-keygen -t -rsa -C \"your_email@example.com\" 设置用户名和邮件 git config --global user.name \"your_name\" git config --global user.email \"your_email\" git config -l # 查看配置 优化shell sudo pacman -Sy fish # 安装fish which fish # 查看fish位置 chsh -s /usr/bin/fish # 修改默认shell fish_config # shell美化 优化终端 原生终端: 设置透明背景 simple terminal git clone https://github.com/zyeking/st_config.git 配置Nvim yay -Sy neovim # 安装 yay -Sy npm nodejs # 安装npm和nodejs以安装coc插件 npm config set registry https://registry.npm.taobao.org # 修改npm国内源 npm config get registry # 测试 sudo touch ~/.config/nvim/init.vim # 创建配置文件 cd ~/.config/nvim git clone https://github.com/zyeking/nvim.git 配置Golang 软件 输入法 yay -Sy fcitx-sogoupinyin yay -Sy fcitx-im yay -Sy fcitx-configtool yay -Sy fcitx-qt4 # sudo nvim ~/.xprofile export GTK_IM_MODULE = fcitx export QT_IM_MODULE = fcitx export XMODIFIERS = \"@im=fcitx\" yay -Sy compton # 解决输入法黑边问题, 新名字为picom compton -b # 可添加到Autostart中 其他软件 yay -Sy google-chrome # 谷歌浏览器 yay -Sy netease-cloud-music # 网易云音乐 yay -Sy electronic-wechat # 微信 yay -Sy xmind # XMind yay -Sy calibre # 图书管理工具 yay -Sy nutstore # 坚果云 yay -Sy kdenlive # 视频剪辑工具 yay -Sy flameshot # 截图软件, 配置全局快捷键 yay -Sy typora # Markdown编辑器 yay -Sy latte-dock # dock栏 wps配置 yay -Sy wps-office # -cn为中文版 sudo nvim /usr/bin/wps # 添加以下配置解决无法输入中文的问题 export GTK_IM_MODULE = fcitx export QT_IM_MODULE = fcitx export XMODIFIERS = \"@im=fcitx\" KDE美化 Netspeed Event Calendar Active Window Control 其他问题 解决Manjaro重启壁纸重设问题 ifconfig指令找不到","text_tokens":["_","包","registry","交换","无法","音乐","g","找","=","rsa","原生","问题","~","server","npm","(","dock","fcitx","nutstore","xprofile","黑","true","office","id","系统","邮件","simple","google","set","微信","\\","usr","配置","swap","flameshot","com","软件","compton","wechat","picom","视频剪辑","输入法","系统软件","8","更新","安装","$","mb","@","创建","中文","st","剪辑","修改","arch","可","refus","manjaro","谷歌","理工","测试","虚拟","和","zyeking","重启","截图","linux","github","最",".","fish","中","wps","到","引导","用户名","module","user","中文版","tencent","浏览器","kde","latte","window","hello","-","默认","入法","xmodifiers","输入","其他软件","active","ifconfig","aur","rtc","qt4","快捷","美化","syyu","org","工具","文件","快捷键","视频","global","边","golang","系统配","文版","keygen","u盘","+",",","设置","chsh","/","不到","]","configtool","cn","添加","栏","autostart","新","esp","\"","efi","nvim","config","conf","china","sy","用户","fat32","为","重设","xmind","管理","boot","查看"," ","coc","opt","基本","ssh","electronic","markdown","指令","网易","example","国内","clone","s","编辑","l","pacman","git","管理工具","源","插件","calendar","mirrors","calibre","https","全局","shell","壁纸","cd","编辑器","系统配置","300","空间","home","chrome","key","b","local","统配","nodejs","netspeed","terminal","内存","sudo","虚拟内存","t","云","im","中国","三方","内存空间","qt","标记","vim","的","15","touch","your","timedatectl","第三","解决","cloud","硬盘空间","时间","pub","终端","透明","netease","event","10","硬盘","户名","[","export","bin","位置","c","背景","图书","init","control","typora","music","坚果","以下","名字","浏览","yay","以","生成","which","其他","etc","get",")","第三方","前面","neovim","优化","配置文件","kdenlive",":","gtk","sogoupinyin","email","#","taobao","archlinuxcn","iso","name","25"],"title":"Hello Manjaro","title_tokens":["hello"," ","manjaro"]},{"location":"Linux/0n Hello Manjaro/#hello-manjaro","text":"","text_tokens":[],"title":"Hello Manjaro","title_tokens":["hello"," ","manjaro"]},{"location":"Linux/0n Hello Manjaro/#_1","text":"refus manjaro linux iso文件 U盘 / usr : 系统软件 / etc : 配置文件 / boot / efi : 300 mb ( 标记 boot esp ) + 引导 fat32 , 最前面 , / opt : 第三方软件 15 G 8 / : 25 G 10 / swap : 交换空间 , 虚拟内存 8 g 内存空间\\硬盘空间 8 g / home : 用户配置","text_tokens":["最","引导","交换","第三","g","硬盘空间","10","硬盘","(","系统","opt","文件","15","\\","usr","300","配置","u盘","swap","空间","+",",","home","/","软件","系统软件","8","etc","mb",")","第三方","内存","前面","esp","虚拟内存","配置文件","efi",":","三方","内存空间","虚拟","refus","manjaro","用户","标记","fat32","iso","boot"," ","linux","25"],"title":"安装","title_tokens":["安装"]},{"location":"Linux/0n Hello Manjaro/#_2","text":"","text_tokens":[],"title":"基本配置","title_tokens":["配置","基本"]},{"location":"Linux/0n Hello Manjaro/#_3","text":"添加国内源 sudo pacman-mirrors -c China 添加 archlinuxcn 中国源 sudo nvim /etc/pacman.conf [ archlinuxcn ] Server = https://mirrors.cloud.tencent.com/archlinuxcn/ $arch 更新 sudo pacman -Syyu 安装yay以安装AUR包 sudo pacman -Sy yay 修改系统时间 sudo timedatectl set-local-rtc true","text_tokens":[".","包","timedatectl","cloud","时间","tencent","=","国内","-","[","pacman","server","源","aur","c","rtc","mirrors","true","syyu","系统","set","https","com","/","yay","以","更新","$","安装","etc","]","local","添加","sudo","修改","nvim",":","中国","conf","china","arch","sy","archlinuxcn"," "],"title":"系统配置","title_tokens":["系统","统配","系统配置","系统配","配置"]},{"location":"Linux/0n Hello Manjaro/#github","text":"生成ssh-key, 添加 id_rsa.pub 到Github ssh-keygen -t -rsa -C \"your_email@example.com\" 设置用户名和邮件 git config --global user.name \"your_name\" git config --global user.email \"your_email\" git config -l # 查看配置","text_tokens":[".","_","your","到","用户名","user","pub","example","rsa","户名","-","l","git","c","id","邮件","global","配置","keygen",",","设置","name","key","com","生成","@","添加","t","\"","config","用户","email","#","和","查看"," ","ssh","github"],"title":"配置Github","title_tokens":["配置","github"]},{"location":"Linux/0n Hello Manjaro/#shell","text":"sudo pacman -Sy fish # 安装fish which fish # 查看fish位置 chsh -s /usr/bin/fish # 修改默认shell fish_config # shell美化","text_tokens":["fish","_","s","默认","-","pacman","bin","位置","美化","shell","usr","chsh","/","which","安装","sudo","修改","config","sy","#","查看"," "],"title":"优化shell","title_tokens":["shell","优化"]},{"location":"Linux/0n Hello Manjaro/#_4","text":"原生终端: 设置透明背景 simple terminal git clone https://github.com/zyeking/st_config.git","text_tokens":[".","_","透明","终端","clone","原生","git","背景","simple","https","设置","com","/","terminal","st",":","config","zyeking"," ","github"],"title":"优化终端","title_tokens":["终端","优化"]},{"location":"Linux/0n Hello Manjaro/#nvim","text":"yay -Sy neovim # 安装 yay -Sy npm nodejs # 安装npm和nodejs以安装coc插件 npm config set registry https://registry.npm.taobao.org # 修改npm国内源 npm config get registry # 测试 sudo touch ~/.config/nvim/init.vim # 创建配置文件 cd ~/.config/nvim git clone https://github.com/zyeking/nvim.git","text_tokens":[".","registry","国内","clone","-","~","git","npm","源","插件","init","org","文件","set","https","cd","配置","com","/","yay","以","创建","安装","nodejs","sudo","neovim","配置文件","修改",":","config","nvim","sy","测试","#","taobao","vim","get","和","zyeking"," ","coc","touch","github"],"title":"配置Nvim","title_tokens":["配置","nvim"]},{"location":"Linux/0n Hello Manjaro/#golang","text":"","text_tokens":[],"title":"配置Golang","title_tokens":["golang","配置"]},{"location":"Linux/0n Hello Manjaro/#_5","text":"输入法 yay -Sy fcitx-sogoupinyin yay -Sy fcitx-im yay -Sy fcitx-configtool yay -Sy fcitx-qt4 # sudo nvim ~/.xprofile export GTK_IM_MODULE = fcitx export QT_IM_MODULE = fcitx export XMODIFIERS = \"@im=fcitx\" yay -Sy compton # 解决输入法黑边问题, 新名字为picom compton -b # 可添加到Autostart中 其他软件 yay -Sy google-chrome # 谷歌浏览器 yay -Sy netease-cloud-music # 网易云音乐 yay -Sy electronic-wechat # 微信 yay -Sy xmind # XMind yay -Sy calibre # 图书管理工具 yay -Sy nutstore # 坚果云 yay -Sy kdenlive # 视频剪辑工具 yay -Sy flameshot # 截图软件, 配置全局快捷键 yay -Sy typora # Markdown编辑器 yay -Sy latte-dock # dock栏 wps配置 yay -Sy wps-office # -cn为中文版 sudo nvim /usr/bin/wps # 添加以下配置解决无法输入中文的问题 export GTK_IM_MODULE = fcitx export QT_IM_MODULE = fcitx export XMODIFIERS = \"@im=fcitx\"","text_tokens":["_","无法","音乐","=","问题","~","dock","fcitx","nutstore","xprofile","黑","office","google","微信","usr","flameshot","配置","compton","软件","wechat","picom","视频剪辑","输入法","@","中文","剪辑","可","谷歌","理工","截图","中",".","wps","到","module","中文版","浏览器","latte","-","xmodifiers","入法","其他软件","输入","快捷","qt4","工具","快捷键","视频","边","文版",",","/","configtool","cn","添加","栏","autostart","新","\"","nvim","sy","为","xmind","管理"," ","electronic","markdown","网易","编辑","管理工具","calibre","全局","编辑器","chrome","b","sudo","云","im","qt","的","解决","cloud","netease","export","bin","图书","typora","music","坚果","以下","名字","浏览","yay","其他","kdenlive","gtk","sogoupinyin","#"],"title":"软件","title_tokens":["软件"]},{"location":"Linux/0n Hello Manjaro/#kde","text":"Netspeed Event Calendar Active Window Control","text_tokens":["calendar","control","event","window","netspeed"," ","active"],"title":"KDE美化","title_tokens":["美化","kde"]},{"location":"Linux/0n Hello Manjaro/#_6","text":"解决Manjaro重启壁纸重设问题 ifconfig指令找不到","text_tokens":["不到","解决","指令","manjaro","重设","找","壁纸","重启","问题"," ","ifconfig"],"title":"其他问题","title_tokens":["问题","其他"]},{"location":"Linux/MyUbuntu/01 Install/","text":"","text_tokens":[],"title":"01 Install","title_tokens":["01","install"," "]},{"location":"Linux/MyUbuntu/toc/","text":"INSTALL CONFIGUE SOURCE IMGAE vim /etc/source.list GOOGLE PINYIN FCITX INDICATOR-MONITOR GITHUB PYTHON3 ln GOLANG VIM NEOVIM VUNDLE/VIM-PLUG VIM-GO AIRLINE NDTREE MARKDOWN ~~RANGER~~ TMUX curl -fLo ~/.config/nvim/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/ plug.vim","text_tokens":[".","markdown","go","configue","list","ndtree","flo","-","~","master","fcitx","airline","ranger","install","google","create","dirs","plug","https","curl","python3","golang","monitor","com","/","indicator","imgae","vundle","raw","etc","pinyin","githubusercontent","neovim","tmux","nvim","config",":","source","autoload","vim","junegunn","ln"," ","github"],"title":"Toc","title_tokens":["toc"]},{"location":"Nginx/01 openstry/","text":"01 openstry Nginx基础指令 nginx ：启动Nginx nginx -s reload ：重新加载配置文件 nginx -s stop ：停止Nginx服务 nginx -t ：测试配置文件是否正确 匹配等级 第一优先级 严格匹配，仅仅匹配 /a location = /a { echo \"hello /a\" ; } 第二优先级 匹配 /a开头 的字符串 localtion ^~ /a { echo \"hello ~ /a\"; } 同优先级，看匹配程度。 第三优先级 正则匹配 location ~ /[a-zA-Z0-9_-]+ { echo \"~ /\\W\" ; } 第四优先级 匹配所有请求 location / { echo \"hello nginx\" ; } 反向代理 将请求通过 process_pass 转发到目标服务器 location { proxy_pass http://192.168.0.12:80 ; } 访问 localhost/a 的时候会发生404 NOT FOUND，因为目标服务器中没有 http://192.168.0.12:80/a location / { echo “hello” ; } location /a { proxy_pass http://192.168.0.12:80 ; } ​ 如果需要将 /a 请求代理到目标服务器的 / 路径，则需要在代理服务器后加 / 表示绝对路径，访问 localhot:/a/ location / { echo “hello” ; } location /a/ { proxy_pass http://192.168.0.12:80/ ; } 负载均衡 通过 upsteam 模块声明服务器组实现负载均衡 weight ：配置服务器权重 ip_hash ：按照访问IP的hash结果值分配 fair ：按照后端服务器响应时间分配，时间短的优先级高 url_hash ：按照访问URL的hash结果值分配 upstream group1 { server 192.168.0.12 : 80 weight=10； server 192.168.0.12 : 81 weight=1； } location / { echo “hello” ; } location /a { proxy_pass http:/group1/ ; }","text_tokens":["等级","_","结果","组","ip","优先级","路径","=","~","声明","server","同","服务器","访问","没有","stop","需要","\\","加载","配置","代理","，","响应","process","“","upstream","正则","看","第一","严格","url","因为","负载","发生","reload","w","1","开头","fair","测试","启动","location","80","中",".","到","第四","9","所有","hello","-","proxy","01","81","openstry","目标","文件","仅仅","时候","。","+","模块","权重","{","/","均衡","务器","]","localhost","高","http",";","代理服务器","绝对路径","\"","0.12","端","绝对","分配","匹配","za","将"," ","}","指令","通过","z0","​","后","在","s","是否","404","值","请求","短","如果","a","not","服务","重新","；","停止","转发","字符串","weight","第二","则","优先","t","正确","实现","”","^","的","192.168","nginx","第三","字符","时间","localtion","表示","localhot","10","[","反向","基础","后加","found","程度","echo","按照","hash","：","group1","pass","upsteam","配置文件",":","会"],"title":"01 openstry","title_tokens":["01"," ","openstry"]},{"location":"Nginx/01 openstry/#01-openstry","text":"","text_tokens":[],"title":"01 openstry","title_tokens":["01"," ","openstry"]},{"location":"Nginx/01 openstry/#nginx","text":"nginx ：启动Nginx nginx -s reload ：重新加载配置文件 nginx -s stop ：停止Nginx服务 nginx -t ：测试配置文件是否正确","text_tokens":["nginx","s","-","是否","文件","stop","加载","服务","配置","重新","停止","：","t","配置文件","reload","正确","测试","启动"," "],"title":"Nginx基础指令","title_tokens":["nginx","指令","基础"]},{"location":"Nginx/01 openstry/#_1","text":"","text_tokens":[],"title":"匹配等级","title_tokens":["等级","匹配"]},{"location":"Nginx/01 openstry/#_2","text":"严格匹配，仅仅匹配 /a location = /a { echo \"hello /a\" ; }","text_tokens":[";","，","\"","echo","{","/","=","匹配","a","严格","hello"," ","location","仅仅","}"],"title":"第一优先级","title_tokens":["优先级","优先","第一"]},{"location":"Nginx/01 openstry/#_3","text":"匹配 /a开头 的字符串 localtion ^~ /a { echo \"hello ~ /a\"; } 同优先级，看匹配程度。","text_tokens":["字符","优先级","localtion","hello","~"," ","同","a","程度","。","，","echo","{","/","字符串","看","优先",";","\"","开头","匹配","^","的","}"],"title":"第二优先级","title_tokens":["第二","优先级","优先"]},{"location":"Nginx/01 openstry/#_4","text":"正则匹配 location ~ /[a-zA-Z0-9_-]+ { echo \"~ /\\W\" ; }","text_tokens":["_","9","z0","-","[","~","a","\\","+","echo","{","/","正则","]",";","\"","w","匹配","za","location"," ","}"],"title":"第三优先级","title_tokens":["第三","优先级","优先"]},{"location":"Nginx/01 openstry/#_5","text":"匹配所有请求 location / { echo \"hello nginx\" ; }","text_tokens":["nginx",";","\"","echo","请求","{","/","匹配","所有","location","hello"," ","}"],"title":"第四优先级","title_tokens":["优先级","优先","第四"]},{"location":"Nginx/01 openstry/#_6","text":"将请求通过 process_pass 转发到目标服务器 location { proxy_pass http://192.168.0.12:80 ; } 访问 localhost/a 的时候会发生404 NOT FOUND，因为目标服务器中没有 http://192.168.0.12:80/a location / { echo “hello” ; } location /a { proxy_pass http://192.168.0.12:80 ; } ​ 如果需要将 /a 请求代理到目标服务器的 / 路径，则需要在代理服务器后加 / 表示绝对路径，访问 localhot:/a/ location / { echo “hello” ; } location /a/ { proxy_pass http://192.168.0.12:80/ ; }","text_tokens":[".","_","的","到","通过","路径","​","表示","localhot","在","hello","80","proxy","404","请求","服务器","访问","没有","目标","如果","后加","found","a","not","需要","服务","时候","代理","，","echo","转发","{","/","process","“","务器","中","localhost","则","pass","http",";","代理服务器","因为","绝对路径","0.12",":","发生","绝对","会","”","location","将"," ","192.168","}"],"title":"反向代理","title_tokens":["代理","反向"]},{"location":"Nginx/01 openstry/#_7","text":"通过 upsteam 模块声明服务器组实现负载均衡 weight ：配置服务器权重 ip_hash ：按照访问IP的hash结果值分配 fair ：按照后端服务器响应时间分配，时间短的优先级高 url_hash ：按照访问URL的hash结果值分配 upstream group1 { server 192.168.0.12 : 80 weight=10； server 192.168.0.12 : 81 weight=1； } location / { echo “hello” ; } location /a { proxy_pass http:/group1/ ; }","text_tokens":[".","_","的","结果","组","ip","通过","时间","优先级","=","后","10","hello","80","声明","server","proxy","值","81","服务器","访问","短","a","服务","配置","；","模块","权重","响应","，","echo","{","均衡","/","“","按照","hash","weight","务器","upstream","高","：","group1","pass","优先","upsteam","url",";","http","0.12","负载",":","1","端","实现","fair","分配","”","location"," ","192.168","}"],"title":"负载均衡","title_tokens":["均衡","负载"]},{"location":"Nginx/02 将Go应用部署在Nginx上/","text":"02 将Go应用部署在Nginx上 配置hosts 127.0.0.1 api.blog.com 配置nginx.conf 实现反向代理，将本地的 api.blog.com:8081 的所有请求代理给Go应用程序的8000端口 worker_processes 1 ; events { worker_connections 1024 ; } http { include mime.types ; default_type application/octet-stream ; sendfile on ; keepalive_timeout 65 ; server { # 监听本地8081 # api.blog.com:8081 listen 8081 ; server_name api.blog.com ; # 将所有请求打给api.blog.com location / { # URL最后的斜杠表示绝对路径 proxy_pass http://127.0.0.1:8000/ ; } } } 启动 在项目路径下通过 go build . 将程序打包成 .exe 文件。在命令行中启动该程序。 通过postman验证请求 http://api.blog.com:8081/auth?username=test&password=test123456 负载均衡 修改 nginx.conf worker_processes 1 ; events { worker_connections 1024 ; } http { include mime.types ; default_type application/octet-stream ; sendfile on ; keepalive_timeout 65 ; # 添加upstream节点 upstream api.blog.com { server 127.0.0.1 : 8001 ; server 127.0.0.1 : 8002 ; } server { listen 8081 ; server_name api.blog.com ; location / { proxy_pass http://api.blog.com/ ; } } } 修改 conf/app.ini 配置不同的端口，分别通过 go build -o [name] 编译成两个应用程序。通过postman多次请求发现两个程序都能够接受到nginx分发过来的请求，实现了负载均衡。","text_tokens":["_","都","打","分别","路径","1024","=","0.1","译成","server","connections","多次","配置","代理","，","编译","了","com","65","upstream","最后","username","验证","节点","url","postman","负载","修改","1","该","启动","type","location","password","auth","本地","中",".","到","processes","build","所有","-","给","proxy","types","文件","test123456","api","。","o","application","{","/","均衡","8001","]","worker","两个","timeout","添加","http",";","绝对路径","conf","分发","octet","绝对","过来","将","}"," ","命令","events","8081","stream","go","通过","on","下","在","请求","app","成","8002","应用","编译成","?","keepalive","监听","项目","接受","hosts","sendfile","实现","端口","listen","8000","的","02","nginx","斜杠","test","能够","blog","&","发现","表示","mime","[","反向","上","exe","default","打包","ini","include","部署","127.0","命令行","pass",":","应用程序","#","不同","程序","name"],"title":"02 将Go应用部署在Nginx上","title_tokens":["nginx","上","go","应用","在","将"," ","部署","02"]},{"location":"Nginx/02 将Go应用部署在Nginx上/#02-gonginx","text":"","text_tokens":[],"title":"02 将Go应用部署在Nginx上","title_tokens":["nginx","上","go","应用","在","将"," ","部署","02"]},{"location":"Nginx/02 将Go应用部署在Nginx上/#hosts","text":"127.0.0.1 api.blog.com","text_tokens":[".","blog","com","0.1","api"," ","127.0"],"title":"配置hosts","title_tokens":["hosts","配置"]},{"location":"Nginx/02 将Go应用部署在Nginx上/#nginxconf","text":"实现反向代理，将本地的 api.blog.com:8081 的所有请求代理给Go应用程序的8000端口 worker_processes 1 ; events { worker_connections 1024 ; } http { include mime.types ; default_type application/octet-stream ; sendfile on ; keepalive_timeout 65 ; server { # 监听本地8081 # api.blog.com:8081 listen 8081 ; server_name api.blog.com ; # 将所有请求打给api.blog.com location / { # URL最后的斜杠表示绝对路径 proxy_pass http://127.0.0.1:8000/ ; } } }","text_tokens":["events",".","8081","_","斜杠","stream","打","blog","go","on","表示","mime","1024","路径","processes","0.1","所有","-","反向","给"," ","connections","server","proxy","请求","types","default","应用","include","api","127.0","代理","，","application","name","com","{","/","keepalive","65","8000","最后","worker","timeout","监听","pass","url","http",";","绝对路径",":","}","1","octet","绝对","sendfile","实现","端口","应用程序","#","type","listen","程序","location","将","的","本地"],"title":"配置nginx.conf","title_tokens":["nginx",".","conf","配置"]},{"location":"Nginx/02 将Go应用部署在Nginx上/#_1","text":"在项目路径下通过 go build . 将程序打包成 .exe 文件。在命令行中启动该程序。 通过postman验证请求 http://api.blog.com:8081/auth?username=test&password=test123456","text_tokens":["test",".","8081","blog","go","通过","&","路径","=","build","下","在"," ","password","请求","exe","成","文件","打包","test123456","api","。","?","com","/","命令行","username","验证","项目","http","postman",":","该","启动","将","auth","程序","命令","中"],"title":"启动","title_tokens":["启动"]},{"location":"Nginx/02 将Go应用部署在Nginx上/#_2","text":"修改 nginx.conf worker_processes 1 ; events { worker_connections 1024 ; } http { include mime.types ; default_type application/octet-stream ; sendfile on ; keepalive_timeout 65 ; # 添加upstream节点 upstream api.blog.com { server 127.0.0.1 : 8001 ; server 127.0.0.1 : 8002 ; } server { listen 8081 ; server_name api.blog.com ; location / { proxy_pass http://api.blog.com/ ; } } } 修改 conf/app.ini 配置不同的端口，分别通过 go build -o [name] 编译成两个应用程序。通过postman多次请求发现两个程序都能够接受到nginx分发过来的请求，实现了负载均衡。","text_tokens":["_","都","分别","1024","0.1","译成","server","connections","多次","配置","，","编译","了","com","65","upstream","节点","postman","修改","负载","1","type","location",".","到","processes","build","-","proxy","types","api","。","o","application","{","/","均衡","8001","]","worker","两个","timeout","添加","http",";","conf","分发","octet","过来"," ","}","events","8081","stream","go","通过","on","app","请求","8002","应用","编译成","keepalive","接受","sendfile","端口","实现","listen","的","nginx","能够","blog","发现","mime","[","default","ini","include","127.0","pass",":","#","应用程序","不同","程序","name"],"title":"负载均衡","title_tokens":["均衡","负载"]},{"location":"Others/01 MySql/","text":"使用Mysql 安装 下载 配置 编辑 my.ini 文件 在Mysql安装文件夹下新建 my.ini 文件 [client] # 设置mysql客户端默认字符集 default-character-set = utf8 [mysqld] # 设置3306端口 port = 3306 # 设置mysql的安装目录 basedir = C:/Software/IDE/mysql-8.0.18 # 设置数据存放位置 datadir = C:/Software/IDE/mysql-8.0.18/data # 设置初始密码, 好像没有什么用 default_authentication_plugin = mysql_native_password # 允许最大连接数 max_connections = 20 # 服务端使用的字符集默认为8比特编码的latin1字符集 character-set-server = UTF8MB4 # 创建新表时将使用的默认存储引擎 default-storage-engine = INNODB 其中 datadir 不能有任何文件, 否则启动mysql服务会报错: --initialize specified but the data directory has files in it. Aborting. 配置完成后进入安装路径的 .\\bin 目录, 用管理员身份打开 CMD 键入: mysqld --initialize --console 进行初始化得到密码 输入mysql指令发现 You must reset your password using ALTER USER statement before executing this statement. , 需要通过 alter user user() identified by \"mypwd\"; 修改密码即可. mysql常用指令 [WINDOWS] mysqld install : 安装mysql服务 [WINDOWS管理员] net start mysql : 启动mysql服务 mysql -u root -p : 进入mysql alter user user() identified by \"passwrod\"; : 修改mysql密码 mysql可视化 heidi sql REF: 安装mysql 设置mysql密码","text_tokens":["_","进行","路径","aborting","initialize","=","max","件夹","得到","server","connections","(","否则","must","没有","reset","set","有","plugin","需要","\\","配置","8.0","net","客户端","specified","存放","20","sql","utf8","字符集","latin1","it","用","8","创建","安装","files","完成","初始密码","in","basedir","修改","初始","statement","启动","下载","password","my","可视化",".","常用","新建","好像","but","directory","user","ide","报错","identified","默认","-","输入","键入","文件","连接数","密码","you","允许",",","设置","ref","/","不能","打开","u","编码","]","进入","比特",";","\"","has","windows","heidi","为","管理","将","utf8mb4"," ","innodb","software","客户","using","目录","指令","通过","什么","后","文件夹","下","在","引擎","编辑","console","初始化","this","cmd","mysql","即可","服务端","install","mypwd","其中","alter","character","服务","身份","可视","存储","3306","storage","port","管理员","使用","executing","engine","mysqld","p","任何","端口","的","18","your","字符","发现","authentication","by","native","[","最大","client","bin","位置","passwrod","c","数据","datadir","default","root","ini","新表时","start",")","the","before",":","会","#","连接","data"],"title":"使用Mysql","title_tokens":["使用","mysql"]},{"location":"Others/01 MySql/#mysql","text":"","text_tokens":[],"title":"使用Mysql","title_tokens":["使用","mysql"]},{"location":"Others/01 MySql/#_1","text":"下载","text_tokens":["下载"],"title":"安装","title_tokens":["安装"]},{"location":"Others/01 MySql/#_2","text":"编辑 my.ini 文件 在Mysql安装文件夹下新建 my.ini 文件 [client] # 设置mysql客户端默认字符集 default-character-set = utf8 [mysqld] # 设置3306端口 port = 3306 # 设置mysql的安装目录 basedir = C:/Software/IDE/mysql-8.0.18 # 设置数据存放位置 datadir = C:/Software/IDE/mysql-8.0.18/data # 设置初始密码, 好像没有什么用 default_authentication_plugin = mysql_native_password # 允许最大连接数 max_connections = 20 # 服务端使用的字符集默认为8比特编码的latin1字符集 character-set-server = UTF8MB4 # 创建新表时将使用的默认存储引擎 default-storage-engine = INNODB 其中 datadir 不能有任何文件, 否则启动mysql服务会报错: --initialize specified but the data directory has files in it. Aborting. 配置完成后进入安装路径的 .\\bin 目录, 用管理员身份打开 CMD 键入: mysqld --initialize --console 进行初始化得到密码 输入mysql指令发现 You must reset your password using ALTER USER statement before executing this statement. , 需要通过 alter user user() identified by \"mypwd\"; 修改密码即可.","text_tokens":["_","进行","路径","aborting","initialize","=","max","件夹","得到","server","connections","(","否则","must","没有","reset","set","有","plugin","需要","\\","配置","8.0","客户端","specified","存放","20","utf8","字符集","latin1","it","用","8","创建","安装","files","完成","初始密码","in","basedir","修改","初始","statement","启动","password","my",".","新建","好像","but","directory","user","ide","报错","identified","默认","-","输入","键入","文件","连接数","密码","you","允许",",","设置","/","不能","打开","编码","]","进入","比特",";","\"","has","为","管理","将","utf8mb4"," ","innodb","software","客户","using","目录","指令","通过","什么","后","文件夹","下","在","引擎","编辑","console","初始化","this","cmd","mysql","即可","服务端","mypwd","其中","alter","character","服务","身份","存储","3306","storage","port","管理员","使用","executing","engine","mysqld","任何","端口","的","18","your","字符","发现","authentication","by","native","[","最大","client","bin","位置","c","数据","datadir","default","ini","新表时",")","the","before",":","会","#","连接","data"],"title":"配置","title_tokens":["配置"]},{"location":"Others/01 MySql/#mysql_1","text":"[WINDOWS] mysqld install : 安装mysql服务 [WINDOWS管理员] net start mysql : 启动mysql服务 mysql -u root -p : 进入mysql alter user user() identified by \"passwrod\"; : 修改mysql密码","text_tokens":["user","identified","by","-","[","(","passwrod","mysql","install","alter","root","服务","start","密码","net","u","安装","]","进入","管理员",")",";","\"","p","mysqld",":","修改","windows","启动","管理"," "],"title":"mysql常用指令","title_tokens":["常用","mysql","指令"]},{"location":"Others/01 MySql/#mysql_2","text":"heidi sql","text_tokens":[" ","heidi","sql"],"title":"mysql可视化","title_tokens":["可视","mysql","可视化"]},{"location":"Others/01 MySql/#ref","text":"安装mysql 设置mysql密码","text_tokens":["设置","mysql","安装"," ","密码"],"title":"REF:","title_tokens":["ref",":"]},{"location":"Others/Excel/01 AutoCreateTime/","text":"1. 自动创建数据时间，不受其他修改影响的 NOW() 在 选项 下的 公式 启用 迭代计算 使得excel不会报循环引用的警告⚠ 此处的 C列 会自动根据 D列 数据创建时间，该时间不会根据其他的列改变 excel = IF ( D2 = \"\" , \"\" , IF ( C2 = \"\" , NOW () , C2 )) 参考URL： 循环引用 自动创建时间后，锁定时间","text_tokens":[".","不","excel","时间","此处","循环","列","=","下","在","迭代","警告","后","now","锁定"," ","(","使得","启用","c","受","d","数据","⚠","引用","参考","不会","，",",","报","计算","c2","创建","自动","其他","影响","公式","：",")","url","\"","修改","d2","1","if","该","会","根据","改变","选项","的"],"title":"\t1. 自动创建数据时间，不受其他修改影响的`NOW()`","title_tokens":[".","不","时间","now"," ","`","(","受","数据","\t","，","创建","自动","其他","影响",")","修改","1","的"]},{"location":"Others/Excel/01 AutoCreateTime/#1-now","text":"在 选项 下的 公式 启用 迭代计算 使得excel不会报循环引用的警告⚠ 此处的 C列 会自动根据 D列 数据创建时间，该时间不会根据其他的列改变 excel = IF ( D2 = \"\" , \"\" , IF ( C2 = \"\" , NOW () , C2 )) 参考URL： 循环引用 自动创建时间后，锁定时间","text_tokens":["excel","时间","此处","循环","列","=","下","在","迭代","警告","后","now","锁定"," ","(","使得","启用","c","d","⚠","数据","引用","参考","不会","，",",","报","计算","c2","创建","自动","其他","公式","：",")","url","\"","d2","if","该","会","根据","改变","选项","的"],"title":"1. 自动创建数据时间，不受其他修改影响的NOW()","title_tokens":[".","(","，","的","不","修改","受","now","1","时间","数据","创建","自动","其他","影响",")"," "]},{"location":"Others/Excel/02 AutoCreateTimeByMacro/","text":"2. 用宏自动创建数据时间 Private Sub Worksheet_Change ( ByVal Target As Range ) ' ______说明 ↓ ___________________________________ '某列单元格发生变化 '若变化值不为空，对应列添加变化时间点日期时间 '若变化值为空，删除对应单元格数据 '示例为 A列第2行发生变化 ，对应的 B列添加或删除日期 ' ______说明 ↑ ___________________________________ Application . ScreenUpdating = False '关闭屏幕刷新 Dim cA , cB , startRG As String Dim offsetc As Long Dim rg As Range ' ______设置参数 ↓ _________________ cA = \"A\" '变化区域所在列 cB = \"B\" '日期生成列 startRG = \"A1\" '变化区域首单元格 ( 防止改动表头触发事件 ) ' ______设置参数 ↑ _________________ offsetc = Columns ( cB ). Column - Columns ( cA ). Column If Not Application . Intersect ( Target , Columns ( cA ), Range ( startRG , ActiveCell . SpecialCells ( xlLastCell ))) Is Nothing Then For Each rg In Intersect ( Target , Columns ( cA ), Range ( startRG , ActiveCell . SpecialCells ( xlLastCell ))) If rg <> \"\" Then With rg . Offset ( 0 , offsetc ) . Value = Now . NumberFormatLocal = \"yyyy/m/d h:mm:ss ; @\" End With Else rg . Offset ( 0 , offsetc ). Clear End If Next rg End If Application . ScreenUpdating = True '恢复屏幕刷新 End Sub","text_tokens":["_","activecell","点","change","=","offset","屏幕","now","(","column","true","range","byval","关闭","值不为","，","yyyy","创建","@","as","参数","in","删除","0","发生","触发","dim","is",".","↑","private","h","-","long","防止","next","单元","xllastcell","<","end","不为","with","mm","单元格","d","clear","事件","区域","a1","nothing","cb",",","设置","each","或","application","/","某列","______","target","specialcells","添加",";","\"","示例","第","刷新","为"," ","columns","用宏","startrg","m","列","___________________________________","2","对应","若","a","not","表头","↓","value","空","b","then","自动","offsetc","'","恢复","的","日期","else","时间","发生变化","ss","rg","screenupdating","_________________","numberformatlocal","数据","值为","行","ca","sub","string","说明","intersect","生变","生成","改动",")","worksheet","false","所在",":","if","变化","首",">","for"],"title":"2. 用宏自动创建数据时间","title_tokens":[".","用宏","时间","数据","创建","自动","2"," "]},{"location":"Others/Excel/02 AutoCreateTimeByMacro/#2","text":"Private Sub Worksheet_Change ( ByVal Target As Range ) ' ______说明 ↓ ___________________________________ '某列单元格发生变化 '若变化值不为空，对应列添加变化时间点日期时间 '若变化值为空，删除对应单元格数据 '示例为 A列第2行发生变化 ，对应的 B列添加或删除日期 ' ______说明 ↑ ___________________________________ Application . ScreenUpdating = False '关闭屏幕刷新 Dim cA , cB , startRG As String Dim offsetc As Long Dim rg As Range ' ______设置参数 ↓ _________________ cA = \"A\" '变化区域所在列 cB = \"B\" '日期生成列 startRG = \"A1\" '变化区域首单元格 ( 防止改动表头触发事件 ) ' ______设置参数 ↑ _________________ offsetc = Columns ( cB ). Column - Columns ( cA ). Column If Not Application . Intersect ( Target , Columns ( cA ), Range ( startRG , ActiveCell . SpecialCells ( xlLastCell ))) Is Nothing Then For Each rg In Intersect ( Target , Columns ( cA ), Range ( startRG , ActiveCell . SpecialCells ( xlLastCell ))) If rg <> \"\" Then With rg . Offset ( 0 , offsetc ) . Value = Now . NumberFormatLocal = \"yyyy/m/d h:mm:ss ; @\" End With Else rg . Offset ( 0 , offsetc ). Clear End If Next rg End If Application . ScreenUpdating = True '恢复屏幕刷新 End Sub","text_tokens":["_","activecell","点","change","=","offset","屏幕","now","(","column","true","range","byval","关闭","值不为","，","yyyy","@","as","参数","in","删除","0","发生","触发","dim","is",".","↑","private","h","-","long","防止","next","单元","xllastcell","<","end","不为","with","mm","单元格","d","clear","事件","区域","a1","nothing","cb",",","设置","each","或","application","/","某列","______","target","specialcells","添加",";","\"","示例","第","刷新","为"," ","columns","startrg","m","列","___________________________________","2","对应","若","a","not","表头","↓","value","空","b","then","offsetc","'","恢复","的","日期","else","时间","发生变化","ss","rg","screenupdating","_________________","numberformatlocal","值为","数据","行","ca","sub","string","说明","intersect","生变","生成","改动",")","worksheet","false","所在",":","if","变化","首",">","for"],"title":"2. 用宏自动创建数据时间","title_tokens":[".","用宏","时间","数据","创建","自动","2"," "]},{"location":"Others/Excel/03 FormatUnit/","text":"3. 为单元格添加格式 选中需要操作列, 右键选择 设置单元格式 ,选择 自定义 , 输入 :G/[格式]","text_tokens":[".","g","选择","列","定义","[","格式"," ","单元","输入","单元格","选中","需要",",","设置","/","自定","]","添加",":","自定义","为","3","右键","操作"],"title":"3. 为单元格添加格式","title_tokens":[".","单元格","添加","为","格式","3"," ","单元"]},{"location":"Others/Excel/03 FormatUnit/#3","text":"选中需要操作列, 右键选择 设置单元格式 ,选择 自定义 , 输入 :G/[格式]","text_tokens":["g","选择","列","定义","[","单元","输入","格式"," ","选中","需要",",","设置","/","操作","]",":","自定义","右键","自定"],"title":"3. 为单元格添加格式","title_tokens":[".","单元格","添加","为","格式","3"," ","单元"]},{"location":"Others/Excel/04 RepairArrowKey/","text":"4. 方向键无法控制excel表格上下、左右移动 解决： 可能是 SCROLL LOCK 键被打开，在笔记本电脑上可以通过 FN+C 或者 FN+NUMB LK 解锁","text_tokens":["4",".","excel","或者","无法","解决","键","可以","通过","上下","lock","在","方向","、","上","c","fn","解锁","移动","可能","numb","是","控制","左右","，","+","表格","scroll","打开","电脑","笔记本","无法控制","：","被","方向键","笔记本电脑","lk"," ","笔记"],"title":"4. 方向键无法控制excel表格上下、左右移动","title_tokens":["4",".","、","excel","无法","表格","移动","上下","控制","无法控制"," ","左右","方向","方向键"]},{"location":"Others/Excel/04 RepairArrowKey/#4-excel","text":"解决： 可能是 SCROLL LOCK 键被打开，在笔记本电脑上可以通过 FN+C 或者 FN+NUMB LK 解锁","text_tokens":["或者","解决","键","可以","通过","lock","在","上","c","fn","解锁","可能","numb","是","，","+","scroll","打开","电脑","笔记本","被","：","笔记本电脑","lk"," ","笔记"],"title":"4. 方向键无法控制excel表格上下、左右移动","title_tokens":["4",".","、","excel","无法","表格","移动","上下","控制","无法控制"," ","左右","方向","方向键"]},{"location":"Others/Excel/05 MultipleInsertValue/","text":"5. 将单元格的空值换成目标值 选中目标单元格 ctrl + G 选择 定位条件 下的 空值 （或其他） 在输入栏中输入目标值，按 crtl + Enter","text_tokens":[".","enter","g","选择","crtl","下","在"," ","单元","输入","ctrl","空值","单元格","选中","定位","目标","5","）","+","，","或","其他","按","（","栏中","条件","标值","目标值","将","的","换成"],"title":"5. 将单元格的空值换成目标值","title_tokens":[".","的","空值","单元格","标值","目标","目标值","5","将"," ","换成","单元"]},{"location":"Others/Excel/05 MultipleInsertValue/#5","text":"选中目标单元格 ctrl + G 选择 定位条件 下的 空值 （或其他） 在输入栏中输入目标值，按 crtl + Enter","text_tokens":["enter","g","选择","crtl","下","在"," ","单元","输入","ctrl","空值","单元格","选中","定位","目标","）","+","，","或","其他","按","（","栏中","条件","标值","目标值","的"],"title":"5. 将单元格的空值换成目标值","title_tokens":[".","的","空值","单元格","标值","目标","目标值","5","将"," ","换成","单元"]},{"location":"Python/01 UsingTesseract/","text":"Tesseract 下载地址 安装 设置环境变量 系统变量Path Tesseract-OCR路径 新建 TESSDATA_PREFIX 系统变量，变量值为 ...\\Tesseract-OCR\\tessdata 测试 python安装pytesseract pip install pytesseract 修改Python37\\site-packages内的 pytesseract\\pytesseract.py 内的文件，指定安装路径 tesseract_cmd = '.../Tesseract-OCR/tesseract.exe') import pytesseract from PIL import Image // pytesseract . pytesseract . tesseract_cmd = 'C://Program Files (x86)/Tesseract-OCR/tesseract.exe' text = pytesseract . image_to_string ( Image . open ( './demo.jpg' )) print ( text ) REF: 安装 测试","text_tokens":[".","_","的","tesseract","open","指定","新建","路径","=","image","...","-","cmd","(","text","ocr","pil","c","program","python37","exe","install","import","from","path","系统","jpg","文件","packages","量值","prefix","\\","环境变","x86","to","string","demo","，","设置","pytesseract","py","/","ref","site","tessdata","安装","print","files",")","python","修改",":","地址","环境变量","'","pip","环境","测试","变量值","为","下载","变量","内"," "],"title":"Tesseract","title_tokens":["tesseract"]},{"location":"Python/01 UsingTesseract/#tesseract","text":"下载地址 安装 设置环境变量 系统变量Path Tesseract-OCR路径 新建 TESSDATA_PREFIX 系统变量，变量值为 ...\\Tesseract-OCR\\tessdata 测试 python安装pytesseract pip install pytesseract 修改Python37\\site-packages内的 pytesseract\\pytesseract.py 内的文件，指定安装路径 tesseract_cmd = '.../Tesseract-OCR/tesseract.exe') import pytesseract from PIL import Image // pytesseract . pytesseract . tesseract_cmd = 'C://Program Files (x86)/Tesseract-OCR/tesseract.exe' text = pytesseract . image_to_string ( Image . open ( './demo.jpg' )) print ( text )","text_tokens":[".","_","的","tesseract","open","指定","新建","路径","=","image","...","-","cmd","(","text","ocr","pil","c","program","python37","exe","install","import","from","path","系统","jpg","文件","packages","量值","prefix","\\","环境变","x86","to","string","demo","，","设置","pytesseract","py","/","site","tessdata","安装","print","files",")","python","修改",":","地址","环境变量","'","pip","环境","测试","变量值","为","下载","变量","内"," "],"title":"Tesseract","title_tokens":["tesseract"]},{"location":"Python/01 UsingTesseract/#ref","text":"安装 测试","text_tokens":["测试"," ","安装"],"title":"REF:","title_tokens":["ref",":"]},{"location":"Python/02 dzdianpingSpider/","text":"大众点评评价爬取逻辑 分析 如图，评价中的 孩 字在源码中时被 <svgmtsi class=\"cfd1i\"></svgmtsi> 标签加密了。 在css中可以看到该svg图片地址为 background-image: url(//s3plus.meituan.net/v1/mss_0a06a471f9514fc79c981b5466f56b91/svgtextcss/2ec02e25ea201ca1b6b415747003614e.svg); 进入该地址发现是字体文件 加密字体的css中有 background: -0.0px -1808.0px; ，通过搜索可知 x / font-size（svg文件中①） + 1 可以得到该字体在svg中的第几个；比较y坐标和②的比较，其中，取 y<N 中的N值 孩 字 background: -0.0px -1808.0px; 对照可知：x=1，y<1831的path id=47 REF： 大众点评评论抓取-加密评论信息完整抓取","text_tokens":["_","比较","可以","=","得到","y","size","(","几个","id","47","cfd1i","net","，","了","抓取","评论","url","class","如图","1","该","中时","标签","和","x","中",".","字","字体","n","-","<","0a06a471f9514fc79c981b5466f56b91","①","background","2ec02e25ea201ca1b6b415747003614e","svgtextcss","path","文件","是","0.0","坐标","。","可知","+","ref","/","分析","被","v1","进入","s3plus","（",";","\"","地址","逻辑","为","第几个"," ","加密","px","通过","对照","在","css","大众","第几","值","其中","1831","；","font","评价","看到","源码","搜索","1808.0","信息","mss","完整","的","取","发现","image","svg","中有","）","meituan","孩","：",")","②","图片","爬取",":","点评",">","svgmtsi"],"title":"大众点评评价爬取逻辑","title_tokens":["大众","爬取","评价","点评","逻辑"]},{"location":"Python/02 dzdianpingSpider/#_1","text":"","text_tokens":[],"title":"大众点评评价爬取逻辑","title_tokens":["大众","爬取","评价","点评","逻辑"]},{"location":"Python/02 dzdianpingSpider/#_2","text":"如图，评价中的 孩 字在源码中时被 <svgmtsi class=\"cfd1i\"></svgmtsi> 标签加密了。 在css中可以看到该svg图片地址为 background-image: url(//s3plus.meituan.net/v1/mss_0a06a471f9514fc79c981b5466f56b91/svgtextcss/2ec02e25ea201ca1b6b415747003614e.svg); 进入该地址发现是字体文件 加密字体的css中有 background: -0.0px -1808.0px; ，通过搜索可知 x / font-size（svg文件中①） + 1 可以得到该字体在svg中的第几个；比较y坐标和②的比较，其中，取 y<N 中的N值 孩 字 background: -0.0px -1808.0px; 对照可知：x=1，y<1831的path id=47","text_tokens":["_","比较","可以","=","得到","y","size","(","几个","id","47","cfd1i","net","，","了","url","class","如图","1","该","中时","标签","和","x","中",".","字","字体","n","-","<","0a06a471f9514fc79c981b5466f56b91","①","background","2ec02e25ea201ca1b6b415747003614e","svgtextcss","path","文件","是","0.0","坐标","。","可知","+","/","被","v1","进入","s3plus","（",";","\"","地址","为","第几个"," ","加密","px","通过","对照","在","css","第几","值","其中","1831","；","font","评价","看到","源码","搜索","1808.0","mss","的","取","发现","image","svg","中有","）","meituan","孩","：",")","②","图片",":",">","svgmtsi"],"title":"分析","title_tokens":["分析"]},{"location":"Python/02 dzdianpingSpider/#ref","text":"大众点评评论抓取-加密评论信息完整抓取","text_tokens":["大众","加密","点评","信息","抓取","评论","完整","-"],"title":"REF：","title_tokens":["：","ref"]}]}