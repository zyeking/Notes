{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Mysite","text_tokens":["welcome"," ","mysite","to"],"title":"index","title_tokens":["index"]},{"location":"#welcome-to-mysite","text":"","text_tokens":[],"title":"Welcome to Mysite","title_tokens":["welcome"," ","mysite","to"]},{"location":"Docker/01 ChangeImageSource/","text":"Docker 01：修改镜像源 在 settings -> Daemon -> Advanced 在 registry-mirrors 括号内添加 \"https://registry.docker-cn.com\" docker info 查询 registry-mirrors","text_tokens":["\"",".","https"," ",":","docker","mirrors",">","settings","括号","查询","镜像","添加","：","内","com","cn","daemon","01","info","/","源","registry","修改","在","advanced","-"],"title":"Docker 01：修改镜像源","title_tokens":["源"," ","docker","镜像","01","修改","："]},{"location":"Docker/01 ChangeImageSource/#docker-01","text":"在 settings -> Daemon -> Advanced 在 registry-mirrors 括号内添加 \"https://registry.docker-cn.com\" docker info 查询 registry-mirrors","text_tokens":["\"","."," ",":","docker","mirrors",">","settings","括号","advanced","查询","添加","内","com","cn","daemon","info","/","registry","在","https","-"],"title":"Docker 01：修改镜像源","title_tokens":["源"," ","docker","镜像","01","修改","："]},{"location":"Docker/02 EntryPointAndCMD/","text":"Docker 02：Dockerfile中的ENTRYPOINT、RUN与CMD CMD与ENRTYPOINT RUN CMD 每个 Dockerfile 中只能有一个 CMD , 如果有多个那么只会执行最后一个. CMD 相当于启动 docker 时候后面添加的参数: docker run -itd --name aaa docker_image /bin/bash -c. 镜像名称后面跟了 /bin/bash -c 等价于在dockerfile中的 CMD [\"/bin/bash\", \"-c\"] 若执行的时候添加了参数,默认的 CMD 中的参数则无效 ENTRYPOINT 类似 CMD , 每个 Dockerfile 只能有一个 ENTRYPOINT , 如果存在多个只执行最后一个. 必定执行, 不会动态改变 书写格式 Shell格式： , 例如: apt-get install python3 Exec [\"executable\", \"param1\", \"param2\", ...], 例如: [\"apt-get\", \"install\", \"python3\"] CMD命令 CMD echo \"hello world\" 1. 运行 docker run -it [image] , 输出hello world 2. 运行 docker run -it [image]/bin/bash , CMD 命令会被忽略, 命令 bash 会被执行 ENTRYPOINT ENTRYPOINT [\"/bin/echo\", \"Hello\"] 1. 运行 docker run -it [image] , 输出Hello 2. 运行 docker run -it [image] kk , 输出Hello kk, 原本的Hello仍然会输出 修改 Dockerfile 为 ENTRYPOINT [ \"/bin/echo\" , \"Hello\" ] CMD [ \"world\" ] 运行 docker run -it [name] , 输出Hello world 运行 docker run -it [name] king , 输出Hello king, CMD 参数被动态替换. RUN命令 RUN apt-get update && apt-get install -y \\ bzr \\ cvs \\ git \\ mercurial \\ subversion apt-get update 和 apt-get install 放在同一个 RUN 指令执行可以==保证每次安装的都是最新的包==; 如果将 apt-get install 放在单独的的 RUN 中执行, 则会使用 apt-get update 创建的镜像层, 这层镜像可能是很久以前缓存的. 总结 CMD 设置容器启动后==默认执行的命令以及参数==, 设置的指令可以被 docker run 命令后面的命令函参数==动态替换== ENTRYPOINT 配置容器启动时的执行命令, 不会被忽略, 一定会被执行 , 即使运行了 docker run 时指定了其他命令 使用 RUN 指令安装应用和软件包，构建镜像。 如果 Docker 镜像的用途是运行应用程序或服务, 比如运行一个 MySQL, 应该优先使用 Exec 格式的 ENTRYPOINT 指令. CMD 可为 ENTRYPOINT 提供额外的默认参数, 同时可利用 docker run 命令行替换默认参数. 如果想为容器设置默认的启动命令,可使用 CMD 指令.用户可在 docker run 命令行中替换此默认命令. REF: Dockerfile RUN，CMD，ENTRYPOINT命令区别 Dockerfile中ENTRYPOINT 和 CMD的区别","text_tokens":["param1","\"","设置","mercurial","docker","或","可","param2","有","如果","aaa","必定","exec","最新","容器","想","额外","其他","软件","镜像","应用","优先","添加","以及","c","king","缓存","于","、","可能","命令行",",","install","mysql","类似","cvs","后","无效","修改","同一个","等价","-"," ",":","都","shell","时候","指令","y","使用","以前","...","默认","动态","忽略","中","名称","执行命令","cmd","相当","书写","\\","会","包","的",";","[","dockerfile","get","提供","name","bzr","多个","只","和","利用","格式","用户","echo","则","当于","很久","每次","时","每个","执行","python3","服务","=","bash","entrypoint","相当于","world","同一",".","1","subversion","不会","创建","只会","]","02","例如","构建","用途","了","替换","此","run","区别","update","被","hello","原本","，","一个","只能","git","executable","与","后面","配置","：","那么","最后","参数","一定","跟","将","是","/","安装","可以","指定","函","&&","启动","比如","在","这层","为","bin","image","层","2","存在","命令","输出","保证","kk","apt","同时","即使","若","。","单独","应该","放在","运行","enrtypoint","it","_","ref","软件包","应用程序","改变","程序","仍然","很久以前","itd","总结"],"title":"Docker 02：Dockerfile中的ENTRYPOINT、RUN与CMD","title_tokens":["的","run","、","dockerfile"," ","entrypoint","中","docker","cmd","与","02","："]},{"location":"Docker/02 EntryPointAndCMD/#docker-02dockerfileentrypointruncmd","text":"","text_tokens":[],"title":"Docker 02：Dockerfile中的ENTRYPOINT、RUN与CMD","title_tokens":["的","run","、","dockerfile"," ","entrypoint","中","docker","cmd","与","02","："]},{"location":"Docker/02 EntryPointAndCMD/#cmdenrtypoint","text":"RUN CMD 每个 Dockerfile 中只能有一个 CMD , 如果有多个那么只会执行最后一个. CMD 相当于启动 docker 时候后面添加的参数: docker run -itd --name aaa docker_image /bin/bash -c. 镜像名称后面跟了 /bin/bash -c 等价于在dockerfile中的 CMD [\"/bin/bash\", \"-c\"] 若执行的时候添加了参数,默认的 CMD 中的参数则无效 ENTRYPOINT 类似 CMD , 每个 Dockerfile 只能有一个 ENTRYPOINT , 如果存在多个只执行最后一个. 必定执行, 不会动态改变","text_tokens":["bin","image","\"","."," ",":","entrypoint","docker","存在","在","有","如果","只会","]","不会","aaa","时候","必定","了","run","默认","动态","一个","中","名称","若","只能","镜像","cmd","后面","相当","添加","那么","的","c","_","于","[","dockerfile","最后","参数","name","多个","跟","只",",","改变","/","类似","则","当于","每个","无效","itd","执行","启动","等价","bash","相当于","-"],"title":"CMD与ENRTYPOINT","title_tokens":["cmd","与","enrtypoint"]},{"location":"Docker/02 EntryPointAndCMD/#_1","text":"Shell格式： , 例如: apt-get install python3 Exec [\"executable\", \"param1\", \"param2\", ...], 例如: [\"apt-get\", \"install\", \"python3\"]","text_tokens":["param1","\""," ",":","shell","param2","]","例如","apt","exec","...","executable","：","[","get",",","install","格式","python3","-"],"title":"书写格式","title_tokens":["书写","格式"]},{"location":"Docker/02 EntryPointAndCMD/#cmd","text":"CMD echo \"hello world\" 1. 运行 docker run -it [image] , 输出hello world 2. 运行 docker run -it [image]/bin/bash , CMD 命令会被忽略, 命令 bash 会被执行","text_tokens":["bin","\"","image","world","1","."," ","2","docker","命令","输出","]","run","被","hello","忽略","cmd","运行","会","it","[",",","/","echo","执行","bash","-"],"title":"CMD命令","title_tokens":["cmd","命令"]},{"location":"Docker/02 EntryPointAndCMD/#entrypoint","text":"ENTRYPOINT [\"/bin/echo\", \"Hello\"] 1. 运行 docker run -it [image] , 输出Hello 2. 运行 docker run -it [image] kk , 输出Hello kk, 原本的Hello仍然会输出 修改 Dockerfile 为 ENTRYPOINT [ \"/bin/echo\" , \"Hello\" ] CMD [ \"world\" ] 运行 docker run -it [name] , 输出Hello world 运行 docker run -it [name] king , 输出Hello king, CMD 参数被动态替换.","text_tokens":["bin","\"","image","world","1","."," ","2","docker","]","输出","kk","替换","run","被","hello","原本","动态","cmd","运行","会","it","的","king","[","dockerfile","参数","name",",","/","仍然","echo","修改","entrypoint","-","为"],"title":"ENTRYPOINT","title_tokens":["entrypoint"]},{"location":"Docker/02 EntryPointAndCMD/#run","text":"RUN apt-get update && apt-get install -y \\ bzr \\ cvs \\ git \\ mercurial \\ subversion apt-get update 和 apt-get install 放在同一个 RUN 指令执行可以==保证每次安装的都是最新的包==; 如果将 apt-get install 放在单独的的 RUN 中执行, 则会使用 apt-get update 创建的镜像层, 这层镜像可能是很久以前缓存的.","text_tokens":["层","mercurial","同一","."," ","都","subversion","创建","如果","保证","apt","y","指令","使用","run","以前","update","最新","一个","中","git","单独","镜像","放在","\\","会","包","的",";","缓存","get","可能","bzr","和","将",",","install","是","安装","cvs","可以","则","很久以前","很久","每次","&&","执行","同一个","=","这层","-"],"title":"RUN命令","title_tokens":["run","命令"]},{"location":"Docker/02 EntryPointAndCMD/#_2","text":"CMD 设置容器启动后==默认执行的命令以及参数==, 设置的指令可以被 docker run 命令后面的命令函参数==动态替换== ENTRYPOINT 配置容器启动时的执行命令, 不会被忽略, 一定会被执行 , 即使运行了 docker run 时指定了其他命令 使用 RUN 指令安装应用和软件包，构建镜像。 如果 Docker 镜像的用途是运行应用程序或服务, 比如运行一个 MySQL, 应该优先使用 Exec 格式的 ENTRYPOINT 指令. CMD 可为 ENTRYPOINT 提供额外的默认参数, 同时可利用 docker run 命令行替换默认参数. 如果想为容器设置默认的启动命令,可使用 CMD 指令.用户可在 docker run 命令行中替换此默认命令.","text_tokens":["设置","."," ","想","docker","或","可","命令","不会","如果","构建","用途","中","指令","替换","了","即使","run","使用","exec","被","默认","同时","容器","动态","忽略","，","一个","其他","执行命令","额外","软件","。","镜像","cmd","应用","应该","后面","配置","优先","运行","此","会","以及","的","参数","一定","提供","命令行","和","软件包","应用程序","利用",",","mysql","程序","是","安装","格式","用户","可以","指定","后","函","时","启动","执行","比如","服务","在","=","entrypoint","为"],"title":"总结","title_tokens":["总结"]},{"location":"Docker/02 EntryPointAndCMD/#ref","text":"Dockerfile RUN，CMD，ENTRYPOINT命令区别 Dockerfile中ENTRYPOINT 和 CMD的区别","text_tokens":["的","run","区别","dockerfile","，"," ","中","cmd","命令","和","entrypoint"],"title":"REF:","title_tokens":["ref",":"]},{"location":"Golang/Basic/01 Channel/","text":"channel what is channel channel是goroutine和goroutine之间无锁交流的【媒介】，换句话说，channel是一种允许一个goroutine发送数据给另外一个goroutine的技术，默认的channel是双向的，意味着goroutines可以通过同一个channel发、收数据。 how syntax var Channel_name chan Type channel_name := make(chan Type) 在golang中, 我们用关键字 Channel_name chan Type 创建某种类型的channel，其中channel仅仅可以传递同种类型的数据，不同类型的数据不可以通过一个类型的channel传递。 Send and Receive Data From a Channel 在golang中，channel主要有两个操作，一个是 sending ，一个是 receiving ，这两种操作被称为通讯。 <- 箭头的方向表明是发送数据还是接受数据。在默认情况下，channel中的发送、接受操作块【直到另一端未就绪】 ，允许goroutine之间在没有显式锁或者条件变量的时候互相同步 发送操作：在channel的帮助下用来将goroutine的数据发送给另外一个goroutine，通过channel发送 float64 ， int ， bool 是安全切容易的，因为这些值会被 拷贝 一份，不会有意外并发的风险，同样的， strings 类型也是安全的，因为它是 immutable（不可更改） 。在发送 pointers 或者 slice ， map 等引用的时候，channel是不安全的，因为指针或者引用会被发送者或者接收者在同一时间修改，结果是不可预知的，因此需要==确保只有一个goroutine能够访问== Mychannel <- element 表明了数据（element）发送给了Mychannel 接受操作： element := <- Mychannel package main import \"fmt\" func main () { fmt . Println ( \"starting Main method\" ) ch := make ( chan int ) go myfunc ( ch ) ch <- 23 fmt . Println ( \"End Main method\" ) } func myfunc ( ch chan int ) { fmt . Println ( 234 + <- ch ) } Closing a Channel close() 这是一个内置函数，设了一个表示表明不会再有值发送给该channel。 ele, ok = <- Mychannel 通过循环，接受者会检查该channel是打开的还是关闭的，如果ok是真，则意味着该channel是打开的。 package main import \"fmt\" func main () { c := make ( chan string ) // 调用goroutine go myFunc ( c ) for { res , ok := <- c if ok == false { fmt . Println ( \"Channel Close\" , ok ) break } fmt . Println ( \"Channel Open\" , res , ok ) } } func myFunc ( mychnl chan string ) { for v := 0 ; v < 4 ; v ++ { mychnl <- \"GeeksforGeeks\" } close ( mychnl ) } Blocking Send and Receive 在channel中，当数据发送给一个channel，直到另外的goroutine读取这个channel前，发送的声明是被阻塞的（发送完后必须等待该信息被读取才能够继续发送）。同样的，当一个channel接受数据的时候在接收到数据前都是被阻塞的。 channel中的零值是 nil 。 for 循环可以迭代channel中所有连续的值，直到该channel。 package main import \"fmt\" func main () { mychnl := make ( chan string ) go func () { mychnl <- \"GFG\" mychnl <- \"ABC\" mychnl <- \"ASDJH\" mychnl <- \"asdjjak\" close ( mychnl ) }() for res := range mychnl { fmt . Println ( res ) } } Length of the Channel len() 表明在channel缓冲区中==值的数量== package main import \"fmt\" func main () { mychnl := make ( chan string , 4 ) mychnl <- \"GFG\" mychnl <- \"ABC\" mychnl <- \"ASDJH\" mychnl <- \"asdjjak\" fmt . Println ( \"Length of the channel is:\" , len ( mychnl )) } Capacity of the Channel cap() 表明channel缓冲区的大小 package main import \"fmt\" func main () { mychnl := make ( chan string , 8 ) mychnl <- \"GFG\" mychnl <- \"ABC\" mychnl <- \"ASDJH\" fmt . Println ( \"Capacity of the channel is:\" , cap ( mychnl )) }","text_tokens":["\"","我们","goroutine","发","大小","一份","strings","golang","用","map","有","如果","情况","go","意外","更改","表示","内置","不可","v","媒介","false","pointers","asdjh","数量","int","receiving","open","c","无锁","缓冲区","、","受者","用来","end","接受","值会","channel","var","】","type",")",",","能够","声明","阻塞","starting","4","意味","同样","引用","import","}","mychnl","修改","拷贝","同一个","of","设","-","等","直到","mychannel","）","所有","++"," ",":","结果","都","package","连续","fmt","（","时候","容易","并发","0","交流","关闭","锁","immutable","调用","默认","capacity","中","因为","(","两个","会","主要","这个","的","<","关键","myfunc","真",";","等待","换句话","同步","数据","切","for","len","name","技术","和","syntax","其中","仅仅","abc","则","bool","缓冲","预知","必须","称为","另一端","同一时","ok","=","ele","不","println","变量","一时间","确保","同一",".","再有","what","and","+","信息","main","意味着","表明","前","创建","不会","时间","读取","make","sending","了","发送","到","被","没有","接受者","geeksforgeeks","，","一个","string","the","双向","ch","：","互相","close","method","显式","另外","条件","换句话说","当","收","块","通过","一时","range","也","类型","需要","将","两种","if","完后","cap","是","/","接收","closing","可以","同一时间","循环","how","receive","这","才","方向","帮助","零值","箭头","在","通讯","is","检查","传递","发送者","换句","不同","234","【","值","未","函数","操作","指针","只有","该","发送数据","发送给","length","a","同种","一端","风险","因此","chan","送给","slice","允许","。","send","element","这些","接收者","迭代","_","23","访问","res","打开","{","gfg","关键字","asdjjak","goroutines","就绪","break","from","之间","float64","func","下","继续","nil","某种","给","data","它","这是","安全","blocking","8","一种","还是","或者"],"title":"channel","title_tokens":["channel"]},{"location":"Golang/Basic/01 Channel/#channel","text":"","text_tokens":[],"title":"channel","title_tokens":["channel"]},{"location":"Golang/Basic/01 Channel/#what-is-channel","text":"channel是goroutine和goroutine之间无锁交流的【媒介】，换句话说，channel是一种允许一个goroutine发送数据给另外一个goroutine的技术，默认的channel是双向的，意味着goroutines可以通过同一个channel发、收数据。","text_tokens":["goroutine","【","发","同一","意味着","发送数据","交流","发送","默认","媒介","，","一个","允许","。","双向","的","无锁","另外","换句话说","收","、","换句话","通过","数据","goroutines","技术","和","channel","】","之间","是","可以","意味","给","一种","同一个","换句"],"title":"what is channel","title_tokens":["is","channel"," ","what"]},{"location":"Golang/Basic/01 Channel/#how","text":"syntax var Channel_name chan Type channel_name := make(chan Type) 在golang中, 我们用关键字 Channel_name chan Type 创建某种类型的channel，其中channel仅仅可以传递同种类型的数据，不同类型的数据不可以通过一个类型的channel传递。","text_tokens":["不同","我们"," ",":","golang","用","创建","make","同种","，","一个","chan","中","。","(","的","关键","_","通过","数据","类型","name","关键字","syntax","type",",",")","channel","var","其中","仅仅","可以","不","某种","在","=","传递"],"title":"how","title_tokens":["how"]},{"location":"Golang/Basic/01 Channel/#send-and-receive-data-from-a-channel","text":"在golang中，channel主要有两个操作，一个是 sending ，一个是 receiving ，这两种操作被称为通讯。 <- 箭头的方向表明是发送数据还是接受数据。在默认情况下，channel中的发送、接受操作块【直到另一端未就绪】 ，允许goroutine之间在没有显式锁或者条件变量的时候互相同步 发送操作：在channel的帮助下用来将goroutine的数据发送给另外一个goroutine，通过channel发送 float64 ， int ， bool 是安全切容易的，因为这些值会被 拷贝 一份，不会有意外并发的风险，同样的， strings 类型也是安全的，因为它是 immutable（不可更改） 。在发送 pointers 或者 slice ， map 等引用的时候，channel是不安全的，因为指针或者引用会被发送者或者接收者在同一时间修改，结果是不可预知的，因此需要==确保只有一个goroutine能够访问== Mychannel <- element 表明了数据（element）发送给了Mychannel 接受操作： element := <- Mychannel package main import \"fmt\" func main () { fmt . Println ( \"starting Main method\" ) ch := make ( chan int ) go myfunc ( ch ) ch <- 23 fmt . Println ( \"End Main method\" ) } func myfunc ( ch chan int ) { fmt . Println ( 234 + <- ch ) }","text_tokens":["\"","goroutine","一份","strings","golang","map","有","情况","go","意外","更改","不可","pointers","int","receiving","、","用来","end","接受","值会","channel",")","】","能够","starting","同样","引用","import","}","修改","拷贝","-","等","直到","mychannel","）"," ",":","结果","package","fmt","（","时候","容易","并发","锁","immutable","默认","中","因为","(","两个","会","主要","的","<","myfunc","同步","数据","切","bool","预知","称为","另一端","同一时","=","不","println","变量","一时间","确保","同一",".","+","main","表明","不会","时间","make","sending","了","发送","被","没有","，","一个","ch","：","互相","method","显式","另外","条件","块","通过","一时","也","类型","需要","将","两种","是","接收","同一时间","这","方向","帮助","箭头","在","通讯","发送者","234","【","未","操作","指针","只有","发送数据","发送给","一端","风险","因此","送给","element","slice","。","允许","chan","这些","接收者","23","访问","{","就绪","之间","float64","func","下","它","安全","还是","或者"],"title":"Send and Receive Data From a Channel","title_tokens":["channel","receive"," ","and","a","data","send","from"]},{"location":"Golang/Basic/01 Channel/#closing-a-channel","text":"close() 这是一个内置函数，设了一个表示表明不会再有值发送给该channel。 ele, ok = <- Mychannel 通过循环，接受者会检查该channel是打开的还是关闭的，如果ok是真，则意味着该channel是打开的。 package main import \"fmt\" func main () { c := make ( chan string ) // 调用goroutine go myFunc ( c ) for { res , ok := <- c if ok == false { fmt . Println ( \"Channel Close\" , ok ) break } fmt . Println ( \"Channel Open\" , res , ok ) } } func myFunc ( mychnl chan string ) { for v := 0 ; v < 4 ; v ++ { mychnl <- \"GeeksforGeeks\" } close ( mychnl ) }","text_tokens":["\"","goroutine","如果","go","表示","内置","v","false","open","c","受者","接受",")","channel",",","4","意味","import","}","mychnl","设","-","mychannel","++"," ",":","package","fmt","0","关闭","调用","(","会","的","<","myfunc",";","真","for","则","ok","=","ele","println","再有",".","main","表明","意味着","不会","make","了","发送","geeksforgeeks","接受者","，","一个","string","close","通过","if","是","/","循环","检查","值","函数","该","发送给","送给","chan","。","res","打开","{","break","func","这是","还是"],"title":"Closing a Channel","title_tokens":["channel","a","closing"," "]},{"location":"Golang/Basic/01 Channel/#blocking-send-and-receive","text":"在channel中，当数据发送给一个channel，直到另外的goroutine读取这个channel前，发送的声明是被阻塞的（发送完后必须等待该信息被读取才能够继续发送）。同样的，当一个channel接受数据的时候在接收到数据前都是被阻塞的。 channel中的零值是 nil 。 for 循环可以迭代channel中所有连续的值，直到该channel。 package main import \"fmt\" func main () { mychnl := make ( chan string ) go func () { mychnl <- \"GFG\" mychnl <- \"ABC\" mychnl <- \"ASDJH\" mychnl <- \"asdjjak\" close ( mychnl ) }() for res := range mychnl { fmt . Println ( res ) } }","text_tokens":["println","\"","goroutine","）","所有","值",".","都"," ",":","信息","main","连续","前","该","package","发送给","读取","（","fmt","时候","make","go","发送","到","被","，","一个","string","中","送给","chan","。","asdjh","(","这个","close","另外","的","迭代","<","当","等待","res","range","for","数据","{","gfg","asdjjak","接受","channel","阻塞","完后","声明","能够","是",")","接收","循环","可以","abc","func","继续","才","nil","同样","必须","import","mychnl","}","零值","在","=","-","直到"],"title":"Blocking Send and Receive","title_tokens":["receive"," ","and","blocking","send"]},{"location":"Golang/Basic/01 Channel/#length-of-the-channel","text":"len() 表明在channel缓冲区中==值的数量== package main import \"fmt\" func main () { mychnl := make ( chan string , 4 ) mychnl <- \"GFG\" mychnl <- \"ABC\" mychnl <- \"ASDJH\" mychnl <- \"asdjjak\" fmt . Println ( \"Length of the channel is:\" , len ( mychnl )) }","text_tokens":["println","\"","值","."," ",":","main","package","表明","fmt","length","make","数量","string","中","chan","asdjh","the","(","的","<","缓冲区","len","{","gfg","asdjjak","channel",")",",","abc","func","缓冲","4","import","mychnl","}","of","在","=","is","-"],"title":"Length of the Channel","title_tokens":[" ","the","of","length","channel"]},{"location":"Golang/Basic/01 Channel/#capacity-of-the-channel","text":"cap() 表明channel缓冲区的大小 package main import \"fmt\" func main () { mychnl := make ( chan string , 8 ) mychnl <- \"GFG\" mychnl <- \"ABC\" mychnl <- \"ASDJH\" fmt . Println ( \"Capacity of the channel is:\" , cap ( mychnl )) }","text_tokens":["println","\"",".","大小"," ",":","main","package","表明","fmt","make","capacity","string","chan","asdjh","the","(","的","<","缓冲区","{","gfg","channel",")","cap",",","abc","func","缓冲","8","import","mychnl","}","of","=","is","-"],"title":"Capacity of the Channel","title_tokens":[" ","capacity","the","of","channel"]},{"location":"Golang/Basic/02 UseDelveDebug/","text":"使用delve调试Golang 安装 vscode中, 通过 ctrl+shift+p 运行 Go: Install/Update Tools ,选择 dlv 安装 go get -u github.com/go-delve/delve/cmd/dlv 使用 vscode 在vscode中按F5, 弹出 launch.json 文件, 配置 { // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 \"version\" : \"0.2.0\" , \"configurations\" : [ { \"name\" : \"Launch\" , \"type\" : \"go\" , \"request\" : \"launch\" , \"mode\" : \"debug\" , // auto \"program\" : \"${fileDirname}\" , \"env\" : { \"GOPATH\" : \"d:/workspace/go space/go\" }, \"args\" : [] } ] } 命令行debug package main import ( \"net/http\" \"github.com/gin-gonic/gin\" ) func HelloHandler ( c * gin . Context ) { firstname := c . DefaultQuery ( \"firstname\" , \"Guest\" ) lastname := c . Query ( \"lastname\" ) c . String ( http . StatusOK , \"Hello %s %s\" , firstname , lastname ) } func main () { router := gin . Default () router . GET ( \"/welcome\" , HelloHandler ) router . Run ( \":8000\" ) } 进入要debug的文件目录 cd ../main.go $ dlv debug main.go // debug $ b HelloHandler // break point $ c // continue $ n // next $ s // step in $ p value // print value $ stepout // step out function","text_tokens":["\"","golang","shift","选择","dlv","linkid","welcome","go","step","configurations","*","in","env","p","要","guest","c","stepout","830387","router","$","cd","d","workspace","命令行","http",",","type","install",")","continue","ctrl","进入","hellohandler","}","import","out","lastname","of","-","function"," ",":","information","package","auto","json","0","使用","args","print","launch","vscode","request","中","space","cmd","intellisense","net","default","目录","(","program","github","gonic","的","point","n","hover","[","get","for","弹","name","firstname","f5","mode","?","learn","about","=","%","existing","调试",".","+","to","context","8000","main","文件目录","]","statusok","tools","run","update","view","hello","出","gopath","string","attributes","配置","filedirname","u","descriptions","通过","possible","..","安装","/","debug","s","microsoft","在","https","defaultquery","visit","next","query","use","fwlink","命令","value","more","gin","运行","com","version","{","break","0.2","delve","文件","func","按","b"],"title":"使用delve调试Golang","title_tokens":["delve","调试","golang","使用"]},{"location":"Golang/Basic/02 UseDelveDebug/#delvegolang","text":"","text_tokens":[],"title":"使用delve调试Golang","title_tokens":["delve","调试","golang","使用"]},{"location":"Golang/Basic/02 UseDelveDebug/#_1","text":"vscode中, 通过 ctrl+shift+p 运行 Go: Install/Update Tools ,选择 dlv 安装 go get -u github.com/go-delve/delve/cmd/dlv","text_tokens":["."," ",":","+","选择","shift","dlv","go","tools","update","vscode","中","cmd","p","u","运行","github","com","通过","get",",","install","/","安装","delve","ctrl","-"],"title":"安装","title_tokens":["安装"]},{"location":"Golang/Basic/02 UseDelveDebug/#_2","text":"","text_tokens":[],"title":"使用","title_tokens":["使用"]},{"location":"Golang/Basic/02 UseDelveDebug/#vscode","text":"在vscode中按F5, 弹出 launch.json 文件, 配置 { // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 \"version\" : \"0.2.0\" , \"configurations\" : [ { \"name\" : \"Launch\" , \"type\" : \"go\" , \"request\" : \"launch\" , \"mode\" : \"debug\" , // auto \"program\" : \"${fileDirname}\" , \"env\" : { \"GOPATH\" : \"d:/workspace/go space/go\" }, \"args\" : [] } ] }","text_tokens":["\"","visit","existing","."," ","information",":","to","use","fwlink","auto","linkid","]","go","json","0","configurations","args","launch","view","vscode","出","request","gopath","中","attributes","more","intellisense","env","space","配置","filedirname","descriptions","program","com","830387","hover","[","$","for","version","{","d","弹","name","possible","workspace","=","f5",",","type","0.2","/","文件","mode","按","?","learn","debug","}","about","microsoft","of","在","https"],"title":"vscode","title_tokens":["vscode"]},{"location":"Golang/Basic/02 UseDelveDebug/#debug","text":"package main import ( \"net/http\" \"github.com/gin-gonic/gin\" ) func HelloHandler ( c * gin . Context ) { firstname := c . DefaultQuery ( \"firstname\" , \"Guest\" ) lastname := c . Query ( \"lastname\" ) c . String ( http . StatusOK , \"Hello %s %s\" , firstname , lastname ) } func main () { router := gin . Default () router . GET ( \"/welcome\" , HelloHandler ) router . Run ( \":8000\" ) } 进入要debug的文件目录 cd ../main.go $ dlv debug main.go // debug $ b HelloHandler // break point $ c // continue $ n // next $ s // step in $ p value // print value $ stepout // step out function","text_tokens":["function","\"","%","next","query","."," ",":","8000","context","main","package","文件目录","dlv","welcome","go","statusok","step","print","run","*","hello","value","string","in","net","default","目录","p","(","gin","github","gonic","c","guest","要","的","com","point","router","$","n","get","stepout","cd","{","firstname","http","..","break",")",",","/","文件","continue","func","进入","hellohandler","import","}","debug","out","lastname","s","defaultquery","=","-","b"],"title":"命令行debug","title_tokens":["debug","命令","命令行"]},{"location":"Golang/ErrorCollect/20191127：Cannot fint main module[gomod]/","text":"20191127：Cannot fint the main module[gomod] 环境 在尝试vscode的debug中输出了 go: cannot find main module; see 'go help modules' 原因 & 解决 根目录下没有 go.mod 文件, 需要 go mod init 初始化建立相关 .mod 文件;或者将环境变量中的 GO111MODULE=AUTO/OFF","text_tokens":["cannot","变量","&","fint",".","解决"," ",":","根目录","20191127","main","auto","输出","]","go","环境变","环境变量","gomod","了","没有","vscode","环境","the","中","init","目录","尝试","：","'","help","modules","的",";","相关","建立","[","需要","初始","将","初始化",",","see","module","find","/","文件","下","off","原因","debug","mod","go111module","在","=","或者"],"title":"20191127：Cannot fint the main module[gomod]","title_tokens":["cannot","fint","["," ","the","20191127","main","]","：","gomod","module"]},{"location":"Golang/ErrorCollect/20191127：Cannot fint main module[gomod]/#20191127cannot-fint-the-main-modulegomod","text":"","text_tokens":[],"title":"20191127：Cannot fint the main module[gomod]","title_tokens":["cannot","fint","["," ","the","20191127","main","]","：","gomod","module"]},{"location":"Golang/ErrorCollect/20191127：Cannot fint main module[gomod]/#_1","text":"在尝试vscode的debug中输出了 go: cannot find main module; see 'go help modules'","text_tokens":["cannot"," ",":","main","输出","go","了","vscode","中","尝试","help","'","modules","的",";","see","module","find","debug","在"],"title":"环境","title_tokens":["环境"]},{"location":"Golang/ErrorCollect/20191127：Cannot fint main module[gomod]/#_2","text":"根目录下没有 go.mod 文件, 需要 go mod init 初始化建立相关 .mod 文件;或者将环境变量中的 GO111MODULE=AUTO/OFF","text_tokens":["变量","."," ","根目录","auto","环境变量","go","环境变","没有","环境","init","中","目录","的","相关",";","建立","需要","初始","将","初始化",",","/","文件","下","off","mod","go111module","=","或者"],"title":"原因 &amp; 解决","title_tokens":[";","&","解决"," ","原因","amp"]},{"location":"Golang/Go-Web/01 HTTPServe/","text":"01：建立HTTP服务器的多种方法 建立服务器 package mian import ( \"log\" \"net/http\" ) func main () { http . HadnleFunc ( \"/\" , func ( w http . ResponseWriter , r * http . Request ) { w . Write ([] byte ( \"hello world\" ) } log . Println ( \"starting HTTP server..\" ) log . Fatal ( http . ListenAndServe ( \":8000\" , nil )) } http.HandleFunc(pattern string, handler func(ResponseWriter, *Request) 根据一个==路由规则==绑定一个执行函数, 当用户访问到指定路由时执行. http.HandleFunc 的第二个参数必须符合函数签名 func(http.ResponseWriter, *http.Request) , 第一个参数是请求所对应的响应对象 http.ResponseWriter ,包含响应码、响应头和响应体, 在这里通过调用 响应对象 的 Write 方法像响应体写入字符串. 第二个参数是请求所对应的请求对象 *http.Request ,包含请求头、请求体等. http.ListenAndServe 启动HTTP服务器,监听 指定地址 和 端口号 的HTTP请求 http.HandleFunc 将传入的 绑定函数 转换为类型 http.HandleFunc (一个HTTP请求处理器对象),该对象类型实现 http.Handler 接口,接口方法调用自己 // net / http / server . go // The HandlerFunc type is an adapter to allow the use of // ordinary functions as HTTP handlers . If f is a function // with the appropriate signature , HandlerFunc ( f ) is a // Handler that calls f . type HandlerFunc func ( ResponseWriter , * Request ) // ServeHTTP calls f ( w , r ) . func ( f HandlerFunc ) ServeHTTP ( w ResponseWriter , r * Request ) { f ( w , r ) } 自定义Handler package main import ( \"log\" \"net/http\" ) type customHandler {} // 将ServeHTTP方法绑定到customHandler上 func ( _ * customHandler ) ServeHTTP ( w http . ResponseWriter , r * http . Request ){ w . Write ([] byte ( \"hello custom Handler\" ) } func main () { http . Handle ( \"/\" , & cutsomerHandler {}) log . Println ( \"starting HTTP server...\" ) log . Fatl ( http . ListenAndServe ( \":8000\" , nil )) } 自定义类型 type customHandler{} 类型绑定 ServerHTTP(w http.ResponseWriter, r *http.Request) 方法 http.Handle 调用, 通过 &customHandler{} 传入该自定义类型的地址 少了将绑定函数转换为 type HandleFunc 的步骤 服务复用器(ServeMux) // ListenAndServe listens on the TCP network address addr and then calls // Serve with handler to handle requests on incoming connections. // Accepted connections are configured to enable TCP keep-alives. // // The handler is typically nil, in which case the DefaultServeMux is used. // // ListenAndServe always returns a non-nil error. func ListenAndServe ( addr string , handler Handler ) error { server := & Server { Addr : addr , Handler : handler } return server . ListenAndServe () } //*****************************// type Handler interface { ServeHTTP ( ResponseWriter , * Request ) } 实例中 http.ListenAndServe 的nil替代了实现了 http.Handler 接口的对象 http.Handler 实现 ServeHTTP 接口 缺陷 该方法不能像之前调用的 http.HandleFunc 和 http.Handle 为不同路由规则绑定不同的函数处理 package main import ( \"log\" \"net/http\" ) type customHandler struct {} func ( _ * customHandler ) ServeHTTP ( w http . ResponseWriter , r * http . Request ) { w . Write ([] byte ( \"hello custom server mux's ServeHTTP\" )) } func main () { log . Println ( \"starting HTTP server... \" ) log . Fatal ( http . ListenAndServe ( \":8000\" , & customHandler {})) } 自定义Serve Mux // HandleFunc registers the handler function for the given pattern // in the DefaultServeMux. // The documentation for ServeMux explains how patterns are matched. func HandleFunc ( pattern string , handler func ( ResponseWriter , * Request )) { DefaultServeMux . HandleFunc ( pattern , handler ) } //*****************************// // DefaultServeMux is the default ServeMux used by Serve. var DefaultServeMux = & defaultServeMux var defaultServeMux ServeMux //*****************************// type ServeMux struct { mu sync . RWMutex m map [ string ] muxEntry es [] muxEntry // slice of entries sorted from longest to shortest. hosts bool // whether any patterns contain hostnames } handle.Handle 调用 DefaultServeMux ,该 DefaultMux 是 http.ServeMux 的封装 http.ServeMux 带有基本路由功能的服务复用器(Serve Multiplexer) 通过 http.NewServeMux 操作 http.ServeMux 对象, 调用 http.NewServeMux 的 .Handle 方法 package main import ( \"log\" \"net/http\" ) type customHandler struct {} func ( _ * customHandler ) ServeHTTP ( w http . ResponseWriter , r * http . Request ) { w . Write ([] byte ( \"hello new custom server mux\" )) } func main () { mux := http . NewServeMux () mux . Handle ( \"/\" , & customHandler {}) log . Println ( \"starting HTTP serve...\" ) log . Fatal ( http . ListenAndServe ( \":8000\" , mux )) } 服务器对象(Server) func ListenAndServe ( addr string , handler Handler ) error { server := & Server { Addr : addr , Handler : handler } return server . ListenAndServe () } //***************************// type Server struct { Addr string Handler Handler ... } 自定义server1 调用 http.ListenAndServe 的时候创建了另一个 http.Serve 对象 package main import ( \"log\" \"net/http\" ) type customHandler struct {} func ( _ * customHandler ) ServeHTTP ( w http . ResponseWriter , r * http . Request ) { w . Write ([] byte ( \"hello custom server mux\" )) } func main () { mux := http . NewServeMux () mux . Handle ( \"/\" , & customHandler {}) serve := & http . Server { Addr : \":8000\" , Handler : mux , } log . Println ( \"starting HTTP serve...\" ) log . Fatal ( serve . ListenAndServe ()) } 自定义server2 // custome server 2 package main import ( \"log\" \"net/http\" \"time\" ) type customHandler struct {} func ( _ * customHandler ) ServeHTTP ( w http . ResponseWriter , r * http . Request ) { w . Write ([] byte ( \"hello custom server mux2\" )) } func main () { mux := http . NewServeMux () mux . Handle ( \"/\" , & customHandler {}) mux . HandleFunc ( \"/timeout\" , func ( w http . ResponseWriter , r * http . Request ) { // 超时 time . Sleep ( 2 * time . Second ) w . Write ([] byte ( \"Timeout\" )) }) server := & http . Server { Addr : \":8000\" , Handler : mux , WriteTimeout : 2 * time . Second , } log . Println ( \"starting HTTP server...\" ) log . Fatal ( server . ListenAndServe ()) } 无法访问到 localhost:8000/timeout 执行函数休眠2秒, 被 http.Serve 对象认为已经超时,提前关闭与客户端之间的连接, 后面无法像响应体写入任何信息 优雅地停止服务 通过捕捉系统信号(Signal)、goroutine和通道(Channel)实现 捕捉 os.Interrupt 信号(ctrl+c)然后调用 server.Shutdown 方法g告知服务器停止接受新请求 http.ErrServerClosed 根据该错误类型判断服务器是否正常关闭 package main import ( \"context\" \"log\" \"net/http\" \"os\" \"os/signal\" ) type customHandler struct {} func ( _ * customHandler ) ServeHTTP ( w http . ResponseWriter , r * http . Request ) { w . Write ([] byte ( \"hello custom server mux2\" )) } func main () { mux := http . NewServeMux () mux . Handle ( \"/\" , & customHandler {}) server := & http . Server { Addr : \":8000\" , Handler : mux , } // 创建系统信号接收器 quit := make ( chan os . Signal ) signal . Notify ( quit , os . Interrupt ) go func () { <- quit if err := server . Shutdown ( context . Background ()); err != nil { log . Fatal ( \"Shutdown server:\" , err ) } }() log . Println ( \"start HTTP server...\" ) err := server . ListenAndServe () if err != nil { if err == http . ErrServerClosed { log . Print ( \"Server Closed under request\" ) } else { log . Fatal ( \"Server closed unexpected\" ) } } }","text_tokens":["mu","custome","对象","转换","*","判断","符合","return","处理","理器","notify","接口","接受",",","type","channel","写入","字符串","starting","server1","appropriate","口号","function"," ","!","print","...","码","serve","default","functions","(","background",";","registers","封装","签名","01","用户","interrupt","错误","捕捉","根据","case","main","server","地","了","mian","体等","：","端口","建立","当","复用器","通过","监听","新","allow","..","将","认为","if","自定义","f","/","how","启动","is","第二个","alives","第二","是否","by","then","chan","slice","writetimeout","write","byte","接收器","non","请求","from","复用","nil","体","像","else","r","used","hostnames","&","无法","正常","服务器","in","timeout","实现",")","包含","adapter","}","-","功能","提前","时候","request","documentation","shutdown","客户","g","优雅","定义","绑定","实例","服务","given","另",".","路由","到","与","后面","上","second","指定","hadnlefunc","quit","为","不同","2","函数","操作","addr","use","该","requests","interface","信号","系统","已经","{","连接","defaultmux","步骤","fatal","goroutine","多种","servehttp","go","configured","hosts","二个","errserverclosed","new","customhandler","'","whether","c","an","规则","var","time","unexpected","务器","err","are","responsewriter","os","of","servemux","listenandserve","处理器","响应","address","关闭","调用","任何","always","net","keep","的","[","cutsomerhandler","for","any","serverhttp","bool","客户端","必须","fatl","执行","自己","基本","第一","之前","which","struct","to","context","]","停止","make","m","被","hello","with","通道","string","the","longest","端口号","sorted","参数","类型","server2","少","incoming","tcp","s","under","localhost","w","matched","自定","a","秒","typically","所","访问","字符","之间","start","log","es","方法","\"","无法访问","that","rwmutex","map","地址","shortest","替代","不能","newservemux","accepted","defaultservemux","、","listens","on","http","connections","ordinary","ctrl","calls","import","sync","对应","休眠",":","package","as","handle","头","中","handlerfunc","sleep","<","multiplexer","和","returns","signature","时","=","println","world","8000","and","handler","信息","+","创建","closed","这里","一个","explains","signal","handlers","patterns","custom","带有","是","接收","第一个","在","mux","mux2","enable","pattern","传入","然后","muxentry","error","entries","_","缺陷","network","超时","handlefunc","用器","func","告知","contain"],"title":"01：建立HTTP服务器的多种方法","title_tokens":["务器","的","建立","多种","服务器","01","http","方法","服务","："]},{"location":"Golang/Go-Web/01 HTTPServe/#01http","text":"","text_tokens":[],"title":"01：建立HTTP服务器的多种方法","title_tokens":["务器","的","建立","多种","服务器","01","http","方法","服务","："]},{"location":"Golang/Go-Web/01 HTTPServe/#_1","text":"package mian import ( \"log\" \"net/http\" ) func main () { http . HadnleFunc ( \"/\" , func ( w http . ResponseWriter , r * http . Request ) { w . Write ([] byte ( \"hello world\" ) } log . Println ( \"starting HTTP server..\" ) log . Fatal ( http . ListenAndServe ( \":8000\" , nil )) } http.HandleFunc(pattern string, handler func(ResponseWriter, *Request) 根据一个==路由规则==绑定一个执行函数, 当用户访问到指定路由时执行. http.HandleFunc 的第二个参数必须符合函数签名 func(http.ResponseWriter, *http.Request) , 第一个参数是请求所对应的响应对象 http.ResponseWriter ,包含响应码、响应头和响应体, 在这里通过调用 响应对象 的 Write 方法像响应体写入字符串. 第二个参数是请求所对应的请求对象 *http.Request ,包含请求头、请求体等. http.ListenAndServe 启动HTTP服务器,监听 指定地址 和 端口号 的HTTP请求 http.HandleFunc 将传入的 绑定函数 转换为类型 http.HandleFunc (一个HTTP请求处理器对象),该对象类型实现 http.Handler 接口,接口方法调用自己 // net / http / server . go // The HandlerFunc type is an adapter to allow the use of // ordinary functions as HTTP handlers . If f is a function // with the appropriate signature , HandlerFunc ( f ) is a // Handler that calls f . type HandlerFunc func ( ResponseWriter , * Request ) // ServeHTTP calls f ( w , r ) . func ( f HandlerFunc ) ServeHTTP ( w ResponseWriter , r * Request ) { f ( w , r ) }","text_tokens":["\"","that","servehttp","对象","转换","go","服务器","*","二个","地址","符合","处理","理器","an","、","接口","实现","规则","http",",",")","type","写入","字符串","务器","starting","ordinary","calls","包含","adapter","import","responsewriter","}","appropriate","of","口号","function","listenandserve","对应"," ",":","处理器","响应","package","as","调用","头","码","request","net","functions","(","handlerfunc","的","[","签名","和","用户","signature","绑定","时","必须","执行","自己","第一","服务","=","根据","println","world",".","8000","to","handler","main","]","路由","server","mian","到","体等","hello","这里","with","一个","string","the","端口号","handlers","端口","当","通过","参数","监听","类型","allow","..","将","if","是","f","/","指定","第一个","hadnlefunc","启动","在","is","为","pattern","w","第二个","函数","第二","use","该","a","传入","write","byte","请求","访问","所","{","字符","handlefunc","func","nil","log","体","像","方法","r","fatal"],"title":"建立服务器","title_tokens":["务器","服务器","建立","服务"]},{"location":"Golang/Go-Web/01 HTTPServe/#handler","text":"package main import ( \"log\" \"net/http\" ) type customHandler {} // 将ServeHTTP方法绑定到customHandler上 func ( _ * customHandler ) ServeHTTP ( w http . ResponseWriter , r * http . Request ){ w . Write ([] byte ( \"hello custom Handler\" ) } func main () { http . Handle ( \"/\" , & cutsomerHandler {}) log . Println ( \"starting HTTP server...\" ) log . Fatl ( http . ListenAndServe ( \":8000\" , nil )) } 自定义类型 type customHandler{} 类型绑定 ServerHTTP(w http.ResponseWriter, r *http.Request) 方法 http.Handle 调用, 通过 &customHandler{} 传入该自定义类型的地址 少了将绑定函数转换为 type HandleFunc 的步骤","text_tokens":["println","\"","listenandserve","&",".","w"," ",":","8000","函数","handler","servehttp","main","package","自定","该","]","转换","handle","server","了","调用","到","*","...","传入","request","hello","地址","net","write","byte","(","customhandler","上","的","_","[","cutsomerhandler","通过","{","类型","custom","http","将","type",")",",","定义","自定义","handlefunc","/","serverhttp","starting","少","func","绑定","nil","步骤","log","import","}","responsewriter","方法","fatl","r","为"],"title":"自定义Handler","title_tokens":["自定","定义","自定义","handler"]},{"location":"Golang/Go-Web/01 HTTPServe/#servemux","text":"// ListenAndServe listens on the TCP network address addr and then calls // Serve with handler to handle requests on incoming connections. // Accepted connections are configured to enable TCP keep-alives. // // The handler is typically nil, in which case the DefaultServeMux is used. // // ListenAndServe always returns a non-nil error. func ListenAndServe ( addr string , handler Handler ) error { server := & Server { Addr : addr , Handler : handler } return server . ListenAndServe () } //*****************************// type Handler interface { ServeHTTP ( ResponseWriter , * Request ) } 实例中 http.ListenAndServe 的nil替代了实现了 http.Handler 接口的对象 http.Handler 实现 ServeHTTP 接口 缺陷 该方法不能像之前调用的 http.HandleFunc 和 http.Handle 为不同路由规则绑定不同的函数处理 package main import ( \"log\" \"net/http\" ) type customHandler struct {} func ( _ * customHandler ) ServeHTTP ( w http . ResponseWriter , r * http . Request ) { w . Write ([] byte ( \"hello custom server mux's ServeHTTP\" )) } func main () { log . Println ( \"starting HTTP server... \" ) log . Fatal ( http . ListenAndServe ( \":8000\" , & customHandler {})) }","text_tokens":["\"","&","servehttp","对象","configured","*","in","return","替代","不能","customhandler","'","处理","accepted","defaultservemux","接口","listens","on","实现","规则","http","connections",",",")","type","starting","calls","are","}","responsewriter","import","-","listenandserve"," ",":","address","package","handle","调用","...","request","中","always","serve","net","keep","(","的","fatal","[","和","returns","绑定","实例","之前","=","which","struct","println","case",".","and","to","handler","8000","main","]","路由","server","了","with","hello","the","string","custom","/","incoming","tcp","s","mux","is","enable","为","不同","w","alives","函数","addr","该","a","requests","then","interface","error","write","byte","typically","_","non","{","缺陷","network","handlefunc","func","nil","log","像","方法","r","used"],"title":"服务复用器(ServeMux)","title_tokens":["用器","复用器","复用","服务","(",")","servemux"]},{"location":"Golang/Go-Web/01 HTTPServe/#serve-mux","text":"// HandleFunc registers the handler function for the given pattern // in the DefaultServeMux. // The documentation for ServeMux explains how patterns are matched. func HandleFunc ( pattern string , handler func ( ResponseWriter , * Request )) { DefaultServeMux . HandleFunc ( pattern , handler ) } //*****************************// // DefaultServeMux is the default ServeMux used by Serve. var DefaultServeMux = & defaultServeMux var defaultServeMux ServeMux //*****************************// type ServeMux struct { mu sync . RWMutex m map [ string ] muxEntry es [] muxEntry // slice of entries sorted from longest to shortest. hosts bool // whether any patterns contain hostnames } handle.Handle 调用 DefaultServeMux ,该 DefaultMux 是 http.ServeMux 的封装 http.ServeMux 带有基本路由功能的服务复用器(Serve Multiplexer) 通过 http.NewServeMux 操作 http.ServeMux 对象, 调用 http.NewServeMux 的 .Handle 方法 package main import ( \"log\" \"net/http\" ) type customHandler struct {} func ( _ * customHandler ) ServeHTTP ( w http . ResponseWriter , r * http . Request ) { w . Write ([] byte ( \"hello new custom server mux\" )) } func main () { mux := http . NewServeMux () mux . Handle ( \"/\" , & customHandler {}) log . Println ( \"starting HTTP serve...\" ) log . Fatal ( http . ListenAndServe ( \":8000\" , mux )) }","text_tokens":["hostnames","\"","&","mu","servehttp","rwmutex","对象","map","hosts","*","new","shortest","in","newservemux","customhandler","whether","defaultservemux","http",",",")","var","type","starting","are","}","responsewriter","sync","import","of","servemux","function","listenandserve"," ",":","功能","package","handle","调用","...","request","documentation","serve","net","default","(","的","fatal","[","for","registers","any","封装","multiplexer","bool","基本","服务","given","=","struct","println",".","8000","to","handler","main","]","路由","server","m","hello","the","explains","string","longest","sorted","复用器","通过","patterns","custom","带有","是","/","how","mux","is","pattern","w","matched","操作","该","by","muxentry","slice","entries","write","byte","_","{","handlefunc","from","defaultmux","用器","复用","func","log","contain","es","方法","r","used"],"title":"自定义Serve Mux","title_tokens":[" ","自定","serve","定义","自定义","mux"]},{"location":"Golang/Go-Web/01 HTTPServe/#server","text":"func ListenAndServe ( addr string , handler Handler ) error { server := & Server { Addr : addr , Handler : handler } return server . ListenAndServe () } //***************************// type Server struct { Addr string Handler Handler ... }","text_tokens":["listenandserve","&","."," ",":","handler","addr","server","...","*","string","error","return","(","{",")",",","type","/","func","}","=","struct"],"title":"服务器对象(Server)","title_tokens":["务器",")","对象","服务","(","server","服务器"]},{"location":"Golang/Go-Web/01 HTTPServe/#server1","text":"调用 http.ListenAndServe 的时候创建了另一个 http.Serve 对象 package main import ( \"log\" \"net/http\" ) type customHandler struct {} func ( _ * customHandler ) ServeHTTP ( w http . ResponseWriter , r * http . Request ) { w . Write ([] byte ( \"hello custom server mux\" )) } func main () { mux := http . NewServeMux () mux . Handle ( \"/\" , & customHandler {}) serve := & http . Server { Addr : \":8000\" , Handler : mux , } log . Println ( \"starting HTTP serve...\" ) log . Fatal ( serve . ListenAndServe ()) }","text_tokens":["println","\"","listenandserve","另","&",".","w"," ",":","8000","handler","servehttp","main","package","addr","对象","创建","]","server","handle","时候","了","调用","...","*","request","hello","一个","serve","net","write","byte","newservemux","(","customhandler","的","fatal","_","[","{","custom","http",")","type",",","/","starting","func","log","import","}","responsewriter","r","=","mux","struct"],"title":"自定义server1","title_tokens":["自定","定义","server1","自定义"]},{"location":"Golang/Go-Web/01 HTTPServe/#server2","text":"// custome server 2 package main import ( \"log\" \"net/http\" \"time\" ) type customHandler struct {} func ( _ * customHandler ) ServeHTTP ( w http . ResponseWriter , r * http . Request ) { w . Write ([] byte ( \"hello custom server mux2\" )) } func main () { mux := http . NewServeMux () mux . Handle ( \"/\" , & customHandler {}) mux . HandleFunc ( \"/timeout\" , func ( w http . ResponseWriter , r * http . Request ) { // 超时 time . Sleep ( 2 * time . Second ) w . Write ([] byte ( \"Timeout\" )) }) server := & http . Server { Addr : \":8000\" , Handler : mux , WriteTimeout : 2 * time . Second , } log . Println ( \"starting HTTP server...\" ) log . Fatal ( server . ListenAndServe ()) } 无法访问到 localhost:8000/timeout 执行函数休眠2秒, 被 http.Serve 对象认为已经超时,提前关闭与客户端之间的连接, 后面无法像响应体写入任何信息","text_tokens":["\"","无法访问","&","custome","servehttp","无法","对象","*","timeout","newservemux","customhandler","http","type",")","time",",","写入","starting","import","}","responsewriter","listenandserve","休眠"," ",":","响应","提前","package","handle","关闭","...","任何","request","serve","net","(","sleep","的","客户","[","客户端","执行","=","struct","println",".","8000","handler","信息","main","]","server","到","被","hello","与","后面","custom","认为","second","/","mux","mux2","localhost","2","w","函数","addr","秒","writetimeout","write","byte","_","访问","已经","{","连接","超时","handlefunc","之间","func","log","体","像","r","fatal"],"title":"自定义server2","title_tokens":["自定","server2","定义","自定义"]},{"location":"Golang/Go-Web/01 HTTPServe/#_2","text":"通过捕捉系统信号(Signal)、goroutine和通道(Channel)实现 捕捉 os.Interrupt 信号(ctrl+c)然后调用 server.Shutdown 方法g告知服务器停止接受新请求 http.ErrServerClosed 根据该错误类型判断服务器是否正常关闭 package main import ( \"context\" \"log\" \"net/http\" \"os\" \"os/signal\" ) type customHandler struct {} func ( _ * customHandler ) ServeHTTP ( w http . ResponseWriter , r * http . Request ) { w . Write ([] byte ( \"hello custom server mux2\" )) } func main () { mux := http . NewServeMux () mux . Handle ( \"/\" , & customHandler {}) server := & http . Server { Addr : \":8000\" , Handler : mux , } // 创建系统信号接收器 quit := make ( chan os . Signal ) signal . Notify ( quit , os . Interrupt ) go func () { <- quit if err := server . Shutdown ( context . Background ()); err != nil { log . Fatal ( \"Shutdown server:\" , err ) } }() log . Println ( \"start HTTP server...\" ) err := server . ListenAndServe () if err != nil { if err == http . ErrServerClosed { log . Print ( \"Server Closed under request\" ) } else { log . Fatal ( \"Server closed unexpected\" ) } } }","text_tokens":["\"","goroutine","&","servehttp","正常","go","服务器","*","errserverclosed","判断","newservemux","customhandler","c","notify","、","实现","接受","http","channel",")","type",",","unexpected","务器","err","ctrl","import","}","responsewriter","os","-","listenandserve"," ",":","package","!","handle","关闭","调用","...","print","request","net","(","shutdown","background","<",";","g","[","和","interrupt","服务","错误","=","struct","捕捉","根据","println",".","+","context","8000","handler","main","创建","]","停止","server","make","closed","hello","通道","signal","通过","新","类型","custom","if","/","接收","quit","mux","mux2","under","w","addr","是否","该","然后","chan","信号","write","byte","系统","接收器","_","请求","{","start","func","告知","nil","log","方法","else","r","fatal"],"title":"优雅地停止服务","title_tokens":["停止","优雅","地","服务"]},{"location":"Golang/Go-Web/02 BasicTemplateUsage/","text":"02：基础模板 为什么要用模板 HTTP服务器响应固定的字符串不符合实际环境, 通过 text/template 包向客户端 响应动态内容 . 特性 将模板应用于给定的数据结构来执行模板，模板的编码与 Go 语言源代码文件相同，需为 UTF-8 编码 模板中的注解（Annotation）会根据数据结构中的元素来执行并派生具体的显示结构，这些元素一般指结构体中的字段或 map 中的键名 模板的执行逻辑会依据点（Dot，\".\"）操作符来设定当前的执行位置，并按序完成所有逻辑的执行。 模板中的行为（Action）包括数据评估（Data Evaluation）和控制逻辑，且需要使用双层大括号（{{ 和 }}）包裹。除行为以外的任何内容都会原样输出不做修改。 模板解析完成后，从设计上可以并发地进行渲染，但要注意被渲染对象的并发安全性。例如，一个模板可以同时为多个客户端的响应进行渲染，因为输出对象（Writer）是相互独立的，但是被渲染的对象可能有各自的状态和时效性。 如何使用模板 实例 package main import ( \"fmt\" \"text/template\" \"log\" \"net/http\" ) func main () { http . HandleFunc ( \"/\" , func ( w http . ResponseWriter , r * http . Request ) { // 创建模板对象并解析模板内容 tmpl , err := template . New ( \"test\" ). Parse ( \"Hello world!\" ) if err != nil { fmt . Fprintf ( w , \"Parse: %v\" , err ) return } // 调用模板对象的渲染方法 err = tmpl . Execute ( w , nil ) if err != nil { fmt . Fprintf ( w , \"Excute: %v\" , err ) return } }) log . Println ( \"starting HTTP server...\" ) log . Fatal ( http . ListenAndServe ( \":8000\" , nil )) } 引入 text/template 包. 调用 template.New 方法根据给定的名称新建模板, 返回一个 *template.Template 对象. *template.Template 对象的 Parse 方法接受字符串参数(文本模板内容), 解析并返回解析中遇到的错误. 调用 template.Execute 渲染模板, 参数分别为 输出对象 和 指定数据对象 , 实现了 io.Writer 接口的实例都可以作为输出对象. 渲染变量 package main import ( \"net/http\" \"log\" ) func main () { http . HandleFunc ( \"/\" , func ( w http . ResponseWriter , r * http . Reqeust ){ w . Write ([] byte ( r . URL . QUERY (). GET ( \"val\" ))) }) log . Println ( \"starting HTTP serve...\" ) log . Fatal ( http . ListenAndServe ( \":8000\" , nil )) } HTTP协议通过 GET 请求获取URL参数(URL中?后的值). 调用 *http.Request 对象的 URL.QUERY().GET() 方法. package main import ( \"fmt\" \"text/template\" \"log\" \"net/http\" ) func main () { http . HandleFunc ( \"/\" , func ( w http . ResponseWriter , r * http . Request ) { // 创建模板并解析内容 tmpl , err := template . New ( \"test\" ). Parse ( \"The value is: {{.}}\" ) if err != nil { fmt . Fprintf ( w , \"Parse: %v\" , err ) return } // 获取URL参数的值 val := r . URL . Query (). Get ( \"val\" ) // 调用模板对象渲染方法 err = tmpl . Execute ( w , val ) if err != nil { fmt . Fprintf ( w , \"Execute: %v\" , err ) return } }) log . Println ( \"starting HTTP server...\" ) log . Fatal ( http . ListenAndServe ( \":8000\" , nil )) } 模板内容修改成 The value is : {{.}} , 用了 分隔符 将 . 操作符包裹起来, . 操作符默认指向 根对象 , 即 template.Execute 中的第二个参数. 在 template.Execute 方法中传入 val , . 操作符渲染该变量 val 实现动态输出. 渲染复杂对象 package main import ( \"fmt\" \"text/template\" \"log\" \"net/http\" \"strconv\" ) // Inventory 库存 type Inventory struct { SKU string Name string UnitPrice float64 Quantity int64 , } func main () { http . HandleFunc ( \"/\" , func ( w http . ResponseWriter , r * http . Request ) { tmpl , err := template . New ( \"test\" ). Parse ( `Inventory SKU: {{.SKU}} Name: {{.Name}} UnitPrice: {{.UnitPrice}} Quantity: {{.Quantity}} ` ) if err != nil { fmt . Fprintf ( w , \"Parse:%v\" , err ) return } // 根据URL查询参数的值创建Inventory实例 inventory := & Inventory { SKU : r . URL . Query (). Get ( \"sku\" ), Name : r . URL . Query (). Get ( \"name\" ), } // 数据处理 inventory . UnitPrice , _ = strconv . ParseFloat ( r . URL . Query (). Get ( \"unitPrice\" ), 64 ) inventory . Quantity , _ = strconv . ParseInt ( r . URL . Query (). Get ( \"quantity\" ), 10 , 64 ) // 渲染 err = tmpl . Execute ( w , inventory ) if err != nil { fmt . Fprintf ( w , \"Execute: %v\" , err ) return } }) log . Println ( \"start HTTP serve...\" ) log . Fatal ( http . ListenAndServe ( \":8000\" , nil )) } template.Execute 的第二个参数类型为 interface{} , 可以传入任何类型的参数. func ( t * Template ) Execute ( wr io . Writer , data interface {}) error { if err := t . escape (); err != nil { return err } return t . text . Execute ( wr , data ) } http/template 会根据传入的 根对象 进行底层类型分析, 自动识别变量, 此时的 . 操作符代表 inventory 结构体, 因此可以调用 inventory 的各个属性. 在 Parse 的时候用反引号``将结构体包起来. 渲染中调用结构体的方法 func ( i * Inventory ) Subtotal () float64 { return i . UnitPrice * float64 ( i . Quantity ) } //******************************// http . HandleFunc ( \"/\" , func ( w http . ResponseWriter , r * http . Request ) { tmpl , err := template . New ( \"test\" ). Parse ( `Inventory SKU: {{.SKU}} Name: {{.Name}} UnitPrice: {{.UnitPrice}} Quantity: {{.Quantity}} Subtotal: {{.Subtotal}} ` ) map类型作为模板跟对象 package main import ( \"fmt\" \"log\" \"net/http\" \"strconv\" \"text/template\" ) func main () { http . HandleFunc ( \"/\" , func ( w http . ResponseWriter , r * http . Request ) { // 创建模板对象并解析模板内容 tmpl , err := template . New ( \"test\" ). Parse ( `Inventory SKU: {{.SKU}} Name: {{.Name}} UnitPrice: {{.UnitPrice}} Quantity: {{.Quantity}} ` ) if err != nil { fmt . Fprintf ( w , \"Parse: %v\" , err ) return } // 直接将URL 查询参数的值赋值给变量 sku := r . URL . Query (). Get ( \"sku\" ) name := r . URL . Query (). Get ( \"name\" ) unitPrice , _ := strconv . ParseFloat ( r . URL . Query (). Get ( \"unitPrice\" ), 64 ) quantity , _ := strconv . ParseInt ( r . URL . Query (). Get ( \"quantity\" ), 10 , 64 ) err = tmpl . Execute ( w , map [ string ] interface {}{ \"SKU\" : sku , \"Name\" : name , \"UnitPrice\" : unitPrice , \"Quantity\" : quantity , }) if err != nil { fmt . Fprintf ( w , \"Execute: %v\" , err ) return } }) log . Println ( \"Starting HTTP server...\" ) log . Fatal ( http . ListenAndServe ( \"localhost:8000\" , nil )) } 传递给 Execute 一个 map[string]interface{} 作为模板对象,可以传入任意类型的值, 将结构体的所有值都传入. 不再需要单独创建实例, 只需要通过 r.URL.Query().Get(valName) 获取URL查询参数的值. 其中数值需要用到 strconv.ParseInt/ParseFloat 进行转化 注释 tmpl , err := template . New ( \"test\" ). Parse ( `Inventory{{/* 打印参数的值 */}} SKU: {{.SKU}} Name: {{.Name}} UnitPrice: {{.UnitPrice}} Quantity: {{.Quantity}} ` ) 通过 {{}} 双层大括号和 /**/ 括起来的值是注释 模板流程 template.New 新建模板, 返回 *template.Template 对象 调用 *template.Template 对象的 Parse 方法解析模板 传入模板实例 数据处理 strconv 调用 *template.Template 对象的 Execute 方法渲染模板","text_tokens":["对象","*","v","10","符合","应用","return","处理","要","接口","即","接受",",","type","注意","字符串","starting","语言","库存","源代码"," ","都","流程","!","...","括号","返回","serve","(","包","相互",";","自动","只","其中","复杂","execute","错误","根据","指向","%","段","当前","渲染","main","不再","内容","server","地","了","parse","：","通过","64","将","一般","if","annotation","进行","/","分析","指","完成","is","第二个","第二","输出","做","同时","特性","单独","write","byte","时效性","请求","但","控制","分隔","遇到","依据","评估","nil","字","t","体","操作符","r","行为","&","io","action","分隔符","服务器","于","实现",")","此时","代码","获取","}","sku","修改","除","-","）","所有","转化","时效","时候","使用","默认","request","strconv","动态","test","因为","subtotal","客户","get","name","wr","什么","实例","各自","服务","起来",".","i","属性","与","上","基础","实际","text","quantity","escape","指定","excute","作为","传递","为","query","操作","给定","结构","该","任意","因此","interface","这些","{","需为","给","fatal","点","大括号","go","二个","new","数值","根","分别","反","务器","err","template","后","responsewriter","打印","listenandserve","设计","响应","固定","位置","按序","（","调用","设定","任何","url","名称","net","tmpl","的","[","用到","reqeust","数据","多个","`","unitprice","底层","?","客户端","执行","struct","]","例如","02","各个","被","hello","the","string","writer","但是","参数","包向","valname","类型","跟","新建","parsefloat","localhost","w","文本","相同","注释","value","。","识别","派生","int64","字符","体包","start","逻辑","data","log","方法","双层","\"","来","引入","或","用","map","有","包裹","数据结构","可能","模板","从","http","原样","import","安全性","代表",":","package","fprintf","fmt","体中","并发","parseint","符合实际","中","状态","会","括","utf","和","独立","evaluation","=","直接","为什么","不","println","变量","world","包括","8000","创建","元素","数据处理","解析","val","，","一个","查询","协议","注解","dot","赋值","需要","是","可以","成","在","并","值","显示","键名","且","inventory","具体","传入","环境","error","引号","_","以外","如何","handlefunc","float64","文件","func","编码","8","安全","自动识别"],"title":"02：基础模板","title_tokens":["基础","02","：","模板"]},{"location":"Golang/Go-Web/02 BasicTemplateUsage/#02","text":"","text_tokens":[],"title":"02：基础模板","title_tokens":["基础","02","：","模板"]},{"location":"Golang/Go-Web/02 BasicTemplateUsage/#_1","text":"HTTP服务器响应固定的字符串不符合实际环境, 通过 text/template 包向客户端 响应动态内容 .","text_tokens":["."," ","响应","内容","固定","服务器","符合实际","环境","动态","符合","的","客户","通过","包向","实际","text","字符","http",",","字符串","务器","/","template","客户端","服务","不"],"title":"为什么要用模板","title_tokens":["什么","模板","用","为什么","要"]},{"location":"Golang/Go-Web/02 BasicTemplateUsage/#_2","text":"将模板应用于给定的数据结构来执行模板，模板的编码与 Go 语言源代码文件相同，需为 UTF-8 编码 模板中的注解（Annotation）会根据数据结构中的元素来执行并派生具体的显示结构，这些元素一般指结构体中的字段或 map 中的键名 模板的执行逻辑会依据点（Dot，\".\"）操作符来设定当前的执行位置，并按序完成所有逻辑的执行。 模板中的行为（Action）包括数据评估（Data Evaluation）和控制逻辑，且需要使用双层大括号（{{ 和 }}）包裹。除行为以外的任何内容都会原样输出不做修改。 模板解析完成后，从设计上可以并发地进行渲染，但要注意被渲染对象的并发安全性。例如，一个模板可以同时为多个客户端的响应进行渲染，因为输出对象（Writer）是相互独立的，但是被渲染的对象可能有各自的状态和时效性。","text_tokens":["\"","点","来","action","或","大括号","对象","map","有","go","包裹","数据结构","应用","要","于","可能","模板","从","原样","注意","语言","代码","后","}","修改","除","-","安全性","）","所有","源代码"," ","都","设计","响应","位置","按序","（","体中","并发","时效","使用","设定","任何","括号","中","因为","状态","会","的","客户","相互","数据","utf","多个","和","独立","客户端","执行","evaluation","各自","不","根据","段",".","当前","包括","渲染","内容","元素","例如","地","解析","被","，","一个","writer","与","但是","注解","dot","上","需要","将","一般","annotation","进行","是","可以","指","完成","并","为","操作","显示","给定","键名","结构","相同","输出","且","做","同时","具体","。","派生","这些","时效性","以外","但","控制","{","需为","依据","文件","逻辑","编码","评估","字","8","data","操作符","安全","双层","行为"],"title":"特性","title_tokens":["特性"]},{"location":"Golang/Go-Web/02 BasicTemplateUsage/#_3","text":"","text_tokens":[],"title":"如何使用模板","title_tokens":["模板","如何","使用"]},{"location":"Golang/Go-Web/02 BasicTemplateUsage/#_4","text":"package main import ( \"fmt\" \"text/template\" \"log\" \"net/http\" ) func main () { http . HandleFunc ( \"/\" , func ( w http . ResponseWriter , r * http . Request ) { // 创建模板对象并解析模板内容 tmpl , err := template . New ( \"test\" ). Parse ( \"Hello world!\" ) if err != nil { fmt . Fprintf ( w , \"Parse: %v\" , err ) return } // 调用模板对象的渲染方法 err = tmpl . Execute ( w , nil ) if err != nil { fmt . Fprintf ( w , \"Excute: %v\" , err ) return } }) log . Println ( \"starting HTTP server...\" ) log . Fatal ( http . ListenAndServe ( \":8000\" , nil )) } 引入 text/template 包. 调用 template.New 方法根据给定的名称新建模板, 返回一个 *template.Template 对象. *template.Template 对象的 Parse 方法接受字符串参数(文本模板内容), 解析并返回解析中遇到的错误. 调用 template.Execute 渲染模板, 参数分别为 输出对象 和 指定数据对象 , 实现了 io.Writer 接口的实例都可以作为输出对象.","text_tokens":["\"","io","引入","对象","*","v","new","return","接口","模板","实现","接受","http","分别",",",")","字符串","err","starting","template","import","responsewriter","}","listenandserve"," ",":","都","package","!","fprintf","fmt","调用","...","request","test","返回","中","名称","net","tmpl","(","包","的","数据","和","execute","实例","错误","=","根据","println","%","world",".","8000","渲染","main","内容","创建","server","解析","了","hello","一个","writer","parse","参数","text","if","/","可以","指定","excute","作为","新建","并","为","w","给定","文本","输出","{","字符","handlefunc","遇到","func","nil","log","方法","r","fatal"],"title":"实例","title_tokens":["实例"]},{"location":"Golang/Go-Web/02 BasicTemplateUsage/#_5","text":"package main import ( \"net/http\" \"log\" ) func main () { http . HandleFunc ( \"/\" , func ( w http . ResponseWriter , r * http . Reqeust ){ w . Write ([] byte ( r . URL . QUERY (). GET ( \"val\" ))) }) log . Println ( \"starting HTTP serve...\" ) log . Fatal ( http . ListenAndServe ( \":8000\" , nil )) } HTTP协议通过 GET 请求获取URL参数(URL中?后的值). 调用 *http.Request 对象的 URL.QUERY().GET() 方法. package main import ( \"fmt\" \"text/template\" \"log\" \"net/http\" ) func main () { http . HandleFunc ( \"/\" , func ( w http . ResponseWriter , r * http . Request ) { // 创建模板并解析内容 tmpl , err := template . New ( \"test\" ). Parse ( \"The value is: {{.}}\" ) if err != nil { fmt . Fprintf ( w , \"Parse: %v\" , err ) return } // 获取URL参数的值 val := r . URL . Query (). Get ( \"val\" ) // 调用模板对象渲染方法 err = tmpl . Execute ( w , val ) if err != nil { fmt . Fprintf ( w , \"Execute: %v\" , err ) return } }) log . Println ( \"starting HTTP server...\" ) log . Fatal ( http . ListenAndServe ( \":8000\" , nil )) } 模板内容修改成 The value is : {{.}} , 用了 分隔符 将 . 操作符包裹起来, . 操作符默认指向 根对象 , 即 template.Execute 中的第二个参数. 在 template.Execute 方法中传入 val , . 操作符渲染该变量 val 实现动态输出.","text_tokens":["\"","用","对象","分隔符","包裹","*","v","二个","new","return","根","即","模板","实现","http",",",")","starting","err","template","获取","后","import","responsewriter","}","修改","listenandserve"," ",":","package","!","fprintf","fmt","调用","...","url","request","默认","动态","test","中","serve","net","tmpl","(","的","[","get","reqeust","?","execute","=","println","指向","%","变量","起来",".","8000","渲染","main","内容","创建","]","server","解析","了","val","协议","the","parse","通过","参数","text","将","if","/","成","在","is","并","query","值","w","第二个","操作","第二","该","输出","传入","value","write","byte","请求","{","分隔","handlefunc","func","nil","log","操作符","方法","r","fatal"],"title":"渲染变量","title_tokens":["变量","渲染"]},{"location":"Golang/Go-Web/02 BasicTemplateUsage/#_6","text":"package main import ( \"fmt\" \"text/template\" \"log\" \"net/http\" \"strconv\" ) // Inventory 库存 type Inventory struct { SKU string Name string UnitPrice float64 Quantity int64 , } func main () { http . HandleFunc ( \"/\" , func ( w http . ResponseWriter , r * http . Request ) { tmpl , err := template . New ( \"test\" ). Parse ( `Inventory SKU: {{.SKU}} Name: {{.Name}} UnitPrice: {{.UnitPrice}} Quantity: {{.Quantity}} ` ) if err != nil { fmt . Fprintf ( w , \"Parse:%v\" , err ) return } // 根据URL查询参数的值创建Inventory实例 inventory := & Inventory { SKU : r . URL . Query (). Get ( \"sku\" ), Name : r . URL . Query (). Get ( \"name\" ), } // 数据处理 inventory . UnitPrice , _ = strconv . ParseFloat ( r . URL . Query (). Get ( \"unitPrice\" ), 64 ) inventory . Quantity , _ = strconv . ParseInt ( r . URL . Query (). Get ( \"quantity\" ), 10 , 64 ) // 渲染 err = tmpl . Execute ( w , inventory ) if err != nil { fmt . Fprintf ( w , \"Execute: %v\" , err ) return } }) log . Println ( \"start HTTP serve...\" ) log . Fatal ( http . ListenAndServe ( \":8000\" , nil )) } template.Execute 的第二个参数类型为 interface{} , 可以传入任何类型的参数. func ( t * Template ) Execute ( wr io . Writer , data interface {}) error { if err := t . escape (); err != nil { return err } return t . text . Execute ( wr , data ) } http/template 会根据传入的 根对象 进行底层类型分析, 自动识别变量, 此时的 . 操作符代表 inventory 结构体, 因此可以调用 inventory 的各个属性. 在 Parse 的时候用反引号``将结构体包起来.","text_tokens":["\"","&","io","用","对象","*","v","二个","10","new","return","处理","根","http","反","type",")",",","此时","err","template","import","sku","}","responsewriter","库存","listenandserve","代表"," ",":","package","!","fprintf","fmt","parseint","时候","调用","...","任何","strconv","request","url","test","serve","net","tmpl","(","会","的",";","get","数据","name","自动","`","wr","unitprice","底层","execute","实例","=","struct","根据","println","%","变量","起来",".","8000","渲染","main","创建","数据处理","各个","查询","string","属性","writer","parse","64","参数","类型","text","将","quantity","if","进行","/","escape","可以","分析","在","parsefloat","为","值","query","w","第二个","第二","操作","结构","inventory","传入","因此","interface","识别","error","引号","_","int64","{","体包","handlefunc","start","float64","func","t","nil","log","data","操作符","体","r","自动识别","fatal"],"title":"渲染复杂对象","title_tokens":["复杂","对象","渲染"]},{"location":"Golang/Go-Web/02 BasicTemplateUsage/#_7","text":"func ( i * Inventory ) Subtotal () float64 { return i . UnitPrice * float64 ( i . Quantity ) } //******************************// http . HandleFunc ( \"/\" , func ( w http . ResponseWriter , r * http . Request ) { tmpl , err := template . New ( \"test\" ). Parse ( `Inventory SKU: {{.SKU}} Name: {{.Name}} UnitPrice: {{.UnitPrice}} Quantity: {{.Quantity}} Subtotal: {{.Subtotal}} ` )","text_tokens":["\"",".","w"," ",":","inventory","*","i","request","new","test","parse","return","tmpl","(","subtotal","{","name","http","`","quantity",")","unitprice","handlefunc",",","/","float64","err","func","template","}","responsewriter","sku","r","="],"title":"渲染中调用结构体的方法","title_tokens":["调用","的","中","体","渲染","结构","方法"]},{"location":"Golang/Go-Web/02 BasicTemplateUsage/#map","text":"package main import ( \"fmt\" \"log\" \"net/http\" \"strconv\" \"text/template\" ) func main () { http . HandleFunc ( \"/\" , func ( w http . ResponseWriter , r * http . Request ) { // 创建模板对象并解析模板内容 tmpl , err := template . New ( \"test\" ). Parse ( `Inventory SKU: {{.SKU}} Name: {{.Name}} UnitPrice: {{.UnitPrice}} Quantity: {{.Quantity}} ` ) if err != nil { fmt . Fprintf ( w , \"Parse: %v\" , err ) return } // 直接将URL 查询参数的值赋值给变量 sku := r . URL . Query (). Get ( \"sku\" ) name := r . URL . Query (). Get ( \"name\" ) unitPrice , _ := strconv . ParseFloat ( r . URL . Query (). Get ( \"unitPrice\" ), 64 ) quantity , _ := strconv . ParseInt ( r . URL . Query (). Get ( \"quantity\" ), 10 , 64 ) err = tmpl . Execute ( w , map [ string ] interface {}{ \"SKU\" : sku , \"Name\" : name , \"UnitPrice\" : unitPrice , \"Quantity\" : quantity , }) if err != nil { fmt . Fprintf ( w , \"Execute: %v\" , err ) return } }) log . Println ( \"Starting HTTP server...\" ) log . Fatal ( http . ListenAndServe ( \"localhost:8000\" , nil )) } 传递给 Execute 一个 map[string]interface{} 作为模板对象,可以传入任意类型的值, 将结构体的所有值都传入. 不再需要单独创建实例, 只需要通过 r.URL.Query().Get(valName) 获取URL查询参数的值. 其中数值需要用到 strconv.ParseInt/ParseFloat 进行转化","text_tokens":["\"","对象","map","*","v","10","new","return","数值","模板","http",")",",","err","starting","template","获取","import","responsewriter","sku","}","listenandserve","所有"," ",":","都","转化","package","!","fprintf","fmt","parseint","...","strconv","request","url","test","net","tmpl","(","的","[","get","用到","name","只","`","unitprice","其中","execute","实例","直接","=","println","%","变量",".","8000","main","不再","内容","创建","]","server","解析","一个","查询","string","parse","通过","64","参数","valname","类型","text","赋值","需要","将","quantity","if","进行","/","可以","作为","parsefloat","传递","并","localhost","值","query","w","结构","inventory","任意","传入","interface","单独","_","{","handlefunc","func","nil","给","log","体","r","fatal"],"title":"map类型作为模板跟对象","title_tokens":["模板","类型","对象","map","跟","作为"]},{"location":"Golang/Go-Web/02 BasicTemplateUsage/#_8","text":"tmpl , err := template . New ( \"test\" ). Parse ( `Inventory{{/* 打印参数的值 */}} SKU: {{.SKU}} Name: {{.Name}} UnitPrice: {{.UnitPrice}} Quantity: {{.Quantity}} ` ) 通过 {{}} 双层大括号和 /**/ 括起来的值是注释","text_tokens":["\"","起来","值","."," ",":","大括号","注释","inventory","*","括号","new","test","parse","tmpl","(","的","通过","参数","括","{","name","和","`",")",",","unitprice","quantity","是","/","err","template","}","sku","=","双层","打印"],"title":"注释","title_tokens":["注释"]},{"location":"Golang/Go-Web/02 BasicTemplateUsage/#_9","text":"template.New 新建模板, 返回 *template.Template 对象 调用 *template.Template 对象的 Parse 方法解析模板 传入模板实例 数据处理 strconv 调用 *template.Template 对象的 Execute 方法渲染模板","text_tokens":["."," ","渲染","对象","数据处理","解析","调用","*","传入","strconv","new","返回","parse","处理","的","数据","模板",",","template","execute","实例","方法","新建"],"title":"模板流程","title_tokens":["流程","模板"]},{"location":"Golang/Go-Web/03 AdvanceTemplateUsage/","text":"03：进阶模板用法 在模板中定义变量 package main import ( \"fmt\" \"log\" \"net/http\" \"text/template\" ) func main () { http . HandleFunc ( \"/\" , func ( w http . ResponseWriter , r * http . Request ) { tmpl , err := template . New ( \"test\" ). Parse ( ` {{$name := \"Alice\"}} {{$age := 18}} {{$round2 := true}} Name: {{$name}} Age: {{$age}} Round2: {{$round2}} ` ) if err != nil { fmt . Fprintf ( w , \"Parse: %v\" , err ) return } err = tmpl . Execute ( w , nil ) if err != nil { fmt . Fprintf ( w , \"Execute: %v\" , err ) return } }) log . Println ( \"starting HTTP serve...\" ) log . Fatal ( http . ListenAndServe ( \":8000\" , nil )) } 用美元符号 $ 作为前缀表示变 $name , $age 变量的定义/赋值必须使用 := 语法 直接通过 {{$VarName}} 调用 所有变量的操作都属于模板语法的一部分,需要用 {{}} 括起来 修改变量的值 ... tmpl , err := template . New ( \"test\" ). Parse ( ` {{$name := \"Alice\"}} {{$age := 18}} {{$round2 := true}} Name: {{$name}} Age: {{$age}} Round2: {{$round2}} {{$name = \"K\"}} Name: {{$name}} ` ) ... 类似赋值, 用 = 号直接修改变量值 在模板中使用条件判断(if) package main import ( \"fmt\" \"log\" \"net/http\" \"strconv\" \"text/template\" ) func main () { http . HandleFunc ( \"/\" , func ( w http . ResponseWriter , r * http . Request ) { tmpl , err := template . New ( \"test\" ). Parse ( ` {{if .yIsZero}} 除数不能为0 {{else}} {{.result}} {{end}} ` ) if err != nil { fmt . Fprintf ( w , \"Parse: %v\" , err ) return } x , _ := strconv . ParseInt ( r . URL . Query (). Get ( \"x\" ), 10 , 64 ) y , _ := strconv . ParseInt ( r . URL . Query (). Get ( \"y\" ), 10 , 64 ) yIsZero := y == 0 result := 0.0 if ! yIsZero { result = float64 ( x ) / float64 ( y ) } err = tmpl . Execute ( w , map [ string ] interface {}{ \"yIsZero\" : yIsZero , \"result\" : result , }) if err != nil { fmt . Fprintf ( w , \"Execute: %v\" , err ) } }) log . Println ( \"starting HTTP serve...\" ) log . Fatal ( http . ListenAndServe ( \":8000\" , nil )) } 用 {{}} 将 if 逻辑语句括起来, if 后面必须返回一个 bool 值 if 语句包括 {{if}} , {{else}} , {{end}} 等式和不等式 eq ：当等式 arg1 == arg2 成立时，返回 true，否则返回 false ne ：当不等式 arg1 != arg2 成立时，返回 true，否则返回 false lt ：当不等式 arg1 < arg2 成立时，返回 true，否则返回 false le ：当不等式 arg1 <= arg2 成立时，返回 true，否则返回 false gt ：当不等式 arg1 > arg2 成立时，返回 true，否则返回 false ge ：当不等式 arg1 >= arg2 成立时，返回 true，否则返回 false package main import ( \"fmt\" \"log\" \"net/http\" \"text/template\" ) func main () { http . HandleFunc ( \"/\" , func ( w http . ResponseWriter , r * http . Request ) { tmpl , err := template . New ( \"test\" ). Parse ( ` {{$name1 := \"alice\"}} {{$name2 := \"bob\"}} {{$age1 := 18}} {{$age2 := 23}} {{if eq $age1 $age2}} 年龄相同 {{else}} 年龄不同 {{end}} {{if ne $name1 $name2}} 名字不相同 {{end}} ` ) if err != nil { fmt . Fprintf ( w , \"Parse: %v\" , err ) return } err = tmpl . Execute ( w , nil ) if err != nil { fmt . Fprintf ( w , \"Execute: %v\" , err ) return } }) log . Println ( \"Starting HTTP server...\" ) log . Fatal ( http . ListenAndServe ( \"localhost:8000\" , nil )) } 迭代操作(range) Go 语言中一般来说有三种类型可以进行迭代操作，数组（Array）、切片（Slice）和 map 类型 package main import ( \"fmt\" \"log\" \"net/http\" \"text/template\" ) func main () { http . HandleFunc ( \"/\" , func ( w http . ResponseWriter , r * http . Request ) { tmpl , err := template . New ( \"test\" ). Parse ( ` {{range $name := .Names}} {{$name}} {{end}} ` ) if err != nil { fmt . Fprintf ( w , \"Parse: %v\" , err ) return } err = tmpl . Execute ( w , map [ string ] interface {}{ \"Names\" : [] string { \"Alice\" , \"Bob\" , \"Carol\" , \"David\" , }, }) if err != nil { fmt . Fprintf ( w , \"Execute: %v\" , err ) return } }) log . Println ( \"Starting HTTP server...\" ) log . Fatal ( http . ListenAndServe ( \"localhost:8000\" , nil )) } 获得迭代元素的索引 ... func main () { http . HandleFunc ( \"/\" , func ( w http . ResponseWriter , r * http . Request ) { // 创建模板对象并解析模板内容 tmpl , err := template . New ( \"test\" ). Parse ( ` {{range $i, $name := .Names}} {{$i}}. {{$name}} {{end}} ` ) ... map类型 ... func main () { http . HandleFunc ( \"/\" , func ( w http . ResponseWriter , r * http . Request ) { // 创建模板对象并解析模板内容 tmpl , err := template . New ( \"test\" ). Parse ( ` {{range $name, $val := .}} {{$name}}: {{$val}} {{end}} ` ) ... // 调用模板对象的渲染方法 err = tmpl . Execute ( w , map [ string ] interface {}{ \"Names\" : [] string { \"Alice\" , \"Bob\" , \"Carol\" , \"David\" , }, \"Numbers\" : [] int { 1 , 3 , 5 , 7 }, }) ... } with tmpl , err := template . New ( \"test\" ). Parse ( `Inventory {{with .Inventory}} SKU: {{.SKU}} Name: {{.Name}} UnitPrice: {{.UnitPrice}} Quantity: {{.Quantity}} {{end}} ` ) //****************************// err = tmpl . Execute ( w , map [ string ] interface {}{ \"Inventory\" : Inventory { // 类型 SKU : \"11000\" , Name : \"Phone\" , UnitPrice : 699.99 , Quantity : 666 , }, }) 用 {{with}} 来替代相关实例\" Inventory \". 空白符号处理 {{- 表示剔除模板内容 左侧 的所有空白符号, -}} 表示剔除模板内容 右侧 的所有空白符号. ... func main () { http . HandleFunc ( \"/\" , func ( w http . ResponseWriter , r * http . Request ) { // 创建模板对象并解析模板内容 tmpl , err := template . New ( \"test\" ). Parse ( `Inventory {{- with .Inventory}} SKU: {{.SKU}} Name: {{.Name}} UnitPrice: {{.UnitPrice}} Quantity: {{.Quantity}} {{- end}} ` ) ...","text_tokens":["\"","666","来","数组","yiszero","carol","lt","用","不等式","map","有","对象","go","11000","表示","*","v","10","判断","david","new","false","return","不能","bob","int","替代","name1","处理","age2","语法","、","$","否则","end","模板","http",")",",","err","starting","类似","语言","template","import","responsewriter","}","sku","修改","-","0.0","listenandserve","成立","所有","k","）","索引"," ",":","age","都","package","!","fprintf","一部分",">","fmt","美元","（","parseint","0","使用","y","调用","...","strconv","request","url","获得","test","返回","中","来说","serve","net","18","tmpl","(","ge","的","<","一般来说","相关","[","get","括","进阶","等式","name","x","不等","用法","699.99","和","`","定义","unitprice","true","bool","execute","时","必须","3","实例","前缀","直接","=","eq","不","println","%","变量","起来","三种",".","1","包括","8000","渲染","main","内容","创建","]","切片","server","元素","解析","val","i","with","names","，","一个","string","语句","alice","parse","量值","后面","一部","arg1","：","条件","当","名字","range","通过","64","号","类型","text","赋值","03","需要","将","le","一般","if","quantity","ne","进行","剔除","/","右侧","可以","result","部分","gt","name2","在","作为","变量值","numbers","为","并","不同","localhost","varname","值","query","w","操作","符号","arg2","相同","inventory","变","interface","slice","round2","7","迭代","_","23","左侧","{","5","array","handlefunc","phone","属于","age1","float64","逻辑","func","nil","log","方法","else","r","除数","fatal","年龄","空白"],"title":"03：进阶模板用法","title_tokens":["模板","进阶","03","用法","："]},{"location":"Golang/Go-Web/03 AdvanceTemplateUsage/#03","text":"","text_tokens":[],"title":"03：进阶模板用法","title_tokens":["模板","进阶","03","用法","："]},{"location":"Golang/Go-Web/03 AdvanceTemplateUsage/#_1","text":"package main import ( \"fmt\" \"log\" \"net/http\" \"text/template\" ) func main () { http . HandleFunc ( \"/\" , func ( w http . ResponseWriter , r * http . Request ) { tmpl , err := template . New ( \"test\" ). Parse ( ` {{$name := \"Alice\"}} {{$age := 18}} {{$round2 := true}} Name: {{$name}} Age: {{$age}} Round2: {{$round2}} ` ) if err != nil { fmt . Fprintf ( w , \"Parse: %v\" , err ) return } err = tmpl . Execute ( w , nil ) if err != nil { fmt . Fprintf ( w , \"Execute: %v\" , err ) return } }) log . Println ( \"starting HTTP serve...\" ) log . Fatal ( http . ListenAndServe ( \":8000\" , nil )) } 用美元符号 $ 作为前缀表示变 $name , $age 变量的定义/赋值必须使用 := 语法 直接通过 {{$VarName}} 调用 所有变量的操作都属于模板语法的一部分,需要用 {{}} 括起来","text_tokens":["\"","用","表示","*","v","new","return","语法","$","模板","http",",",")","err","starting","template","import","responsewriter","}","listenandserve","所有"," ",":","age","都","package","!","fprintf","一部分","fmt","美元","使用","调用","...","request","test","serve","net","18","tmpl","(","的","括","name","`","定义","true","execute","必须","前缀","直接","=","println","%","变量","起来",".","8000","main","alice","parse","一部","通过","text","赋值","需要","if","/","部分","作为","varname","w","操作","符号","变","round2","{","handlefunc","属于","func","nil","log","r","fatal"],"title":"在模板中定义变量","title_tokens":["变量","中","模板","在","定义"]},{"location":"Golang/Go-Web/03 AdvanceTemplateUsage/#_2","text":"... tmpl , err := template . New ( \"test\" ). Parse ( ` {{$name := \"Alice\"}} {{$age := 18}} {{$round2 := true}} Name: {{$name}} Age: {{$age}} Round2: {{$round2}} {{$name = \"K\"}} Name: {{$name}} ` ) ... 类似赋值, 用 = 号直接修改变量值","text_tokens":["\"","变量","k","."," ",":","age","用","直接","...","new","test","alice","parse","round2","量值","18","tmpl","(","$","号","{","name","赋值","`",")",",","err","类似","template","true","}","修改","变量值","="],"title":"修改变量的值","title_tokens":["的","变量","修改","值"]},{"location":"Golang/Go-Web/03 AdvanceTemplateUsage/#if","text":"package main import ( \"fmt\" \"log\" \"net/http\" \"strconv\" \"text/template\" ) func main () { http . HandleFunc ( \"/\" , func ( w http . ResponseWriter , r * http . Request ) { tmpl , err := template . New ( \"test\" ). Parse ( ` {{if .yIsZero}} 除数不能为0 {{else}} {{.result}} {{end}} ` ) if err != nil { fmt . Fprintf ( w , \"Parse: %v\" , err ) return } x , _ := strconv . ParseInt ( r . URL . Query (). Get ( \"x\" ), 10 , 64 ) y , _ := strconv . ParseInt ( r . URL . Query (). Get ( \"y\" ), 10 , 64 ) yIsZero := y == 0 result := 0.0 if ! yIsZero { result = float64 ( x ) / float64 ( y ) } err = tmpl . Execute ( w , map [ string ] interface {}{ \"yIsZero\" : yIsZero , \"result\" : result , }) if err != nil { fmt . Fprintf ( w , \"Execute: %v\" , err ) } }) log . Println ( \"starting HTTP serve...\" ) log . Fatal ( http . ListenAndServe ( \":8000\" , nil )) } 用 {{}} 将 if 逻辑语句括起来, if 后面必须返回一个 bool 值 if 语句包括 {{if}} , {{else}} , {{end}}","text_tokens":["\"","yiszero","用","map","*","v","10","new","不能","return","end","http",")",",","err","starting","template","import","responsewriter","}","0.0","listenandserve"," ",":","package","!","fprintf","fmt","parseint","0","y","...","strconv","request","url","test","返回","serve","net","tmpl","(","[","get","括","x","`","bool","execute","必须","=","println","%","起来",".","包括","8000","main","]","一个","string","语句","parse","后面","64","text","将","if","/","result","为","query","值","w","interface","_","{","handlefunc","float64","逻辑","func","nil","log","else","r","除数","fatal"],"title":"在模板中使用条件判断(if)","title_tokens":["条件","判断","中","模板",")","在","if","(","使用"]},{"location":"Golang/Go-Web/03 AdvanceTemplateUsage/#_3","text":"eq ：当等式 arg1 == arg2 成立时，返回 true，否则返回 false ne ：当不等式 arg1 != arg2 成立时，返回 true，否则返回 false lt ：当不等式 arg1 < arg2 成立时，返回 true，否则返回 false le ：当不等式 arg1 <= arg2 成立时，返回 true，否则返回 false gt ：当不等式 arg1 > arg2 成立时，返回 true，否则返回 false ge ：当不等式 arg1 >= arg2 成立时，返回 true，否则返回 false package main import ( \"fmt\" \"log\" \"net/http\" \"text/template\" ) func main () { http . HandleFunc ( \"/\" , func ( w http . ResponseWriter , r * http . Request ) { tmpl , err := template . New ( \"test\" ). Parse ( ` {{$name1 := \"alice\"}} {{$name2 := \"bob\"}} {{$age1 := 18}} {{$age2 := 23}} {{if eq $age1 $age2}} 年龄相同 {{else}} 年龄不同 {{end}} {{if ne $name1 $name2}} 名字不相同 {{end}} ` ) if err != nil { fmt . Fprintf ( w , \"Parse: %v\" , err ) return } err = tmpl . Execute ( w , nil ) if err != nil { fmt . Fprintf ( w , \"Execute: %v\" , err ) return } }) log . Println ( \"Starting HTTP server...\" ) log . Fatal ( http . ListenAndServe ( \"localhost:8000\" , nil )) }","text_tokens":["\"","lt","不等式","*","v","new","false","return","bob","name1","age2","$","否则","end","http",")",",","err","starting","template","import","responsewriter","}","成立","listenandserve"," ",":","!","package","fprintf",">","fmt","...","request","test","返回","net","18","tmpl","(","ge","<","不等","等式","`","true","execute","时","=","不","eq","println","%",".","8000","main","server","，","alice","parse","arg1","：","当","名字","text","le","if","ne","/","gt","name2","不同","localhost","w","arg2","相同","23","{","handlefunc","age1","func","nil","log","else","r","fatal","年龄"],"title":"等式和不等式","title_tokens":["不等","不等式","和","等式"]},{"location":"Golang/Go-Web/03 AdvanceTemplateUsage/#range","text":"Go 语言中一般来说有三种类型可以进行迭代操作，数组（Array）、切片（Slice）和 map 类型 package main import ( \"fmt\" \"log\" \"net/http\" \"text/template\" ) func main () { http . HandleFunc ( \"/\" , func ( w http . ResponseWriter , r * http . Request ) { tmpl , err := template . New ( \"test\" ). Parse ( ` {{range $name := .Names}} {{$name}} {{end}} ` ) if err != nil { fmt . Fprintf ( w , \"Parse: %v\" , err ) return } err = tmpl . Execute ( w , map [ string ] interface {}{ \"Names\" : [] string { \"Alice\" , \"Bob\" , \"Carol\" , \"David\" , }, }) if err != nil { fmt . Fprintf ( w , \"Execute: %v\" , err ) return } }) log . Println ( \"Starting HTTP server...\" ) log . Fatal ( http . ListenAndServe ( \"localhost:8000\" , nil )) }","text_tokens":["\"","数组","carol","map","有","go","*","v","david","new","return","bob","、","$","end","http",")",",","err","starting","语言","template","import","responsewriter","}","listenandserve","）"," ",":","package","!","fprintf","fmt","（","...","request","test","中","来说","net","tmpl","(","一般来说","[","name","和","`","execute","=","println","%","三种",".","8000","main","]","切片","server","names","，","string","alice","parse","range","类型","text","一般","if","进行","/","可以","localhost","w","操作","interface","slice","迭代","{","array","handlefunc","func","nil","log","r","fatal"],"title":"迭代操作(range)","title_tokens":["迭代","range","操作","(",")"]},{"location":"Golang/Go-Web/03 AdvanceTemplateUsage/#_4","text":"... func main () { http . HandleFunc ( \"/\" , func ( w http . ResponseWriter , r * http . Request ) { // 创建模板对象并解析模板内容 tmpl , err := template . New ( \"test\" ). Parse ( ` {{range $i, $name := .Names}} {{$i}}. {{$name}} {{end}} ` ) ...","text_tokens":["\"",".","w"," ",":","main","内容","对象","创建","解析","...","*","i","request","names","new","test","parse","tmpl","(","range","$","end","{","模板","name","http","`",",",")","handlefunc","/","err","func","template","}","responsewriter","r","=","并"],"title":"获得迭代元素的索引","title_tokens":["的","迭代","获得","索引","元素"]},{"location":"Golang/Go-Web/03 AdvanceTemplateUsage/#map","text":"... func main () { http . HandleFunc ( \"/\" , func ( w http . ResponseWriter , r * http . Request ) { // 创建模板对象并解析模板内容 tmpl , err := template . New ( \"test\" ). Parse ( ` {{range $name, $val := .}} {{$name}}: {{$val}} {{end}} ` ) ... // 调用模板对象的渲染方法 err = tmpl . Execute ( w , map [ string ] interface {}{ \"Names\" : [] string { \"Alice\" , \"Bob\" , \"Carol\" , \"David\" , }, \"Numbers\" : [] int { 1 , 3 , 5 , 7 }, }) ... }","text_tokens":["\"",".","w"," ",":","1","渲染","carol","main","内容","对象","map","创建","]","解析","调用","...","*","val","request","names","david","new","test","string","interface","alice","parse","bob","int","tmpl","(","7","的","[","range","$","end","{","模板","name","5","http","`",",",")","handlefunc","/","err","func","template","execute","}","responsewriter","3","方法","r","=","numbers","并"],"title":"map类型","title_tokens":["map","类型"]},{"location":"Golang/Go-Web/03 AdvanceTemplateUsage/#with","text":"tmpl , err := template . New ( \"test\" ). Parse ( `Inventory {{with .Inventory}} SKU: {{.SKU}} Name: {{.Name}} UnitPrice: {{.UnitPrice}} Quantity: {{.Quantity}} {{end}} ` ) //****************************// err = tmpl . Execute ( w , map [ string ] interface {}{ \"Inventory\" : Inventory { // 类型 SKU : \"11000\" , Name : \"Phone\" , UnitPrice : 699.99 , Quantity : 666 , }, }) 用 {{with}} 来替代相关实例\" Inventory \".","text_tokens":["\"","666","来",".","w"," ",":","用","map","]","inventory","11000","*","with","new","test","string","interface","parse","替代","tmpl","(","相关","[","end","{","类型","name","699.99","`",")",",","unitprice","quantity","phone","/","err","template","execute","}","sku","实例","="],"title":"with","title_tokens":["with"]},{"location":"Golang/Go-Web/03 AdvanceTemplateUsage/#_5","text":"{{- 表示剔除模板内容 左侧 的所有空白符号, -}} 表示剔除模板内容 右侧 的所有空白符号. ... func main () { http . HandleFunc ( \"/\" , func ( w http . ResponseWriter , r * http . Request ) { // 创建模板对象并解析模板内容 tmpl , err := template . New ( \"test\" ). Parse ( `Inventory {{- with .Inventory}} SKU: {{.SKU}} Name: {{.Name}} UnitPrice: {{.UnitPrice}} Quantity: {{.Quantity}} {{- end}} ` ) ...","text_tokens":["\"","所有",".","w"," ",":","符号","main","内容","对象","创建","解析","inventory","表示","...","*","request","with","new","test","parse","tmpl","(","的","左侧","end","{","模板","name","http","`",",",")","handlefunc","unitprice","quantity","剔除","/","右侧","err","func","template","}","responsewriter","sku","r","并","=","-","空白"],"title":"空白符号处理","title_tokens":["符号","处理","空白"]},{"location":"Golang/Project/go-gin-example/01 Config/","text":"go-gin-example 01：配置 Golang 环境安装配置 下载 配置环境变量 文件配置 $ mkdir go-gin-example && cd go-gin-example $ go env -w GO111MODULE = on $ go env -w GOPROXY = https://goproxy.cn,direct $ go mod init [ MODULE_PATH ] $ ls > go.mod mkdir go-gin-example && cd go-gin-example ：创建并切换到项目目录。 go env -w GO111MUDOLE=on ：打开Go module 开关。 go env -w GOPROXY=... ：设置GOPROXY代理，第一个为七牛Go代理， direct 为Go在拉取模块遇到错误会回源到原模块版本的源地址去抓取。 go mod init [Module_Path] ：初始化Go module，产生go.mod文件 module go-gin-example go 1 .12 GOMODULE基础使用 go get ：拉取新的依赖 拉取最新的版本： go get golang/org/x/text@lastest 拉取 master 分支的最新commit： go get golang.org/x/text@master go tidy ：整理依","text_tokens":["回源","设置","lastest","org","golang","go","最新","地址","版本","源地址","原","gomodule","env","开关","$","cn","cd","on",",","依","-"," ",":","依赖",">","@","使用","...","commit","去","目录","会","example","的","[","get","x","01","整理","模块","module","mod","path","第一","错误","=","变量","代理","源地",".","1","创建","]","环境变量","goproxy","环境变","master","到","，","一个","init","配置","：","基础","分支","切换","产生","新","text","抓取","初始","12","初始化","go111mudole","tidy","安装","/","为七牛","第一个","&&","在","https","为","并","w","ls","项目","拉取","环境","direct","。","gin","_","打开","遇到","文件","go111module","mkdir","下载"],"title":"go-gin-example 01：配置","title_tokens":["example"," ","gin","01","配置","go","：","-"]},{"location":"Golang/Project/go-gin-example/01 Config/#go-gin-example-01","text":"","text_tokens":[],"title":"go-gin-example 01：配置","title_tokens":["example"," ","gin","01","配置","go","：","-"]},{"location":"Golang/Project/go-gin-example/01 Config/#golang","text":"","text_tokens":[],"title":"Golang 环境安装配置","title_tokens":["安装","环境"," ","golang","配置"]},{"location":"Golang/Project/go-gin-example/01 Config/#_1","text":"","text_tokens":[],"title":"下载","title_tokens":["下载"]},{"location":"Golang/Project/go-gin-example/01 Config/#_2","text":"","text_tokens":[],"title":"配置环境变量","title_tokens":["变量","环境","配置","环境变量","环境变"]},{"location":"Golang/Project/go-gin-example/01 Config/#_3","text":"$ mkdir go-gin-example && cd go-gin-example $ go env -w GO111MODULE = on $ go env -w GOPROXY = https://goproxy.cn,direct $ go mod init [ MODULE_PATH ] $ ls > go.mod mkdir go-gin-example && cd go-gin-example ：创建并切换到项目目录。 go env -w GO111MUDOLE=on ：打开Go module 开关。 go env -w GOPROXY=... ：设置GOPROXY代理，第一个为七牛Go代理， direct 为Go在拉取模块遇到错误会回源到原模块版本的源地址去抓取。 go mod init [Module_Path] ：初始化Go module，产生go.mod文件 module go-gin-example go 1 .12","text_tokens":["回源","设置","代理","源地",".","w"," ",":","1","ls","创建","]",">","goproxy","go","项目","错误","到","...","拉取","地址","，","一个","init","版本","direct","源地址","。","原","env","目录","去","gin","：","会","example","的","开关","_","[","$","cn","打开","cd","on","切换","产生","抓取","=","初始","为","初始化",",","go111mudole","模块","12","遇到","module","/","为七牛","文件","第一个","&&","go111module","mod","path","mkdir","第一","在","https","-","并"],"title":"文件配置","title_tokens":["文件","配置"]},{"location":"Golang/Project/go-gin-example/01 Config/#gomodule","text":"go get ：拉取新的依赖 拉取最新的版本： go get golang/org/x/text@lastest 拉取 master 分支的最新commit： go get golang.org/x/text@master go tidy ：整理依","text_tokens":["."," ","lastest","org","golang","依赖","@","go","master","最新","拉取","commit","版本","：","的","分支","get","新","x","text","整理","tidy","依","/"],"title":"GOMODULE基础使用","title_tokens":["gomodule","基础","使用"]},{"location":"Golang/Project/go-gin-example/02 API-1/","text":"go-gin-example 02：API-1 初始设置 项目目录 go-gin-example/ ├─conf ├─middleware ├─models ├─pkg ├─routers └─runtime conf：用于存储配置文件 middleware：应用中间件 models：应用数据库模型 pkg：第三方包 routers：路由逻辑处理 runtime：应用运行时数据 添加Go Modules Replace配置本地模块路径 （好像不必要） module go - gin - example go 1.12 require ( ··· ) replace ( . / go - gin - example / conf => . / go - gin - example / pkg / conf . / go - gin - example / middleware => . / go - gin - example / middleware . / go - gin - example / models => . / go - gin - example / models . / go - gin - example / pkg / e => . / go - gin - example / pkg / e . / go - gin - example / pkg / setting => . / go - gin - example / pkg / setting . / go - gin - example / pkg / util => . / go - gin - example / pkg / util . / go - gin - example / routers => . / go - gin - example / routers ) # 用 replace 将其指定读取本地的模块路径 ， 这样子就可以解决本地模块读取的问题 使用ini配置文件库/编写项目配置包 应用配置文件 将公共配置部分提取出来，写成专门的配置文件，统一写数据库环境、服务器环境等。 在 ./conf 目录下新建 app.ini 文件 定义RUN_MODE 定义数据库端口、账号、表格等 定义公共参数：分页 定义服务器端口、TIMEOUT时间等 # debug or release RUN_MODE = debug [app] PAGE_SIZE = 10 JWT_SECRET = 23347$040412 [server] HTTP_PORT = 8000 READ_TIMEOUT = 60 WRITE_TIMEOUT = 60 [database] TYPE = mysql USER = root # 数据库账号 PASSWORD = root # 数据库密码 HOST = 127.0.0.1:3306 # 数据库IP:数据库端口号 NAME = blog TABLE_PREFIX = blog_ 调用配置的setting模块 负责调用app.ini go get -u github.com/go-ini/ini 在 ./pkg/setting 目录下新建 setting.go 文件 package setting import ( \"log\" \"time\" \"github.com/go-ini/ini\" ) var ( Cfg * ini . File // Cfg为ini文件类型 // 声明app.ini文件写好的各种配置的类型 RunMode string HTTPPort int ReadTimeout time . Duration WriteTimeout time . Duration PageSize int JwtSecret string ) func init () { var err error // 加载初始化文件 Cfg , err = ini . Load ( \"conf/app.ini\" ) if err != nil { log . Fatalf ( \"Fail to parse 'conf/app.ini`: %v\" , err ) } LoadBase () LoadServer () LoadApp () } // 加载基础设置 func LoadBase () { // 设置RUN_MODE为'debug' RunMode = Cfg . Section ( \"\" ). Key ( \"RUN_MODE\" ). MustString ( \"debug\" ) } // LoadServer 加载服务器配置 func LoadServer () { // 获取'server'的section信息 // 这里的section包含'server'的各种信息, 由./config/app,ini配置文件提供 sec , err := Cfg . GetSection ( \"server\" ) if err != nil { log . Fatalf ( \"Fail to get section 'server':%v\" , err ) } RunMode = Cfg . Section ( \"\" ). Key ( \"RUN_MODE\" ). MustString ( \"debug\" ) // 自动类型转换 HTTPPort = sec . Key ( \"HTTP_PORT\" ). MustInt ( 8000 ) ReadTimeout = time . Duration ( sec . Key ( \"READ_TIMEOUT\" ). MustInt ( 60 )) * time . Second WriteTimeout = time . Duration ( sec . Key ( \"WRITE_TIMEOUT\" ). MustInt ( 60 )) * time . Second } // LoadApp 加载APP配置 func LoadApp () { // 获取./config/app.ini配置文件的APP配置 sec , err := Cfg . GetSection ( \"app\" ) if err != nil { log . Fatalf ( \"Fail to get section 'app':%v\" , err ) } JwtSecret = sec . Key ( \"JWT_SECRET\" ). MustString ( \"!@)*#)!@U#@*!@!)\" ) PageSize = sec . Key ( \"PAGE_SIZE\" ). MustInt ( 10 ) } API错误码包 建立错误码e模块 在 ./pkg/e 目录下新建 code.go 和 msg.go 文件 code.go package e // API错误代码 const ( SUCCESS = 200 ERROR = 500 INVALID_PARAMS = 400 ERROR_EXIST_TAG = 10001 ERROR_NOT_EXIST_TAG = 10002 ERROR_NOT_EXIST_ARTICLE = 10003 ERROR_AUTH_CHECK_TOKEN_FAIL = 20001 ERROR_AUTH_CHECK_TOKEN_TIMEOUT = 20002 ERROR_AUTH_TOKEN = 20003 ERROR_AUTH = 20004 ) msg.go package e //msg.go // MsgFlags 错误信息 var MsgFlags = map [ int ] string { SUCCESS : \"ok\" , ERROR : \"fail\" , INVALID_PARAMS : \"请求参数错误\" , ERROR_EXIST_TAG : \"已存在该标签名称\" , ERROR_NOT_EXIST_TAG : \"该标签不存在\" , ERROR_NOT_EXIST_ARTICLE : \"该文章不存在\" , ERROR_AUTH_CHECK_TOKEN_FAIL : \"Token鉴权失败\" , ERROR_AUTH_CHECK_TOKEN_TIMEOUT : \"Token鉴权超时\" , ERROR_AUTH_TOKEN : \"Token生成失败\" , ERROR_AUTH : \"Token错误\" , } // GetMsg 获取错误信息 func GetMsg ( code int ) string { msg , ok := MsgFlags [ code ] if ok { return msg } return MsgFlags [ ERROR ] } 工具包 公共方法：例如获取分页页码等 go get -u github.com/unknwon/com 在 ./pkg/util 目录下新建 pagination.go 文件 package util import ( setting \"go-gin-example/pkg/settings\" \"github.com/gin-gonic/gin\" \"github.com/unknwon/com\" ) // GetPage 获取page数量 func GetPage ( c * gin . Context ) int { result := 0 // page转换为int page , _ := com . StrTo ( c . Query ( \"page\" )). Int () if page > 0 { result = ( page - 1 ) * setting . PageSize } return result } 数据库模型映射 通过gorm将golang结构体映射到数据库中自动生成模型 go get -u github.com/jinzhu/gorm go get -u github.com/go-sql-driver/mysql 在 ./models 目录下新建 models.go 文件。 package models import ( \"fmt\" setting \"go-gin-example/pkg/settings\" \"log\" \"github.com/jinzhu/gorm\" ) var db * gorm . DB // Model 数据库模型 type Model struct { ID int `gorm:\"primary_key\" json:id` CreatedOn int `json:\"created_on\"` ModifiedOn int `json:\"modified_on\"` } func init () { var ( err error dbType , dbName , user , password , host , tablePrefix string ) // 获取配置文件的数据库配置 sec , err := setting . Cfg . GetSection ( \"database\" ) if err != nil { log . Fatal ( 2 , \"Fail to get get scetion `database`:%v\" , err ) } dbType = sec . Key ( \"TYPE\" ). String () dbName = sec . Key ( \"NAME\" ). String () user = sec . Key ( \"USER\" ). String () password = sec . Key ( \"PASSWORD\" ). String () host = sec . Key ( \"HOST\" ). String () tablePrefix = sec . Key ( \"TABLE_PREFIX\" ). String () db , err = gorm . Open ( dbtype , fmt . Sprintf ( \"%s:%s@tcp(%s)/%s?charset=utf8&parseTime=True&loc=Local\" , user , password , dbName )) if err != nil { log . Println ( err ) } gorm . DefaultTableNameHandler = func ( db * gorm . DB , defaultTableName string ) string { return tablePrefix + defaultTableName } db . SingularTable ( true ) db . LogMode ( true ) db . DB (). SetMaxIdleConns ( 10 ) db . DB (). SetMaxOpenConns ( 100 ) } // CloseDB 关闭数据库连接 func CloseDB () { defer db . Close () } Demo 实例程序 在 ./ 目录下新建 main.go 文件 package main import ( \"fmt\" setting \"go-gin-example/pkg/settings\" \"net/http\" \"github.com/gin-gonic/gin\" ) func main () { router := gin . Default () router . GET ( \"/test\" , func ( c * gin . Context ) { c . JSON ( 200 , gin . H { \"message\" : \"test\" , }) }) s := & http . Server { Addr : fmt . Sprintf ( \":%d\" , setting . HTTPPort ), Handler : router , ReadTimeout : setting . ReadTimeout , WriteTimeout : setting . WriteTimeout , MaxHeaderBytes : 1 << 20 , } // 调用在&http.Server中设置的参数,因此上面要用&,要改变参数的值 s . ListenAndServe () } 浏览器输入 localhost：8000/test 返回 {\"message\":\"test\"} 则成功 从main.go中分离路由 在 ./routers 目录下新建 router.go 文件 package routers import ( setting \"go-gin-example/pkg/settings\" \"github.com/gin-gonic/gin\" ) func InitRouter () * gin . Engine { r := gin . New () r . Use ( gin . Logger ()) r . Use ( gin . Recovery ()) gin . SetMode ( setting . RunMode ) r . GET ( \"/test\" , func ( c * gin . Context ) { c . JSON ( 200 , gin . H { \"message\" : \"test\" , }) }) return r } 修改 main.go 文件 package main import ( \"fmt\" setting \"go-gin-example/pkg/settings\" \"go-gin-example/routers\" \"net/http\" ) func main () { router := routers . InitRouter () s := & http . Server { Addr : fmt . Sprintf ( \":%d\" , setting . HTTPPort ), Handler : router , ReadTimeout : setting . ReadTimeout , WriteTimeout : setting . WriteTimeout , MaxHeaderBytes : 1 << 20 , } s . ListenAndServer () } 当前目录结构 go-gin-example/ ├── conf │ └── app.ini ├── main.go ├── middleware ├── models │ └── models.go ├── pkg │ ├── e │ │ ├── code.go │ │ └── msg.go │ ├── setting │ │ └── setting.go │ └── util │ └── pagination.go ├── routers │ └── router.go ├── runtime","text_tokens":["生成","golang","转换","据库","*","v","demo","10","60","logger","应用","return","10001","msg","处理","要","or","local","type",",","utf8","映射","口号","├"," ","20002","当前目录","!","要用","json","就","返回","default","conf","(","包","第三","自动","浏览器","models","误码","getsection","错误","%","当前","main","unknwon","server","分页","read","parse","文件类型","pkg","u","：","modules","端口","muststring","msgflags","建立","040412","通过","load","scetion","将","if","/","cfg","不必","replace","tag","存在","账号","closedb","writetimeout","write","问题","code","运行","200","release","请求","写","专门","存储配置","程序","pagination","routers","配置文件","nil","getpage","体","r","中间","&","host","服务器","由","recovery","timeout","添加","duration","服务器端","loc","d","createdon",")","10002","代码","sec","获取","包含","}","修改","-","已","）","标签",">","使用","好","gorm","test","页码","get","name","e","ip","定义","module","true","jwtsecret","实例","服务","负责","listenandserver","db","1",".","出来","setmaxopenconns","jwt","路由","到","ini","section","config","基础","10003","初始","初始化","second","指定","result","dbname","这","分离","100","各种","file","为","query","model","错误码","2","统一","addr","结构","该","use","上面","message","类型转换","因此","singulartable","exist","readtimeout","sql","{","sprintf","连接","改变","created","modified","下","fatal","存储","go","写成","invalid","400","误信","1.12","new","数量","defaulttablenamehandler","engine","defer","文章","'","好像","success","c","router","$","样子","var","time","mysql","声明","务器","err","20","table","鉴权","listenandserve","公共","加载","@","（","id","0","关闭","调用","settings","params","名称","目录","net","github","gonic","的","[","编写","数据","提供","`","maxheaderbytes","模块","primary","?","输入","struct","to","context","模型","loadbase","必要","库","]","02","例如","其","run","│","string","init","pagesize","端口号","close","port","参数","类型","第三方","└","tcp","s","新建","localhost","loadapp","logmode","用于","。","中间件","gin","三方","auth","127.0","fail","strto","逻辑","prefix","数据库","log","#","方法","\"","设置","database","500","用","map","app","setting","middleware","int","工具","open","page","密码","、","on","从","http","require","20003","user","import","错误代码","等","错误信息","解决",":","setmaxidleconns","package","blog","工具包","token","fmt","password","中","util","charset","·","httpport","key","example","<","dbtype","getmsg","和","defaulttablename","mode","则","tableprefix","initrouter","root","setmode","时","提取","20001","ok","modifiedon","=","不","println","8000","article","信息","+","handler","时间","读取","这里","，","20004","api","secret","3306","配置","路径","jinzhu","口","0.1","const","浏览","失败","可以","表格","parsetime","debug","部分","在","check","值","mustint","项目","loadserver","runtime","环境","error","成功","不必要","_","com","23347","本地","size","runmode","超时","文件","fatalf","func","h","driver","not","─"],"title":"go-gin-example 02：API-1","title_tokens":["example","02","1"," ","gin","api","go","：","-"]},{"location":"Golang/Project/go-gin-example/02 API-1/#go-gin-example-02api-1","text":"初始设置","text_tokens":["设置","初始"],"title":"go-gin-example 02：API-1","title_tokens":["example","02","1"," ","gin","api","go","：","-"]},{"location":"Golang/Project/go-gin-example/02 API-1/#_1","text":"go-gin-example/ ├─conf ├─middleware ├─models ├─pkg ├─routers └─runtime conf：用于存储配置文件 middleware：应用中间件 models：应用数据库模型 pkg：第三方包 routers：路由逻辑处理 runtime：应用运行时数据","text_tokens":["中间","├"," ","模型","存储","路由","go","runtime","据库","用于","中间件","middleware","应用","conf","pkg","配置","gin","：","运行","处理","包","example","三方","数据","第三","models","存储配置","第三方","/","routers","文件","逻辑","└","数据库","时","-","─"],"title":"项目目录","title_tokens":["目录","项目"]},{"location":"Golang/Project/go-gin-example/02 API-1/#go-modules-replace","text":"module go - gin - example go 1.12 require ( ··· ) replace ( . / go - gin - example / conf => . / go - gin - example / pkg / conf . / go - gin - example / middleware => . / go - gin - example / middleware . / go - gin - example / models => . / go - gin - example / models . / go - gin - example / pkg / e => . / go - gin - example / pkg / e . / go - gin - example / pkg / setting => . / go - gin - example / pkg / setting . / go - gin - example / pkg / util => . / go - gin - example / pkg / util . / go - gin - example / routers => . / go - gin - example / routers ) # 用 replace 将其指定读取本地的模块路径 ， 这样子就可以解决本地模块读取的问题","text_tokens":["replace",".","解决"," ","用",">","读取","go","其","就","1.12","，","setting","util","middleware","·","conf","pkg","(","gin","路径","问题","example","的","本地","e","require","将","样子",")","models","模块","module","/","routers","可以","指定","这","#","=","-"],"title":"添加Go Modules Replace配置本地模块路径 （好像不必要）","title_tokens":["（","）","replace"," ","本地","配置","添加","不必","go","路径","模块","好像","必要","modules","不必要"]},{"location":"Golang/Project/go-gin-example/02 API-1/#ini","text":"","text_tokens":[],"title":"使用ini配置文件库/编写项目配置包","title_tokens":["/","文件","ini","配置文件","编写","配置","库","项目","包","使用"]},{"location":"Golang/Project/go-gin-example/02 API-1/#_2","text":"将公共配置部分提取出来，写成专门的配置文件，统一写数据库环境、服务器环境等。 在 ./conf 目录下新建 app.ini 文件 定义RUN_MODE 定义数据库端口、账号、表格等 定义公共参数：分页 定义服务器端口、TIMEOUT时间等 # debug or release RUN_MODE = debug [app] PAGE_SIZE = 10 JWT_SECRET = 23347$040412 [server] HTTP_PORT = 8000 READ_TIMEOUT = 60 WRITE_TIMEOUT = 60 [database] TYPE = mysql USER = root # 数据库账号 PASSWORD = root # 数据库密码 HOST = 127.0.0.1:3306 # 数据库IP:数据库端口号 NAME = blog TABLE_PREFIX = blog_","text_tokens":["database","host","服务器","写成","据库","10","app","60","timeout","page","服务器端","密码","or","、","$","http","type","mysql","务器","user","table","口号","等"," ",":","公共","blog","password","目录","conf","的","[","数据","name","ip","定义","mode","root","提取","服务","=",".","出来","8000","jwt","时间","]","server","run","ini","分页","，","read","secret","3306","端口号","配置","：","port","端口","040412","口","参数","0.1","将","/","表格","debug","部分","在","新建","统一","账号","环境","。","write","release","_","23347","写","size","专门","127.0","文件","prefix","配置文件","下","数据库","#"],"title":"应用配置文件","title_tokens":["应用","配置文件","配置","文件"]},{"location":"Golang/Project/go-gin-example/02 API-1/#setting","text":"负责调用app.ini go get -u github.com/go-ini/ini 在 ./pkg/setting 目录下新建 setting.go 文件 package setting import ( \"log\" \"time\" \"github.com/go-ini/ini\" ) var ( Cfg * ini . File // Cfg为ini文件类型 // 声明app.ini文件写好的各种配置的类型 RunMode string HTTPPort int ReadTimeout time . Duration WriteTimeout time . Duration PageSize int JwtSecret string ) func init () { var err error // 加载初始化文件 Cfg , err = ini . Load ( \"conf/app.ini\" ) if err != nil { log . Fatalf ( \"Fail to parse 'conf/app.ini`: %v\" , err ) } LoadBase () LoadServer () LoadApp () } // 加载基础设置 func LoadBase () { // 设置RUN_MODE为'debug' RunMode = Cfg . Section ( \"\" ). Key ( \"RUN_MODE\" ). MustString ( \"debug\" ) } // LoadServer 加载服务器配置 func LoadServer () { // 获取'server'的section信息 // 这里的section包含'server'的各种信息, 由./config/app,ini配置文件提供 sec , err := Cfg . GetSection ( \"server\" ) if err != nil { log . Fatalf ( \"Fail to get section 'server':%v\" , err ) } RunMode = Cfg . Section ( \"\" ). Key ( \"RUN_MODE\" ). MustString ( \"debug\" ) // 自动类型转换 HTTPPort = sec . Key ( \"HTTP_PORT\" ). MustInt ( 8000 ) ReadTimeout = time . Duration ( sec . Key ( \"READ_TIMEOUT\" ). MustInt ( 60 )) * time . Second WriteTimeout = time . Duration ( sec . Key ( \"WRITE_TIMEOUT\" ). MustInt ( 60 )) * time . Second } // LoadApp 加载APP配置 func LoadApp () { // 获取./config/app.ini配置文件的APP配置 sec , err := Cfg . GetSection ( \"app\" ) if err != nil { log . Fatalf ( \"Fail to get section 'app':%v\" , err ) } JwtSecret = sec . Key ( \"JWT_SECRET\" ). MustString ( \"!@)*#)!@U#@*!@!)\" ) PageSize = sec . Key ( \"PAGE_SIZE\" ). MustInt ( 10 ) }","text_tokens":["\"","设置","转换","go","服务器","*","v","10","由","app","setting","60","timeout","int","'","duration","page","http",")","var","time","声明",",","务器","err","sec","获取","包含","import","}","-"," ",":","package","!","加载","@","好","调用","目录","httpport","conf","(","key","github","的","get","提供","自动","`","mode","jwtsecret","getsection","服务","=","负责","%",".","8000","to","信息","jwt","loadbase","server","run","ini","这里","section","string","init","read","pagesize","secret","parse","文件类型","pkg","配置","u","port","config","muststring","基础","load","类型","初始","初始化","if","second","/","cfg","debug","在","新建","各种","为","file","loadapp","mustint","loadserver","类型转换","writetimeout","error","write","readtimeout","_","com","写","size","runmode","{","fail","文件","fatalf","func","下","配置文件","nil","log","#"],"title":"调用配置的setting模块","title_tokens":["调用","的","setting","配置","模块"]},{"location":"Golang/Project/go-gin-example/02 API-1/#api","text":"建立错误码e模块 在 ./pkg/e 目录下新建 code.go 和 msg.go 文件 code.go package e // API错误代码 const ( SUCCESS = 200 ERROR = 500 INVALID_PARAMS = 400 ERROR_EXIST_TAG = 10001 ERROR_NOT_EXIST_TAG = 10002 ERROR_NOT_EXIST_ARTICLE = 10003 ERROR_AUTH_CHECK_TOKEN_FAIL = 20001 ERROR_AUTH_CHECK_TOKEN_TIMEOUT = 20002 ERROR_AUTH_TOKEN = 20003 ERROR_AUTH = 20004 ) msg.go package e //msg.go // MsgFlags 错误信息 var MsgFlags = map [ int ] string { SUCCESS : \"ok\" , ERROR : \"fail\" , INVALID_PARAMS : \"请求参数错误\" , ERROR_EXIST_TAG : \"已存在该标签名称\" , ERROR_NOT_EXIST_TAG : \"该标签不存在\" , ERROR_NOT_EXIST_ARTICLE : \"该文章不存在\" , ERROR_AUTH_CHECK_TOKEN_FAIL : \"Token鉴权失败\" , ERROR_AUTH_CHECK_TOKEN_TIMEOUT : \"Token鉴权超时\" , ERROR_AUTH_TOKEN : \"Token生成失败\" , ERROR_AUTH : \"Token错误\" , } // GetMsg 获取错误信息 func GetMsg ( code int ) string { msg , ok := MsgFlags [ code ] if ok { return msg } return MsgFlags [ ERROR ] }","text_tokens":["\"","生成","500","map","go","invalid","400","误信","timeout","return","int","10001","文章","msg","success",")","var",",","10002","代码","获取","20003","}","错误代码","鉴权","已","错误信息"," ",":","标签","20002","package","token","params","名称","目录","(","[","getmsg","e","和","模块","误码","20001","ok","错误","=","不",".","article","信息","]","20004","api","string","pkg","msgflags","建立","10003","参数","const","if","失败","/","在","新建","check","错误码","tag","存在","该","error","code","200","exist","_","请求","auth","{","超时","fail","文件","func","下","not"],"title":"API错误码包","title_tokens":["误码","错误码","api","错误","包"]},{"location":"Golang/Project/go-gin-example/02 API-1/#_3","text":"公共方法：例如获取分页页码等 go get -u github.com/unknwon/com 在 ./pkg/util 目录下新建 pagination.go 文件 package util import ( setting \"go-gin-example/pkg/settings\" \"github.com/gin-gonic/gin\" \"github.com/unknwon/com\" ) // GetPage 获取page数量 func GetPage ( c * gin . Context ) int { result := 0 // page转换为int page , _ := com . StrTo ( c . Query ( \"page\" )). Int () if page > 0 { result = ( page - 1 ) * setting . PageSize } return result }","text_tokens":["\"","query",".","1"," ",":","context","unknwon","公共","package",">","例如","go","转换","0","*","settings","分页","数量","setting","util","pagesize","目录","return","pkg","int","u","(","：","gin","page","github","gonic","example","c","_","com","页码","get","{",")",",","strto","if","pagination","/","文件","result","func","下","获取","getpage","import","}","方法","在","=","新建","-","等","为"],"title":"工具包","title_tokens":["工具","工具包"]},{"location":"Golang/Project/go-gin-example/02 API-1/#_4","text":"通过gorm将golang结构体映射到数据库中自动生成模型 go get -u github.com/jinzhu/gorm go get -u github.com/go-sql-driver/mysql 在 ./models 目录下新建 models.go 文件。 package models import ( \"fmt\" setting \"go-gin-example/pkg/settings\" \"log\" \"github.com/jinzhu/gorm\" ) var db * gorm . DB // Model 数据库模型 type Model struct { ID int `gorm:\"primary_key\" json:id` CreatedOn int `json:\"created_on\"` ModifiedOn int `json:\"modified_on\"` } func init () { var ( err error dbType , dbName , user , password , host , tablePrefix string ) // 获取配置文件的数据库配置 sec , err := setting . Cfg . GetSection ( \"database\" ) if err != nil { log . Fatal ( 2 , \"Fail to get get scetion `database`:%v\" , err ) } dbType = sec . Key ( \"TYPE\" ). String () dbName = sec . Key ( \"NAME\" ). String () user = sec . Key ( \"USER\" ). String () password = sec . Key ( \"PASSWORD\" ). String () host = sec . Key ( \"HOST\" ). String () tablePrefix = sec . Key ( \"TABLE_PREFIX\" ). String () db , err = gorm . Open ( dbtype , fmt . Sprintf ( \"%s:%s@tcp(%s)/%s?charset=utf8&parseTime=True&loc=Local\" , user , password , dbName )) if err != nil { log . Println ( err ) } gorm . DefaultTableNameHandler = func ( db * gorm . DB , defaultTableName string ) string { return tablePrefix + defaultTableName } db . SingularTable ( true ) db . LogMode ( true ) db . DB (). SetMaxIdleConns ( 10 ) db . DB (). SetMaxOpenConns ( 100 ) } // CloseDB 关闭数据库连接 func CloseDB () { defer db . Close () }","text_tokens":["\"","&","database","host","生成","golang","go","据库","*","v","10","defaulttablenamehandler","setting","return","int","defer","open","loc","on","createdon","local",")","var","type","mysql",",","utf8","err","sec","获取","映射","import","}","user","table","-"," ",":","setmaxidleconns","package","!","fmt","id","json","@","关闭","settings","gorm","password","中","charset","目录","(","key","github","example","的","dbtype","get","数据","自动","name","`","models","defaulttablename","primary","tableprefix","?","true","getsection","modifiedon","=","struct","db","println","%",".","+","to","setmaxopenconns","模型","到","init","string","pkg","配置","u","close","jinzhu","通过","scetion","将","if","/","dbname","parsetime","tcp","cfg","s","100","在","新建","model","2","logmode","结构","closedb","singulartable","。","error","gin","sql","com","_","{","sprintf","连接","fail","created","modified","文件","prefix","func","下","配置文件","nil","数据库","体","log","driver","fatal"],"title":"数据库模型映射","title_tokens":["据库","数据库","数据","映射","模型"]},{"location":"Golang/Project/go-gin-example/02 API-1/#demo","text":"实例程序 在 ./ 目录下新建 main.go 文件 package main import ( \"fmt\" setting \"go-gin-example/pkg/settings\" \"net/http\" \"github.com/gin-gonic/gin\" ) func main () { router := gin . Default () router . GET ( \"/test\" , func ( c * gin . Context ) { c . JSON ( 200 , gin . H { \"message\" : \"test\" , }) }) s := & http . Server { Addr : fmt . Sprintf ( \":%d\" , setting . HTTPPort ), Handler : router , ReadTimeout : setting . ReadTimeout , WriteTimeout : setting . WriteTimeout , MaxHeaderBytes : 1 << 20 , } // 调用在&http.Server中设置的参数,因此上面要用&,要改变参数的值 s . ListenAndServe () } 浏览器输入 localhost：8000/test 返回 {\"message\":\"test\"} 则成功","text_tokens":["\"","设置","&","go","*","setting","要","c","router","d","http",")",",","import","}","20","-","listenandserve"," ",":","package","要用","fmt","json","调用","settings","test","返回","中","目录","net","default","httpport","(","github","gonic","example","<","的","get","浏览器","maxheaderbytes","则","实例","输入","=","%",".","1","8000","context","handler","main","server","pkg","：","参数","浏览","/","s","在","新建","localhost","值","addr","上面","message","因此","writetimeout","成功","gin","200","readtimeout","com","{","sprintf","改变","程序","文件","func","下","h"],"title":"Demo","title_tokens":["demo"]},{"location":"Golang/Project/go-gin-example/02 API-1/#maingo","text":"在 ./routers 目录下新建 router.go 文件 package routers import ( setting \"go-gin-example/pkg/settings\" \"github.com/gin-gonic/gin\" ) func InitRouter () * gin . Engine { r := gin . New () r . Use ( gin . Logger ()) r . Use ( gin . Recovery ()) gin . SetMode ( setting . RunMode ) r . GET ( \"/test\" , func ( c * gin . Context ) { c . JSON ( 200 , gin . H { \"message\" : \"test\" , }) }) return r } 修改 main.go 文件 package main import ( \"fmt\" setting \"go-gin-example/pkg/settings\" \"go-gin-example/routers\" \"net/http\" ) func main () { router := routers . InitRouter () s := & http . Server { Addr : fmt . Sprintf ( \":%d\" , setting . HTTPPort ), Handler : router , ReadTimeout : setting . ReadTimeout , WriteTimeout : setting . WriteTimeout , MaxHeaderBytes : 1 << 20 , } s . ListenAndServer () }","text_tokens":["\"","%","&",".","1"," ",":","context","handler","main","package","use","addr","fmt","go","json","server","message","*","settings","recovery","new","test","setting","engine","logger","writetimeout","目录","return","net","pkg","httpport","(","gin","github","gonic","example","c","200","readtimeout","com","<","router","get","runmode","{","d","sprintf","http","maxheaderbytes",")",",","/","routers","文件","func","下","initrouter","h","setmode","import","}","20","修改","r","s","在","=","新建","-","listenandserver"],"title":"从main.go中分离路由","title_tokens":[".","中","分离","main","从","路由","go"]},{"location":"Golang/Project/go-gin-example/02 API-1/#_5","text":"go-gin-example/ ├── conf │ └── app.ini ├── main.go ├── middleware ├── models │ └── models.go ├── pkg │ ├── e │ │ ├── code.go │ │ └── msg.go │ ├── setting │ │ └── setting.go │ └── util │ └── pagination.go ├── routers │ └── router.go ├── runtime","text_tokens":["├","."," ","main","go","runtime","│","ini","app","setting","util","middleware","conf","pkg","gin","code","msg","example","router","e","models","pagination","/","routers","└","-","─"],"title":"当前目录结构","title_tokens":["当前","结构","目录","当前目录"]},{"location":"Golang/Project/go-gin-example/03 API-2/","text":"go-gin-example 03：API-2 完成博客的标签类接口定义和编写 定义接口 定义文章标签的路由分发操作 获取标签列表：GET(“/tags”) 新建标签：POST(“/tags”) 更新指定标签：PUT(“/tags/:id”) 删除指定标签：DELETE(“/tags/:id”) 空壳路由 注册路由将请求分发到该路由中，由该API路由中函数处理 在./routers/api 下新建 v1 目录，目录内新建 tag.go 文件代表第一个API大版本 package v1 import ( \"github.com/gin-gonic/gin\" ) // GetTags 获取多个文章标签 func GetTags ( c * gin . Context ) { } // AddTag 新增文章标签 func AddTag ( c * gin . Context ) { } // EditTag 修改文章标签 func EditTag ( c * gin . Context ) { } // DeleteTag 删除文章标签 func DeleteTag ( c * gin . Context ) { } 注册路由 该路由负责分发各个api请求给相应的 handler 者 打开 ./routers 下的 router.go 文件，修改为： package routers import ( setting \"go-gin-example/pkg/settings\" v1 \"go-gin-example/routers/api/v1\" \"github.com/gin-gonic/gin\" ) // InitRouter 初始化路由 func InitRouter () * gin . Engine { r := gin . New () r . Use ( gin . Logger ()) r . Use ( gin . Recovery ()) gin . SetMode ( setting . RunMode ) apiv1 := r . Group ( \"/api/v1\" ) { apiv1 . GET ( \"/tags\" , v1 . GetTags ) apiv1 . POST ( \"/tags\" , v1 . AddTag ) apiv1 . PUT ( \"/tags/:id\" , v1 . EditTag ) apiv1 . DELETE ( \"/tags/:id\" , v1 . DeleteTag ) } return r } 用 go run main.go 检测是否成功注册路由 表单验证 用beego的validation来进行表单校验数据 该 tag.go 模型中继承了 model.Model 结构体外新增了标签结构体中的一些属性，在该文件下除了通过 gorm 映射数据库模型外还添加了对标签的CRUD操作方法，在 ./routers/api/v1/tag.go 中可以调用这些CRUD方法 go get -u github.com/astaxie/beego/validation 在 models 目录下的 tag.go 写入 package models import ( \"time\" \"github.com/jinzhu/gorm\" ) // Tag 标签结构体 // 给结构体赋予json属性, 在c.JSON中会自动转换 type Tag struct { // 继承Model的结构体 Model Name string `json:\"name\"` CreatedBy string `json:\"created_by\"` ModifiedBy string `json:\"modified_by\"` State int `json:\"state\"` } // BeforeCreate 创建标签之前自动补全CreatedOn时间 func ( tag * Tag ) BeforeCreate ( scope * gorm . Scope ) error { scope . SetColumn ( \"CreatedOn\" , time . Now (). Unix ()) return nil } // BeforeUpdate 更新标签之前自动补全ModifiedOn时间 func ( tag * Tag ) BeforeUpdate ( scope * gorm . Scope ) error { scope . SetColumn ( \"ModifiedOn\" , time . Now (). Unix ()) return nil } // GetTags 获取文章标签 func GetTags ( pageNum int , pageSize int , maps interface {}) ( tags [] Tag ) { db . Where ( maps ). Offset ( pageNum ). Limit ( pageSize ). Find ( & tags ) return } // GetTagTotal 获取全部文章标签 func GetTagTotal ( maps interface {}) ( count int ) { db . Model ( & Tag {}). Where ( maps ). Count ( & count ) return } // ExistTagByName 查询文章标签是否存在 func ExistTagByName ( name string ) bool { var tag Tag db . Select ( \"id\" ). Where ( \"name = ?\" , name ). First ( & tag ) if tag . ID > 0 { return true } return false } // ExistTagByID 查询ID文章是否存在 func ExistTagByID ( id int ) bool { var tag Tag db . Select ( \"id\" ). Where ( \"id = ?\" , id ). First ( & tag ) if tag . ID > 0 { return true } return false } // AddTag 添加文章标签 func AddTag ( name string , state int , createdBy string ) bool { db . Create ( & Tag { Name : name , State : state , CreatedBy : createdBy , }) return true } // DeleteTag 删除文章标签 func DeleteTag ( id int ) bool { db . Where ( \"id = ? \" , id ). Delete ( & Tag {}) return true } // EditTag 编辑文章标签 func EditTag ( id int , data interface {}) bool { db . Model ( & Tag {}). Where ( \"id = ? \" , id ). Update ( data ) return true } 编写标签列表的路由逻辑 完善空壳路由 通过 beego/validation 对URL传递进来的参数进行校验，操作为声明 validation.Validation 对象，调用其 .Required 、 .MaxSize 、 .Range 、 .Message 等方法 通过 c.Query 获取URL中 ?name=test&state=1 中的参数， c.DefaultQuery 则支持设置一个默认值 util.GetPage 确保各个接口的 page 处理是一致的 在 ./routers/v1/tag.go 写入 package v1 import ( \"go-gin-example/models\" \"go-gin-example/pkg/e\" setting \"go-gin-example/pkg/settings\" \"go-gin-example/pkg/util\" \"net/http\" \"github.com/astaxie/beego/validation\" \"github.com/gin-gonic/gin\" \"github.com/unknwon/com\" ) // GetTags 获取文章标签 func GetTags ( c * gin . Context ) { // 从URL获取参数 // localhost:8000/tags?name=test&state=1 name := c . Query ( \"name\" ) maps := make ( map [ string ] interface {}) data := make ( map [ string ] interface {}) if name != \"\" { // 如果存在name参数, 将其添加到maps中 maps [ \"name\" ] = name } var state = - 1 // should omit type , it will be inferred if arg := c . Query ( \"state\" ); arg != \"\" { // 如果URL中存在state参数, 且arg不等于空的时候 // 将state转换为int // 添加到maps[\"state\"]中 state = com . StrTo ( arg ). MustInt () maps [ \"state\" ] = state } code := e . SUCCESS // 找到该文章,将其添加到lists中返回 data [ \"lists\" ] = models . GetTags ( util . GetPage ( c ), setting . PageSize , maps ) data [ \"total\" ] = models . GetTagTotal ( maps ) c . JSON ( http . StatusOK , gin . H { \"code\" : code , \"msg\" : e . GetMsg ( code ), \"data\" : data , }) } // AddTag 增加文章标签 func AddTag ( c * gin . Context ) { name := c . Query ( \"name\" ) // state=0代表该标签不存在 // 设置默认值为0 state := com . StrTo ( c . DefaultQuery ( \"state\" , \"0\" )). MustInt () createdBy := c . Query ( \"created_by\" ) valid := validation . Validation {} valid . Required ( name , \"name\" ). Message ( \"名称不能为空\" ) valid . MaxSize ( name , 100 , \"name\" ). Message ( \"名称最长为100字符\" ) valid . Required ( createdBy , \"created_by\" ). Message ( \"创建人不能为空\" ) valid . MaxSize ( createdBy , 100 , \"created_by\" ). Message ( \"创建人最长为100字符\" ) valid . Range ( state , 0 , 1 , \"starte\" ). Message ( \"状态只允许0或1\" ) code := e . INVALID_PARAMS if ! valid . HasErrors () { if ! models . ExistTagByName ( name ) { code = e . SUCCESS models . AddTag ( name , state , createdBy ) } else { code = e . ERROR_EXIST_TAG } } c . JSON ( http . StatusOK , gin . H { \"code\" : code , \"msg\" : e . GetMsg ( code ), \"data\" : make ( map [ string ] string ), }) } // EditTag 修改文章标签 func EditTag ( c * gin . Context ) { id := com . StrTo ( c . Param ( \"id\" )). MustInt () name := c . Query ( \"name\" ) modifiedBy := c . Query ( \"modified_by\" ) valid := validation . Validation {} var state = - 1 if arg := c . Query ( \"state\" ); arg != \"\" { state = com . StrTo ( arg ). MustInt () valid . Range ( state , 0 , 1 , \"state\" ). Message ( \"状态只允许0或1\" ) } valid . Required ( id , \"id\" ). Message ( \"ID不能为空\" ) valid . Required ( modifiedBy , \"modiified_by\" ). Message ( \"修改人不能为空\" ) valid . MaxSize ( modifiedBy , 100 , \"modified_by\" ). Message ( \"修改人最长为100字符\" ) valid . MaxSize ( name , 100 , \"name\" ). Message ( \"名称最长为100字符\" ) code := e . INVALID_PARAMS if ! valid . HasErrors () { code = e . SUCCESS if models . ExistTagByID ( id ) { data := make ( map [ string ] interface {}) data [ \"modified_by\" ] = modifiedBy if name != \"\" { data [ \"name\" ] = name } if state != - 1 { data [ \"state\" ] = state } models . EditTag ( id , data ) } else { // 不存在, 无法修改标签 code = e . ERROR_NOT_EXIST_ARTICLE } } c . JSON ( http . StatusOK , gin . H { \"code\" : code , \"message\" : e . GetMsg ( code ), \"data\" : make ( map [ string ] string ), }) } // DeleteTag 删除文章标签 func DeleteTag ( c * gin . Context ) { id := com . StrTo ( c . Param ( \"id\" )). MustInt () valid := validation . Validation {} valid . Min ( id , 1 , \"id\" ). Message ( \"ID必须大于0\" ) code := e . INVALID_PARAMS if ! valid . HasErrors () { code = e . SUCCESS // 数据库操作 if models . ExistTagByID ( id ) { models . DeleteTag ( id ) } else { code = e . ERROR_NOT_EXIST_TAG } } c . JSON ( http . StatusOK , gin . H { \"code\" : code , \"msg\" : e . GetMsg ( code ), \"data\" : make ( map [ string ] string ), }) }","text_tokens":["外","空壳","对象","修改文章","转换","据库","*","logger","return","msg","处理","博客","starte","接口",",","type","写入","映射","类","支持","完善"," ","haserrors","!","json","arg","对","返回","(",";","自动","只","models","will","等于","main","unknwon","了","tags","“","pkg","u","：","count","通过","maxsize","将","if","进行","/","modiified","完成","tag","者","存在","是否","by","code","增加","请求","校验","routers","检测","nil","getpage","体","全部","默认值","验证","else","r","&","无法","如果","create","deletetag","recovery","一致","添加","createdon",")","获取","}","修改","omit","分发","-","标签","required",">","时候","默认","gorm","test","apiv1","get","name","e","createdby","定义","where","true","负责","db","确保",".","1","路由","statusok","到","最长","属性","”","空","valid","03","addtag","初始","初始化","find","delete","指定","补全","beforeupdate","100","传递","为","astaxie","unix","pagenum","query","2","model","函数","操作","use","该","结构","should","message","min","interface","这些","exist","{","相应","created","modified","下","lists","beforecreate","给","offset","中会","gettags","go","invalid","new","false","版本","engine","modifiedby","文章","success","c","router","var","time","声明","existtagbyid","total","id","新增","0","调用","settings","params","url","由该","名称","目录","net","github","gonic","的","继承","[","编写","数据","多个","`","创建人","bool","?","必须","第一","之前","还","struct","context","模型","gettagtotal","param","inferred","state","]","列表","其","make","各个","run","update","string","pagesize","setcolumn","range","参数","接口定义","除了","新建","beego","localhost","scope","select","v1","赋予","允许","gin","put","it","打开","字符","post","编辑","strto","first","大于","逻辑","数据库","data","方法","\"","设置","来","或","用","map","注册","更新","setting","不能","int","page","edittag","、","validation","从","http","为空","import","等","代表",":","人","package","limit","体中","中","util","group","now","状态","大","example","getmsg","进来","crud","和","表单","则","initrouter","setmode","找到","modifiedon","=","不","existtagbyname","8000","article","handler","创建","时间","，","一个","查询","api","be","jinzhu","是","可以","第一个","删除","在","defaultquery","一些","mustint","且","操作方法","maps","error","成功","内","_","com","runmode","文件","体外","func","h","not"],"title":"go-gin-example 03：API-2","title_tokens":["example","2"," ","gin","api","03","go","：","-"]},{"location":"Golang/Project/go-gin-example/03 API-2/#go-gin-example-03api-2","text":"完成博客的标签类接口定义和编写","text_tokens":["的","接口","编写","标签","接口定义","类","和","完成","定义","博客"],"title":"go-gin-example 03：API-2","title_tokens":["example","2"," ","gin","api","03","go","：","-"]},{"location":"Golang/Project/go-gin-example/03 API-2/#_1","text":"定义文章标签的路由分发操作 获取标签列表：GET(“/tags”) 新建标签：POST(“/tags”) 更新指定标签：PUT(“/tags/:id”) 删除指定标签：DELETE(“/tags/:id”)","text_tokens":[" ",":","标签","操作","路由","id","列表","tags","更新","“","文章","(","：","put","”","的","get",")","定义","post","/","delete","指定","获取","删除","分发","新建"],"title":"定义接口","title_tokens":["接口","定义"]},{"location":"Golang/Project/go-gin-example/03 API-2/#_2","text":"注册路由将请求分发到该路由中，由该API路由中函数处理 在./routers/api 下新建 v1 目录，目录内新建 tag.go 文件代表第一个API大版本 package v1 import ( \"github.com/gin-gonic/gin\" ) // GetTags 获取多个文章标签 func GetTags ( c * gin . Context ) { } // AddTag 新增文章标签 func AddTag ( c * gin . Context ) { } // EditTag 修改文章标签 func EditTag ( c * gin . Context ) { } // DeleteTag 删除文章标签 func DeleteTag ( c * gin . Context ) { }","text_tokens":["\"","代表",".","tag"," ","函数","标签","gettags","context","package","该","修改文章","注册","路由","go","新增","到","*","deletetag","v1","，","一个","api","由该","中","版本","目录","(","gin","文章","大","处理","github","gonic","c","edittag","内","com","请求","新建","{","多个","addtag","将",")","/","routers","文件","func","下","第一个","获取","import","}","删除","修改","第一","在","分发","-"],"title":"空壳路由","title_tokens":["路由","空壳"]},{"location":"Golang/Project/go-gin-example/03 API-2/#_3","text":"该路由负责分发各个api请求给相应的 handler 者 打开 ./routers 下的 router.go 文件，修改为： package routers import ( setting \"go-gin-example/pkg/settings\" v1 \"go-gin-example/routers/api/v1\" \"github.com/gin-gonic/gin\" ) // InitRouter 初始化路由 func InitRouter () * gin . Engine { r := gin . New () r . Use ( gin . Logger ()) r . Use ( gin . Recovery ()) gin . SetMode ( setting . RunMode ) apiv1 := r . Group ( \"/api/v1\" ) { apiv1 . GET ( \"/tags\" , v1 . GetTags ) apiv1 . POST ( \"/tags\" , v1 . AddTag ) apiv1 . PUT ( \"/tags/:id\" , v1 . EditTag ) apiv1 . DELETE ( \"/tags/:id\" , v1 . DeleteTag ) } return r } 用 go run main.go 检测是否成功注册路由","text_tokens":["\"","gettags","用","注册","go","*","deletetag","recovery","new","setting","engine","logger","return","edittag","router",")",",","import","}","修改","分发","-"," ",":","package","id","settings","group","apiv1","(","github","gonic","的","example","get","initrouter","setmode","=","负责",".","handler","main","路由","各个","tags","run","，","api","pkg","：","addtag","初始","初始化","/","delete","为","者","use","该","是否","v1","成功","gin","put","com","请求","打开","runmode","{","post","相应","routers","检测","文件","func","下","给","r"],"title":"注册路由","title_tokens":["路由","注册"]},{"location":"Golang/Project/go-gin-example/03 API-2/#_4","text":"用beego的validation来进行表单校验数据 该 tag.go 模型中继承了 model.Model 结构体外新增了标签结构体中的一些属性，在该文件下除了通过 gorm 映射数据库模型外还添加了对标签的CRUD操作方法，在 ./routers/api/v1/tag.go 中可以调用这些CRUD方法 go get -u github.com/astaxie/beego/validation 在 models 目录下的 tag.go 写入 package models import ( \"time\" \"github.com/jinzhu/gorm\" ) // Tag 标签结构体 // 给结构体赋予json属性, 在c.JSON中会自动转换 type Tag struct { // 继承Model的结构体 Model Name string `json:\"name\"` CreatedBy string `json:\"created_by\"` ModifiedBy string `json:\"modified_by\"` State int `json:\"state\"` } // BeforeCreate 创建标签之前自动补全CreatedOn时间 func ( tag * Tag ) BeforeCreate ( scope * gorm . Scope ) error { scope . SetColumn ( \"CreatedOn\" , time . Now (). Unix ()) return nil } // BeforeUpdate 更新标签之前自动补全ModifiedOn时间 func ( tag * Tag ) BeforeUpdate ( scope * gorm . Scope ) error { scope . SetColumn ( \"ModifiedOn\" , time . Now (). Unix ()) return nil } // GetTags 获取文章标签 func GetTags ( pageNum int , pageSize int , maps interface {}) ( tags [] Tag ) { db . Where ( maps ). Offset ( pageNum ). Limit ( pageSize ). Find ( & tags ) return } // GetTagTotal 获取全部文章标签 func GetTagTotal ( maps interface {}) ( count int ) { db . Model ( & Tag {}). Where ( maps ). Count ( & count ) return } // ExistTagByName 查询文章标签是否存在 func ExistTagByName ( name string ) bool { var tag Tag db . Select ( \"id\" ). Where ( \"name = ?\" , name ). First ( & tag ) if tag . ID > 0 { return true } return false } // ExistTagByID 查询ID文章是否存在 func ExistTagByID ( id int ) bool { var tag Tag db . Select ( \"id\" ). Where ( \"id = ?\" , id ). First ( & tag ) if tag . ID > 0 { return true } return false } // AddTag 添加文章标签 func AddTag ( name string , state int , createdBy string ) bool { db . Create ( & Tag { Name : name , State : state , CreatedBy : createdBy , }) return true } // DeleteTag 删除文章标签 func DeleteTag ( id int ) bool { db . Where ( \"id = ? \" , id ). Delete ( & Tag {}) return true } // EditTag 编辑文章标签 func EditTag ( id int , data interface {}) bool { db . Model ( & Tag {}). Where ( \"id = ? \" , id ). Update ( data ) return true }","text_tokens":["\"","来","&","外","gettags","用","转换","go","据库","*","create","deletetag","更新","false","modifiedby","return","int","添加","文章","edittag","c","validation","createdon",")",",","time","type","var","写入","获取","映射","import","}","-","existtagbyid"," ",":","标签","package","limit",">","id","体中","json","新增","0","调用","对","gorm","中","目录","now","(","github","的","继承","[","get","数据","自动","name","crud","createdby","`","表单","models","where","bool","?","true","modifiedon","之前","=","还","struct","db","existtagbyname",".","模型","gettagtotal","创建","state","时间","]","了","tags","update","，","查询","api","string","属性","pagesize","u","setcolumn","jinzhu","count","通过","除了","addtag","if","进行","/","find","可以","delete","补全","beforeupdate","删除","在","一些","beego","astaxie","unix","pagenum","scope","model","tag","操作","存在","结构","该","是否","select","by","v1","赋予","interface","操作方法","maps","error","这些","_","com","{","校验","编辑","first","created","routers","modified","文件","体外","func","下","nil","数据库","给","体","beforecreate","data","全部","方法","offset","中会"],"title":"表单验证","title_tokens":["表单","验证"]},{"location":"Golang/Project/go-gin-example/03 API-2/#_5","text":"完善空壳路由 通过 beego/validation 对URL传递进来的参数进行校验，操作为声明 validation.Validation 对象，调用其 .Required 、 .MaxSize 、 .Range 、 .Message 等方法 通过 c.Query 获取URL中 ?name=test&state=1 中的参数， c.DefaultQuery 则支持设置一个默认值 util.GetPage 确保各个接口的 page 处理是一致的 在 ./routers/v1/tag.go 写入 package v1 import ( \"go-gin-example/models\" \"go-gin-example/pkg/e\" setting \"go-gin-example/pkg/settings\" \"go-gin-example/pkg/util\" \"net/http\" \"github.com/astaxie/beego/validation\" \"github.com/gin-gonic/gin\" \"github.com/unknwon/com\" ) // GetTags 获取文章标签 func GetTags ( c * gin . Context ) { // 从URL获取参数 // localhost:8000/tags?name=test&state=1 name := c . Query ( \"name\" ) maps := make ( map [ string ] interface {}) data := make ( map [ string ] interface {}) if name != \"\" { // 如果存在name参数, 将其添加到maps中 maps [ \"name\" ] = name } var state = - 1 // should omit type , it will be inferred if arg := c . Query ( \"state\" ); arg != \"\" { // 如果URL中存在state参数, 且arg不等于空的时候 // 将state转换为int // 添加到maps[\"state\"]中 state = com . StrTo ( arg ). MustInt () maps [ \"state\" ] = state } code := e . SUCCESS // 找到该文章,将其添加到lists中返回 data [ \"lists\" ] = models . GetTags ( util . GetPage ( c ), setting . PageSize , maps ) data [ \"total\" ] = models . GetTagTotal ( maps ) c . JSON ( http . StatusOK , gin . H { \"code\" : code , \"msg\" : e . GetMsg ( code ), \"data\" : data , }) } // AddTag 增加文章标签 func AddTag ( c * gin . Context ) { name := c . Query ( \"name\" ) // state=0代表该标签不存在 // 设置默认值为0 state := com . StrTo ( c . DefaultQuery ( \"state\" , \"0\" )). MustInt () createdBy := c . Query ( \"created_by\" ) valid := validation . Validation {} valid . Required ( name , \"name\" ). Message ( \"名称不能为空\" ) valid . MaxSize ( name , 100 , \"name\" ). Message ( \"名称最长为100字符\" ) valid . Required ( createdBy , \"created_by\" ). Message ( \"创建人不能为空\" ) valid . MaxSize ( createdBy , 100 , \"created_by\" ). Message ( \"创建人最长为100字符\" ) valid . Range ( state , 0 , 1 , \"starte\" ). Message ( \"状态只允许0或1\" ) code := e . INVALID_PARAMS if ! valid . HasErrors () { if ! models . ExistTagByName ( name ) { code = e . SUCCESS models . AddTag ( name , state , createdBy ) } else { code = e . ERROR_EXIST_TAG } } c . JSON ( http . StatusOK , gin . H { \"code\" : code , \"msg\" : e . GetMsg ( code ), \"data\" : make ( map [ string ] string ), }) } // EditTag 修改文章标签 func EditTag ( c * gin . Context ) { id := com . StrTo ( c . Param ( \"id\" )). MustInt () name := c . Query ( \"name\" ) modifiedBy := c . Query ( \"modified_by\" ) valid := validation . Validation {} var state = - 1 if arg := c . Query ( \"state\" ); arg != \"\" { state = com . StrTo ( arg ). MustInt () valid . Range ( state , 0 , 1 , \"state\" ). Message ( \"状态只允许0或1\" ) } valid . Required ( id , \"id\" ). Message ( \"ID不能为空\" ) valid . Required ( modifiedBy , \"modiified_by\" ). Message ( \"修改人不能为空\" ) valid . MaxSize ( modifiedBy , 100 , \"modified_by\" ). Message ( \"修改人最长为100字符\" ) valid . MaxSize ( name , 100 , \"name\" ). Message ( \"名称最长为100字符\" ) code := e . INVALID_PARAMS if ! valid . HasErrors () { code = e . SUCCESS if models . ExistTagByID ( id ) { data := make ( map [ string ] interface {}) data [ \"modified_by\" ] = modifiedBy if name != \"\" { data [ \"name\" ] = name } if state != - 1 { data [ \"state\" ] = state } models . EditTag ( id , data ) } else { // 不存在, 无法修改标签 code = e . ERROR_NOT_EXIST_ARTICLE } } c . JSON ( http . StatusOK , gin . H { \"code\" : code , \"message\" : e . GetMsg ( code ), \"data\" : make ( map [ string ] string ), }) } // DeleteTag 删除文章标签 func DeleteTag ( c * gin . Context ) { id := com . StrTo ( c . Param ( \"id\" )). MustInt () valid := validation . Validation {} valid . Min ( id , 1 , \"id\" ). Message ( \"ID必须大于0\" ) code := e . INVALID_PARAMS if ! valid . HasErrors () { code = e . SUCCESS // 数据库操作 if models . ExistTagByID ( id ) { models . DeleteTag ( id ) } else { code = e . ERROR_NOT_EXIST_TAG } } c . JSON ( http . StatusOK , gin . H { \"code\" : code , \"msg\" : e . GetMsg ( code ), \"data\" : make ( map [ string ] string ), }) }","text_tokens":["\"","设置","&","gettags","空壳","或","无法","对象","map","如果","修改文章","转换","go","invalid","据库","*","deletetag","一致","setting","modifiedby","不能","int","添加","文章","msg","page","处理","success","c","starte","edittag","、","接口","validation","从","http",")",",","var","声明","type","写入","为空","获取","import","}","支持","修改","omit","-","等","完善","existtagbyid","total","代表"," ",":","标签","haserrors","人","package","required","!","id","json","时候","0","arg","调用","对","settings","url","默认","params","test","返回","中","util","名称","net","(","状态","github","gonic","的","example",";","[","getmsg","进来","数据","name","e","只","createdby","models","will","创建人","则","?","必须","找到","等于","=","不","existtagbyname","确保",".","1","8000","context","article","param","unknwon","gettagtotal","inferred","创建","state","]","路由","make","其","statusok","各个","tags","到","，","一个","be","最长","string","pagesize","pkg","空","valid","range","通过","maxsize","参数","addtag","将","if","进行","是","/","modiified","删除","100","在","defaultquery","beego","传递","为","astaxie","localhost","query","mustint","tag","操作","存在","该","should","且","message","min","by","v1","interface","允许","maps","error","gin","code","it","exist","_","com","增加","{","校验","字符","strto","created","routers","modified","大于","func","lists","h","getpage","数据库","data","默认值","方法","else","not"],"title":"编写标签列表的路由逻辑","title_tokens":["的","逻辑","编写","标签","路由","列表"]},{"location":"Golang/Project/go-gin-example/04 API-3/","text":"go-gin-example 04：API-3 完成博客的文章类接口定义和编写 定义接口 定义文章的路由分发操作 获取文章列表：GET(“/articles”) 获取单篇文章：GET(“/articles/:id”) 更新文章：PUT(“/articles/:id”) 新建文章：POST(“/articles”) 删除文章：DELETE(“/tags/:id”) 空壳路由 文章请求处理API 在 ./routers/api/v1 下新建 article.go 文件 package v1 import ( \"go-gin-example/models\" \"go-gin-example/pkg/e\" setting \"go-gin-example/pkg/settings\" \"go-gin-example/pkg/util\" \"log\" \"net/http\" \"github.com/astaxie/beego/validation\" \"github.com/gin-gonic/gin\" \"github.com/unknwon/com\" ) // GetArticle 获取单个文章 func GetArticle ( c * gin . Context ) { id := com . StrTo ( c . Param ( \"id\" )). MustInt () valid := validation . Validation {} valid . Min ( id , 1 , \"id\" ). Message ( \"ID必须大于0\" ) code := e . INVALID_PARAMS var data interface {} if ! valid . HasErrors () { if models . ExistArticleByID ( id ) { data = models . GetArticle ( id ) code = e . SUCCESS } else { code = e . ERROR_NOT_EXIST_ARTICLE } } else { for _ , err := range valid . Errors { log . Printf ( \"err.key: %s, err.message: %s\" , err . Key , err . Message ) } } c . JSON ( http . StatusOK , gin . H { \"code\" : code , \"msg\" : e . GetMsg ( code ), \"data\" : data , }) } // GetArticles 获取多个文章 func GetArticles ( c * gin . Context ) { data := make ( map [ string ] interface {}) maps := make ( map [ string ] interface {}) valid := validation . Validation {} var state = - 1 if arg := c . Query ( \"state\" ); arg != \"\" { state = com . StrTo ( arg ). MustInt () maps [ \"state\" ] = state valid . Range ( state , 0 , 1 , \"state\" ). Message ( \"状态只允许0或1\" ) } var tagID = - 1 if arg := c . Query ( \"tag_id\" ); arg != \"\" { tagID = com . StrTo ( arg ). MustInt () maps [ \"tag_id\" ] = tagID valid . Min ( tagID , 1 , \"tag_id\" ). Message ( \"标签ID必须大于0\" ) } code := e . INVALID_PARAMS if ! valid . HasErrors () { data [ \"list\" ] = models . GetArticles ( util . GetPage ( c ), setting . PageSize , maps ) data [ \"total\" ] = models . GetTagTotal ( maps ) code = e . SUCCESS } else { for _ , err := range valid . Errors { log . Printf ( \"err.key:%s, err.message:%s\" , err . Key , err . Message ) } } c . JSON ( http . StatusOK , gin . H { \"code\" : code , \"msg\" : e . GetMsg ( code ), \"data\" : data , }) } // AddArticle 增加文章 func AddArticle ( c * gin . Context ) { tagID := com . StrTo ( c . Query ( \"tag_id\" )). MustInt () title := c . Query ( \"title\" ) desc := c . Query ( \"desc\" ) content := c . Query ( \"content\" ) createdBy := c . Query ( \"created_by\" ) state := com . StrTo ( c . Query ( \"state\" )). MustInt () valid := validation . Validation {} valid . Min ( tagID , 1 , \"tagID\" ). Message ( \"标签ID必须大于0\" ) valid . Required ( title , \"title\" ). Message ( \"题目不能为空\" ) valid . Required ( desc , \"desc\" ). Message ( \"描述不能为空\" ) valid . Required ( content , \"content\" ). Message ( \"内容不能为空\" ) valid . Required ( createdBy , \"created_by\" ). Message ( \"创建人不能为空\" ) valid . Range ( state , 0 , 1 , \"state\" ). Message ( \"状态只能是0或1\" ) code := e . INVALID_PARAMS if ! valid . HasErrors () { if models . ExistTagByID ( tagID ) { data := make ( map [ string ] interface {}) data [ \"tag_id\" ] = tagID data [ \"title\" ] = title data [ \"desc\" ] = desc data [ \"content\" ] = content data [ \"created_by\" ] = createdBy data [ \"state\" ] = state models . AddArticle ( data ) code = e . SUCCESS } else { code = e . ERROR_NOT_EXIST_TAG } } else { for _ , err := range valid . Errors { log . Printf ( \"err.key:%s, err.message%s\" , err . Key , err . Message ) } } c . JSON ( http . StatusOK , gin . H { \"code\" : code , \"msg\" : e . GetMsg ( code ), \"data\" : make ( map [ string ] string ), }) } // EditArticle 修改文章 func EditArticle ( c * gin . Context ) { valid := validation . Validation {} id := com . StrTo ( c . Query ( \"id\" )). MustInt () tagID := com . StrTo ( c . Query ( \"tag_id\" )). MustInt () title := c . Query ( \"title\" ) desc := c . Query ( \"desc\" ) content := c . Query ( \"content\" ) modifiedBy := c . Query ( \"modified_by\" ) var state = - 1 if arg := c . Query ( \"state\" ); arg != \"\" { state = com . StrTo ( arg ). MustInt () valid . Range ( state , 0 , 1 , \"state\" ). Message ( \"状态只能是0或1\" ) } valid . Min ( id , 1 , \"id\" ). Message ( \"ID必须大于0\" ) valid . MaxSize ( title , 100 , \"title\" ). Message ( \"标题最长为100字符\" ) valid . MaxSize ( desc , 255 , \"desc\" ). Message ( \"简述最长为255字符\" ) valid . MaxSize ( content , 65535 , \"content\" ). Message ( \"内容最长为65535字符\" ) valid . Required ( modifiedBy , \"modified_by\" ). Message ( \"修改人不能为空\" ) valid . MaxSize ( modifiedBy , 100 , \"modified_by\" ). Message ( \"修改人最长为100字符\" ) code := e . INVALID_PARAMS if ! valid . HasErrors () { if models . ExistArticleByID ( id ) { if models . ExistTagByID ( tagID ) { data := make ( map [ string ] interface {}) if tagID > 0 { data [ \"tag_id\" ] = tagID } if title != \"\" { data [ \"title\" ] = title } if desc != \"\" { data [ \"desc\" ] = desc } if content != \"\" { data [ \"content\" ] = content } data [ \"modified_by\" ] = modifiedBy models . EditArticle ( id , data ) code = e . SUCCESS } else { code = e . ERROR_NOT_EXIST_TAG } } else { code = e . ERROR_NOT_EXIST_ARTICLE } } else { for _ , err := range valid . Errors { log . Printf ( \"err.key:%s err.Message:%s\" , err . Key , err . Message ) } } c . JSON ( http . StatusOK , gin . H { \"code\" : code , \"msg\" : e . GetMsg ( code ), \"data\" : make ( map [ string ] string ), }) } // DeleteArticle 删除文章 func DeleteArticle ( c * gin . Context ) { id := com . StrTo ( c . Query ( \"id\" )). MustInt () valid := validation . Validation {} valid . Min ( id , 1 , \"id\" ). Message ( \"ID必须大于0\" ) code := e . INVALID_PARAMS if ! valid . HasErrors () { if models . ExistArticleByID ( id ) { models . DeleteArticle ( id ) code = e . SUCCESS } else { code = e . ERROR_NOT_EXIST_ARTICLE } } else { for _ , err := range valid . Errors { log . Printf ( \"err.Key:%s err.Message:%s\" , err . Key , err . Message ) } } c . JSON ( http . StatusOK , gin . H { \"code\" : code , \"msg\" : e . GetMsg ( code ), \"data\" : make ( map [ string ] string ), }) } 定义文章的数据库模型 数据库模型和相关CRUD操作 在 ./models 下新建 article.go 文件 package models import ( \"time\" \"github.com/jinzhu/gorm\" ) // Article 文章结构体 type Article struct { Model // 声明该`TagID`为索引 TagID int `json:\"tag_id\" gorm:\"index\"` Tag Tag `json:tag` Title string `json:\"title\"` Desc string `json:\"desc\"` Content string `json:\"content\"` CreatedBy string `json:\"created_by\"` ModifiedBy string `json:\"modified_by\"` State int `json:state\"` } // BeforeCreate 创建数据前的操作 func ( article * Article ) BeforeCreate ( scope * gorm . Scope ) error { // scope 包含当前执行的所有信息 scope . SetColumn ( \"CreateOn\" , time . Now (). Unix ()) return nil } // BeforeUpdate 更新(编辑)之前添加修改时间 func ( article * Article ) BeforeUpdate ( scope * gorm . Scope ) error { scope . SetColumn ( \"ModifiedOn\" , time . Now (). Unix ()) return nil } // ExistArticleByID 判断是否存在文章 func ExistArticleByID ( id int ) bool { var article Article db . Select ( \"id\" ). Where ( \"id = ?\" , id ). Find ( & article ) if article . ID > 0 { return true } return false } // GetArticleTotal 计算文章数量 func GetArticleTotal ( maps interface {}) ( count int ) { // 在Article数据库中查询所有数据后计数返回给count db . Model ( & Article {}). Where ( maps ). Count ( & count ) return count } // GetArticles 获取所有文章列表 func GetArticles ( pageNum int , pageSize int , maps interface {}) ( articles [] Article ) { // 根据条件预加载 db . Preload ( \"Tag\" ). Where ( maps ). Offset ( pageNum ). Limit ( pageSize ). Find ( & articles ) return articles } // GetArticle 获取单篇文章 func GetArticle ( id int ) ( article Article ) { // 找到该片文章, 返回到article中 db . Where ( \"id = ?\" , id ). First ( & article ) // 获取与该篇文章有关的Tag // 通过.Related关联到嵌套在Article内的Tag结构体 db . Model ( & article ). Related ( & article . Tag ) return article } // EditArticle 编辑文章 func EditArticle ( id int , data interface {}) bool { db . Model ( & Article {}). Where ( \"id = ?\" , id ). Update ( data ) return true } // AddArticle 添加文章 func AddArticle ( data map [ string ] interface {}) bool { db . Create ( & Article { // v.(I)类型断言: 判断接口v的实际类型是否为(I)类型 TagID : data [ \"tag_id\" ].( int ), Title : data [ \"title\" ].( string ), Desc : data [ \"desc\" ].( string ), Content : data [ \"content\" ].( string ), CreatedBy : data [ \"created_by\" ].( string ), State : data [ \"state\" ].( int ), }) return true } // DeleteArticle 删除文章 func DeleteArticle ( id int ) bool { db . Where ( \"id = ?\" , id ). Delete ( Article {}) return true }","text_tokens":["\"","&","关联","message%","空壳","或","该片","前","map","修改文章","go","invalid","title","*","据库","create","更新","判断","v","false","数量","setting","modifiedby","不能","return","int","添加","文章","msg","处理","博客","success","c","editarticle","预","单篇","接口","articles","validation","http",")","单个",",","var","time","type","声明","err","为空","获取","index","包含","后","import","}","类","修改","分发","-","existtagbyid","total","所有","索引"," ",":","getarticle","haserrors","标签","人","package","!","required","计数","加载","limit",">","id","json","0","arg","settings","params","gorm","返回","中","util","net","now","(","状态","key","github","gonic","example","的",";","相关","[","get","编写","for","getmsg","数据","e","crud","多个","和","只","createdby","`","定义","models","list","创建人","where","bool","?","true","篇文章","题目","必须","3","执行","找到","modifiedon","之前","=","模型","struct","描述","db","根据","%","65535",".","1","当前","article","context","信息","param","unknwon","errors","gettagtotal","内容","创建","state","]","路由","标题","列表","existarticlebyid","make","statusok","时间","tags","preload","到","update","i","最长","查询","api","string","只能","pagesize","“","pkg","与","：","”","tagid","jinzhu","setcolumn","条件","count","valid","range","通过","getarticles","maxsize","printf","接口定义","类型","实际","255","if","是","/","find","delete","有关","beforeupdate","删除","s","完成","在","100","新建","beego","为","astaxie","deletearticle","unix","pagenum","query","mustint","tag","model","scope","操作","断言","getarticletotal","存在","结构","该","是否","select","简述","message","min","by","v1","interface","允许","maps","error","嵌套","计算","gin","code","put","exist","related","内","_","com","增加","请求","createon","{","字符","post","strto","编辑","first","created","routers","modified","文件","大于","desc","func","下","h","getpage","04","数据库","beforecreate","log","data","addarticle","content","体","nil","给","else","offset","not"],"title":"go-gin-example 04：API-3","title_tokens":["example"," ","gin","04","api","3","go","：","-"]},{"location":"Golang/Project/go-gin-example/04 API-3/#go-gin-example-04api-3","text":"完成博客的文章类接口定义和编写","text_tokens":["的","接口","编写","接口定义","类","和","完成","文章","定义","博客"],"title":"go-gin-example 04：API-3","title_tokens":["example"," ","gin","04","api","3","go","：","-"]},{"location":"Golang/Project/go-gin-example/04 API-3/#_1","text":"定义文章的路由分发操作 获取文章列表：GET(“/articles”) 获取单篇文章：GET(“/articles/:id”) 更新文章：PUT(“/articles/:id”) 新建文章：POST(“/articles”) 删除文章：DELETE(“/tags/:id”)","text_tokens":[" ",":","操作","路由","id","列表","tags","更新","“","文章","(","：","put","”","的","单篇","get","articles","新建",")","定义","post","/","delete","获取","删除","分发"],"title":"定义接口","title_tokens":["接口","定义"]},{"location":"Golang/Project/go-gin-example/04 API-3/#_2","text":"文章请求处理API 在 ./routers/api/v1 下新建 article.go 文件 package v1 import ( \"go-gin-example/models\" \"go-gin-example/pkg/e\" setting \"go-gin-example/pkg/settings\" \"go-gin-example/pkg/util\" \"log\" \"net/http\" \"github.com/astaxie/beego/validation\" \"github.com/gin-gonic/gin\" \"github.com/unknwon/com\" ) // GetArticle 获取单个文章 func GetArticle ( c * gin . Context ) { id := com . StrTo ( c . Param ( \"id\" )). MustInt () valid := validation . Validation {} valid . Min ( id , 1 , \"id\" ). Message ( \"ID必须大于0\" ) code := e . INVALID_PARAMS var data interface {} if ! valid . HasErrors () { if models . ExistArticleByID ( id ) { data = models . GetArticle ( id ) code = e . SUCCESS } else { code = e . ERROR_NOT_EXIST_ARTICLE } } else { for _ , err := range valid . Errors { log . Printf ( \"err.key: %s, err.message: %s\" , err . Key , err . Message ) } } c . JSON ( http . StatusOK , gin . H { \"code\" : code , \"msg\" : e . GetMsg ( code ), \"data\" : data , }) } // GetArticles 获取多个文章 func GetArticles ( c * gin . Context ) { data := make ( map [ string ] interface {}) maps := make ( map [ string ] interface {}) valid := validation . Validation {} var state = - 1 if arg := c . Query ( \"state\" ); arg != \"\" { state = com . StrTo ( arg ). MustInt () maps [ \"state\" ] = state valid . Range ( state , 0 , 1 , \"state\" ). Message ( \"状态只允许0或1\" ) } var tagID = - 1 if arg := c . Query ( \"tag_id\" ); arg != \"\" { tagID = com . StrTo ( arg ). MustInt () maps [ \"tag_id\" ] = tagID valid . Min ( tagID , 1 , \"tag_id\" ). Message ( \"标签ID必须大于0\" ) } code := e . INVALID_PARAMS if ! valid . HasErrors () { data [ \"list\" ] = models . GetArticles ( util . GetPage ( c ), setting . PageSize , maps ) data [ \"total\" ] = models . GetTagTotal ( maps ) code = e . SUCCESS } else { for _ , err := range valid . Errors { log . Printf ( \"err.key:%s, err.message:%s\" , err . Key , err . Message ) } } c . JSON ( http . StatusOK , gin . H { \"code\" : code , \"msg\" : e . GetMsg ( code ), \"data\" : data , }) } // AddArticle 增加文章 func AddArticle ( c * gin . Context ) { tagID := com . StrTo ( c . Query ( \"tag_id\" )). MustInt () title := c . Query ( \"title\" ) desc := c . Query ( \"desc\" ) content := c . Query ( \"content\" ) createdBy := c . Query ( \"created_by\" ) state := com . StrTo ( c . Query ( \"state\" )). MustInt () valid := validation . Validation {} valid . Min ( tagID , 1 , \"tagID\" ). Message ( \"标签ID必须大于0\" ) valid . Required ( title , \"title\" ). Message ( \"题目不能为空\" ) valid . Required ( desc , \"desc\" ). Message ( \"描述不能为空\" ) valid . Required ( content , \"content\" ). Message ( \"内容不能为空\" ) valid . Required ( createdBy , \"created_by\" ). Message ( \"创建人不能为空\" ) valid . Range ( state , 0 , 1 , \"state\" ). Message ( \"状态只能是0或1\" ) code := e . INVALID_PARAMS if ! valid . HasErrors () { if models . ExistTagByID ( tagID ) { data := make ( map [ string ] interface {}) data [ \"tag_id\" ] = tagID data [ \"title\" ] = title data [ \"desc\" ] = desc data [ \"content\" ] = content data [ \"created_by\" ] = createdBy data [ \"state\" ] = state models . AddArticle ( data ) code = e . SUCCESS } else { code = e . ERROR_NOT_EXIST_TAG } } else { for _ , err := range valid . Errors { log . Printf ( \"err.key:%s, err.message%s\" , err . Key , err . Message ) } } c . JSON ( http . StatusOK , gin . H { \"code\" : code , \"msg\" : e . GetMsg ( code ), \"data\" : make ( map [ string ] string ), }) } // EditArticle 修改文章 func EditArticle ( c * gin . Context ) { valid := validation . Validation {} id := com . StrTo ( c . Query ( \"id\" )). MustInt () tagID := com . StrTo ( c . Query ( \"tag_id\" )). MustInt () title := c . Query ( \"title\" ) desc := c . Query ( \"desc\" ) content := c . Query ( \"content\" ) modifiedBy := c . Query ( \"modified_by\" ) var state = - 1 if arg := c . Query ( \"state\" ); arg != \"\" { state = com . StrTo ( arg ). MustInt () valid . Range ( state , 0 , 1 , \"state\" ). Message ( \"状态只能是0或1\" ) } valid . Min ( id , 1 , \"id\" ). Message ( \"ID必须大于0\" ) valid . MaxSize ( title , 100 , \"title\" ). Message ( \"标题最长为100字符\" ) valid . MaxSize ( desc , 255 , \"desc\" ). Message ( \"简述最长为255字符\" ) valid . MaxSize ( content , 65535 , \"content\" ). Message ( \"内容最长为65535字符\" ) valid . Required ( modifiedBy , \"modified_by\" ). Message ( \"修改人不能为空\" ) valid . MaxSize ( modifiedBy , 100 , \"modified_by\" ). Message ( \"修改人最长为100字符\" ) code := e . INVALID_PARAMS if ! valid . HasErrors () { if models . ExistArticleByID ( id ) { if models . ExistTagByID ( tagID ) { data := make ( map [ string ] interface {}) if tagID > 0 { data [ \"tag_id\" ] = tagID } if title != \"\" { data [ \"title\" ] = title } if desc != \"\" { data [ \"desc\" ] = desc } if content != \"\" { data [ \"content\" ] = content } data [ \"modified_by\" ] = modifiedBy models . EditArticle ( id , data ) code = e . SUCCESS } else { code = e . ERROR_NOT_EXIST_TAG } } else { code = e . ERROR_NOT_EXIST_ARTICLE } } else { for _ , err := range valid . Errors { log . Printf ( \"err.key:%s err.Message:%s\" , err . Key , err . Message ) } } c . JSON ( http . StatusOK , gin . H { \"code\" : code , \"msg\" : e . GetMsg ( code ), \"data\" : make ( map [ string ] string ), }) } // DeleteArticle 删除文章 func DeleteArticle ( c * gin . Context ) { id := com . StrTo ( c . Query ( \"id\" )). MustInt () valid := validation . Validation {} valid . Min ( id , 1 , \"id\" ). Message ( \"ID必须大于0\" ) code := e . INVALID_PARAMS if ! valid . HasErrors () { if models . ExistArticleByID ( id ) { models . DeleteArticle ( id ) code = e . SUCCESS } else { code = e . ERROR_NOT_EXIST_ARTICLE } } else { for _ , err := range valid . Errors { log . Printf ( \"err.Key:%s err.Message:%s\" , err . Key , err . Message ) } } c . JSON ( http . StatusOK , gin . H { \"code\" : code , \"msg\" : e . GetMsg ( code ), \"data\" : make ( map [ string ] string ), }) }","text_tokens":["\"","message%","或","map","修改文章","go","invalid","title","*","setting","modifiedby","不能","文章","msg","处理","success","c","editarticle","validation","http",")","单个",",","var","err","为空","获取","import","}","修改","-","existtagbyid","total"," ","getarticle",":","haserrors","标签","人","package","!","required",">","id","json","0","arg","settings","params","util","net","(","状态","key","github","gonic","example",";","[","getmsg","for","e","多个","只","createdby","models","list","创建人","题目","必须","=","描述","%","65535",".","1","article","context","param","unknwon","errors","gettagtotal","内容","创建","state","]","标题","make","existarticlebyid","statusok","最长","api","string","只能","pagesize","pkg","tagid","valid","range","getarticles","maxsize","printf","255","if","是","/","删除","s","100","在","新建","beego","为","astaxie","deletearticle","query","mustint","tag","简述","message","min","by","v1","interface","允许","maps","error","gin","code","exist","_","com","增加","请求","{","字符","strto","created","routers","modified","文件","大于","desc","func","下","h","getpage","log","data","addarticle","content","else","not"],"title":"空壳路由","title_tokens":["路由","空壳"]},{"location":"Golang/Project/go-gin-example/04 API-3/#_3","text":"数据库模型和相关CRUD操作 在 ./models 下新建 article.go 文件 package models import ( \"time\" \"github.com/jinzhu/gorm\" ) // Article 文章结构体 type Article struct { Model // 声明该`TagID`为索引 TagID int `json:\"tag_id\" gorm:\"index\"` Tag Tag `json:tag` Title string `json:\"title\"` Desc string `json:\"desc\"` Content string `json:\"content\"` CreatedBy string `json:\"created_by\"` ModifiedBy string `json:\"modified_by\"` State int `json:state\"` } // BeforeCreate 创建数据前的操作 func ( article * Article ) BeforeCreate ( scope * gorm . Scope ) error { // scope 包含当前执行的所有信息 scope . SetColumn ( \"CreateOn\" , time . Now (). Unix ()) return nil } // BeforeUpdate 更新(编辑)之前添加修改时间 func ( article * Article ) BeforeUpdate ( scope * gorm . Scope ) error { scope . SetColumn ( \"ModifiedOn\" , time . Now (). Unix ()) return nil } // ExistArticleByID 判断是否存在文章 func ExistArticleByID ( id int ) bool { var article Article db . Select ( \"id\" ). Where ( \"id = ?\" , id ). Find ( & article ) if article . ID > 0 { return true } return false } // GetArticleTotal 计算文章数量 func GetArticleTotal ( maps interface {}) ( count int ) { // 在Article数据库中查询所有数据后计数返回给count db . Model ( & Article {}). Where ( maps ). Count ( & count ) return count } // GetArticles 获取所有文章列表 func GetArticles ( pageNum int , pageSize int , maps interface {}) ( articles [] Article ) { // 根据条件预加载 db . Preload ( \"Tag\" ). Where ( maps ). Offset ( pageNum ). Limit ( pageSize ). Find ( & articles ) return articles } // GetArticle 获取单篇文章 func GetArticle ( id int ) ( article Article ) { // 找到该片文章, 返回到article中 db . Where ( \"id = ?\" , id ). First ( & article ) // 获取与该篇文章有关的Tag // 通过.Related关联到嵌套在Article内的Tag结构体 db . Model ( & article ). Related ( & article . Tag ) return article } // EditArticle 编辑文章 func EditArticle ( id int , data interface {}) bool { db . Model ( & Article {}). Where ( \"id = ?\" , id ). Update ( data ) return true } // AddArticle 添加文章 func AddArticle ( data map [ string ] interface {}) bool { db . Create ( & Article { // v.(I)类型断言: 判断接口v的实际类型是否为(I)类型 TagID : data [ \"tag_id\" ].( int ), Title : data [ \"title\" ].( string ), Desc : data [ \"desc\" ].( string ), Content : data [ \"content\" ].( string ), CreatedBy : data [ \"created_by\" ].( string ), State : data [ \"state\" ].( int ), }) return true } // DeleteArticle 删除文章 func DeleteArticle ( id int ) bool { db . Where ( \"id = ?\" , id ). Delete ( Article {}) return true }","text_tokens":["\"","&","关联","该片","map","go","title","据库","*","create","v","更新","判断","false","数量","modifiedby","return","int","添加","文章","预","editarticle","单篇","接口","articles",")","type","time","声明",",","var","获取","index","包含","后","import","}","修改","所有","索引"," ",":","getarticle","package","计数","加载","limit",">","id","json","0","gorm","返回","中","now","(","github","的","相关","[","数据","crud","和","createdby","`","models","where","bool","?","true","篇文章","找到","执行","modifiedon","之前","=","struct","db","根据",".","当前","article","信息","模型","前","计算","创建","state","时间","]","列表","existarticlebyid","preload","到","update","i","查询","string","pagesize","与","tagid","jinzhu","setcolumn","条件","count","通过","getarticles","类型","实际","if","/","find","delete","有关","beforeupdate","删除","在","新建","为","deletearticle","unix","pagenum","scope","model","tag","断言","操作","getarticletotal","存在","结构","该","是否","select","by","interface","maps","error","嵌套","related","内","_","com","createon","{","编辑","first","created","modified","文件","desc","func","下","nil","数据库","beforecreate","体","给","data","content","addarticle","offset"],"title":"定义文章的数据库模型","title_tokens":["的","据库","数据","数据库","模型","文章","定义"]},{"location":"Golang/Project/go-gin-example/05 JWT/","text":"go-gin-example 05：JWT 为什么要JWT 当前的API接口虽然编写好了，但是这些API可以被随意调用，这样子是不安全的。因此需要通过 jwt-go 的方式来解决 如何使用JWT 下载依赖包： go get -u github.com/dgrijalva/jwt-go 编写 ./pkg/util 下的新建 jwt.go 文件 其中该工具包主要包含 生成Token 、 解析Token 功能 NewWithClaims 中加密方法有 SigningMethodHS256 ， SigningMethodHS384 、 SigningMethodHS512 三种 cropto.Hash 方案 package util import ( setting \"go-gin-example/pkg/settings\" \"time\" \"github.com/dgrijalva/jwt-go\" ) var jwtSecret = [] byte ( setting . JwtSecret ) // Claims 声明Claims结构体 type Claims struct { Username string `json: \"username\"` Password string `json: \"password\"` jwt . StandardClaims } // GenerateToken 生成密钥 func GenerateToken ( username , password string ) ( string , error ) { nowTime := time . Now () expireTime := nowTime . Add ( 3 * time . Hour ) claims := Claims { username , password , jwt . StandardClaims { ExpiresAt : expireTime . Unix (), Issuer : \"gin-blog\" , }, } // 对claims 进行加密 tokenClaims := jwt . NewWithClaims ( jwt . SigningMethodHS256 , claims ) // 获得加密后的token // 猜测为生成一个加密后的字符串给jwtSecret token , err := tokenClaims . SignedString ( jwtSecret ) return token , err } // ParseToken 解析密钥 func ParseToken ( token string ) ( * Claims , error ) { tokenClaims , err := jwt . ParseWithClaims ( token , & Claims {}, func ( token * jwt . Token ) ( interface {}, error ) { return jwtSecret , nil }) if tokenClaims != nil { if claims , ok := tokenClaims . Claims .( * Claims ); ok && tokenClaims . Valid { return claims , nil } } return nil , err } 编写Gin中间件，在 middleware 下新建 jwt 目录，在其中新建 jwt.go 文件写入 package jwt import ( \"go-gin-example/pkg/e\" \"go-gin-example/pkg/util\" \"net/http\" \"time\" \"github.com/gin-gonic/gin\" ) // JWT json web token func JWT () gin . HandlerFunc { return func ( c * gin . Context ) { var code int var data interface {} code = e . SUCCESS token := c . Query ( \"token\" ) if token == \"\" { code = e . INVALID_PARAMS } else { claims , err := util . ParseToken ( token ) if err != nil { code = e . ERROR_AUTH_CHECK_TOKEN_FAIL } else if time . Now (). Unix () > claims . ExpiresAt { code = e . ERROR_AUTH_CHECK_TOKEN_TIMEOUT } } if code != e . SUCCESS { c . JSON ( http . StatusUnauthorized , gin . H { \"code\" : code , \"msg\" : e . GetMsg ( code ), \"data\" : data , }) // 通过Abort确保当前的handler未被调用, 即当验证不正确的时候丢弃掉该处理 c . Abort () return } c . Next () } } 获得token，在 ./models 下新建 auth.go 文件写入 package models // Auth Token认证 type Auth struct { ID int `gorm:\"primary_key\" json:\"id\"` Username string `json:\"username\"` Password string `json:\"password\"` } // CheckAuth 验证token func CheckAuth ( username , password string ) bool { var auth Auth db . Select ( \"id\" ). Where ( Auth { Username : username , Password : password }). First ( & auth ) if auth . ID > 0 { return true } return false } 在 ./api 下新建 auth.go 文件写入 package api import ( \"go-gin-example/models\" \"go-gin-example/pkg/e\" \"go-gin-example/pkg/util\" \"log\" \"net/http\" \"github.com/astaxie/beego/validation\" \"github.com/gin-gonic/gin\" ) type auth struct { Username string `valid: \"Required; MaxSize(50)\" ` Password string `valid: \"Required; MaxSize(50)\"` } // GetAuth 获取认证 func GetAuth ( c * gin . Context ) { username := c . Query ( \"username\" ) password := c . Query ( \"password\" ) valid := validation . Validation {} a := auth { Username : username , Password : password } ok , _ := valid . Valid ( & a ) data := make ( map [ string ] interface {}) code := e . INVALID_PARAMS if ok { isExist := models . CheckAuth ( username , password ) // 如果存在该账号 if isExist { token , err := util . GenerateToken ( username , password ) if err != nil { code = e . ERROR_AUTH_TOKEN } else { data [ \"token\" ] = token code = e . SUCCESS } } else { // 不存在账号 code = e . ERROR_AUTH } } else { for _ , err := range valid . Errors { log . Println ( err . Key , err . Message ) } } c . JSON ( http . StatusOK , gin . H { \"code\" : code , \"msg\" : e . GetMsg ( code ), \"data\" : data , }) } 修改 router.go 文件 package routers import ( \"go-gin-example/middleware/jwt\" setting \"go-gin-example/pkg/settings\" \"go-gin-example/routers/api\" v1 \"go-gin-example/routers/api/v1\" \"github.com/gin-gonic/gin\" ) // InitRouter 初始化路由 func InitRouter () * gin . Engine { r := gin . New () r . Use ( gin . Logger ()) r . Use ( gin . Recovery ()) gin . SetMode ( setting . RunMode ) // 调用认证接口 r . GET ( \"/auth\" , api . GetAuth ) apiv1 := r . Group ( \"/api/v1\" ) // Group内的所有请求都需要经过JWT apiv1 . Use ( jwt . JWT ()) { apiv1 . GET ( \"/tags\" , v1 . GetTags ) apiv1 . POST ( \"/tags\" , v1 . AddTag ) apiv1 . PUT ( \"/tags/:id\" , v1 . EditTag ) apiv1 . DELETE ( \"/tags/:id\" , v1 . DeleteTag ) apiv1 . GET ( \"/articles\" , v1 . GetArticles ) apiv1 . GET ( \"/articles/:id\" , v1 . GetArticle ) apiv1 . POST ( \"/articles\" , v1 . AddArticle ) apiv1 . PUT ( \"/articles/:id\" , v1 . EditTag ) apiv1 . DELETE ( \"/atricles/:id\" , v1 . DeleteTag ) } return r } 调用 访问 http://127.0.0.1:8000/auth?username=test&password=test123456 获得token 带着token访问api http://127.0.0.1:8000/api/v1/articles?token=eyJhbGci...","text_tokens":["\"","中间","来","&","生成","gettags","map","有","如果","go","invalid","*","deletetag","recovery","new","false","setting","timeout","engine","logger","middleware","return","int","工具","msg","处理","要","success","c","edittag","、","router","接口","articles","validation","http","样子",")","var","time","声明","type",",","字符串","写入","err","abort","获取","包含","后","掉","import","}","nowtime","修改","-","所有","解决"," ","方案",":","功能","都","getarticle","package","!","依赖","工具包","dgrijalva","blog",">","token","丢弃","json","tokenclaims","时候","id","使用","好","调用","0","带","settings","对","params","获得","...","password","gorm","test","中","util","加密","now","目录","net","apiv1","group","(","handlerfunc","主要","包","github","example","的","standardclaims",";","gonic","key","[","eyjhbgci","get","编写","getmsg","for","expiresat","e","`","50","models","其中","什么","where","primary","checkauth","initrouter","bool","true","?","jwtsecret","setmode","test123456","3","ok","=","struct","为什么","不","db","println","signingmethodhs512","随意","确保","三种","当前",".","8000","context","handler","expiretime","jwt","errors","]","路由","make","解析","了","statusok","tags","被","，","一个","api","hash","string","hour","statusunauthorized","signingmethodhs384","认证","但是","pkg","u","：","username","claims","valid","range","通过","maxsize","getarticles","0.1","需要","初始","addtag","初始化","if","正确","进行","是","signingmethodhs256","/","经过","可以","delete","这","&&","猜测","在","新建","check","beego","为","astaxie","unix","next","query","未","虽然","存在","结构","该","select","getauth","账号","use","a","着","atricles","message","密钥","v1","因此","interface","。","中间件","byte","error","generatetoken","parsetoken","gin","code","put","这些","web","内","_","com","add","请求","05","signedstring","访问","auth","runmode","{","字符","如何","127.0","fail","即当","方式","post","cropto","isexist","first","routers","文件","func","下","h","nil","parsewithclaims","给","体","data","log","安全","newwithclaims","方法","验证","else","required","r","addarticle","issuer","下载"],"title":"go-gin-example 05：JWT","title_tokens":["example","05"," ","gin","jwt","go","：","-"]},{"location":"Golang/Project/go-gin-example/05 JWT/#go-gin-example-05jwt","text":"","text_tokens":[],"title":"go-gin-example 05：JWT","title_tokens":["example","05"," ","gin","jwt","go","：","-"]},{"location":"Golang/Project/go-gin-example/05 JWT/#jwt","text":"当前的API接口虽然编写好了，但是这些API可以被随意调用，这样子是不安全的。因此需要通过 jwt-go 的方式来解决","text_tokens":["来","随意","当前","解决"," ","虽然","jwt","go","了","好","调用","被","因此","，","api","。","但是","这些","的","接口","通过","编写","需要","样子","方式","是","可以","这","安全","-","不"],"title":"为什么要JWT","title_tokens":["要","jwt","为什么","什么"]},{"location":"Golang/Project/go-gin-example/05 JWT/#jwt_1","text":"下载依赖包： go get -u github.com/dgrijalva/jwt-go 编写 ./pkg/util 下的新建 jwt.go 文件 其中该工具包主要包含 生成Token 、 解析Token 功能 NewWithClaims 中加密方法有 SigningMethodHS256 ， SigningMethodHS384 、 SigningMethodHS512 三种 cropto.Hash 方案 package util import ( setting \"go-gin-example/pkg/settings\" \"time\" \"github.com/dgrijalva/jwt-go\" ) var jwtSecret = [] byte ( setting . JwtSecret ) // Claims 声明Claims结构体 type Claims struct { Username string `json: \"username\"` Password string `json: \"password\"` jwt . StandardClaims } // GenerateToken 生成密钥 func GenerateToken ( username , password string ) ( string , error ) { nowTime := time . Now () expireTime := nowTime . Add ( 3 * time . Hour ) claims := Claims { username , password , jwt . StandardClaims { ExpiresAt : expireTime . Unix (), Issuer : \"gin-blog\" , }, } // 对claims 进行加密 tokenClaims := jwt . NewWithClaims ( jwt . SigningMethodHS256 , claims ) // 获得加密后的token // 猜测为生成一个加密后的字符串给jwtSecret token , err := tokenClaims . SignedString ( jwtSecret ) return token , err } // ParseToken 解析密钥 func ParseToken ( token string ) ( * Claims , error ) { tokenClaims , err := jwt . ParseWithClaims ( token , & Claims {}, func ( token * jwt . Token ) ( interface {}, error ) { return jwtSecret , nil }) if tokenClaims != nil { if claims , ok := tokenClaims . Claims .( * Claims ); ok && tokenClaims . Valid { return claims , nil } } return nil , err } 编写Gin中间件，在 middleware 下新建 jwt 目录，在其中新建 jwt.go 文件写入 package jwt import ( \"go-gin-example/pkg/e\" \"go-gin-example/pkg/util\" \"net/http\" \"time\" \"github.com/gin-gonic/gin\" ) // JWT json web token func JWT () gin . HandlerFunc { return func ( c * gin . Context ) { var code int var data interface {} code = e . SUCCESS token := c . Query ( \"token\" ) if token == \"\" { code = e . INVALID_PARAMS } else { claims , err := util . ParseToken ( token ) if err != nil { code = e . ERROR_AUTH_CHECK_TOKEN_FAIL } else if time . Now (). Unix () > claims . ExpiresAt { code = e . ERROR_AUTH_CHECK_TOKEN_TIMEOUT } } if code != e . SUCCESS { c . JSON ( http . StatusUnauthorized , gin . H { \"code\" : code , \"msg\" : e . GetMsg ( code ), \"data\" : data , }) // 通过Abort确保当前的handler未被调用, 即当验证不正确的时候丢弃掉该处理 c . Abort () return } c . Next () } } 获得token，在 ./models 下新建 auth.go 文件写入 package models // Auth Token认证 type Auth struct { ID int `gorm:\"primary_key\" json:\"id\"` Username string `json:\"username\"` Password string `json:\"password\"` } // CheckAuth 验证token func CheckAuth ( username , password string ) bool { var auth Auth db . Select ( \"id\" ). Where ( Auth { Username : username , Password : password }). First ( & auth ) if auth . ID > 0 { return true } return false } 在 ./api 下新建 auth.go 文件写入 package api import ( \"go-gin-example/models\" \"go-gin-example/pkg/e\" \"go-gin-example/pkg/util\" \"log\" \"net/http\" \"github.com/astaxie/beego/validation\" \"github.com/gin-gonic/gin\" ) type auth struct { Username string `valid: \"Required; MaxSize(50)\" ` Password string `valid: \"Required; MaxSize(50)\"` } // GetAuth 获取认证 func GetAuth ( c * gin . Context ) { username := c . Query ( \"username\" ) password := c . Query ( \"password\" ) valid := validation . Validation {} a := auth { Username : username , Password : password } ok , _ := valid . Valid ( & a ) data := make ( map [ string ] interface {}) code := e . INVALID_PARAMS if ok { isExist := models . CheckAuth ( username , password ) // 如果存在该账号 if isExist { token , err := util . GenerateToken ( username , password ) if err != nil { code = e . ERROR_AUTH_TOKEN } else { data [ \"token\" ] = token code = e . SUCCESS } } else { // 不存在账号 code = e . ERROR_AUTH } } else { for _ , err := range valid . Errors { log . Println ( err . Key , err . Message ) } } c . JSON ( http . StatusOK , gin . H { \"code\" : code , \"msg\" : e . GetMsg ( code ), \"data\" : data , }) } 修改 router.go 文件 package routers import ( \"go-gin-example/middleware/jwt\" setting \"go-gin-example/pkg/settings\" \"go-gin-example/routers/api\" v1 \"go-gin-example/routers/api/v1\" \"github.com/gin-gonic/gin\" ) // InitRouter 初始化路由 func InitRouter () * gin . Engine { r := gin . New () r . Use ( gin . Logger ()) r . Use ( gin . Recovery ()) gin . SetMode ( setting . RunMode ) // 调用认证接口 r . GET ( \"/auth\" , api . GetAuth ) apiv1 := r . Group ( \"/api/v1\" ) // Group内的所有请求都需要经过JWT apiv1 . Use ( jwt . JWT ()) { apiv1 . GET ( \"/tags\" , v1 . GetTags ) apiv1 . POST ( \"/tags\" , v1 . AddTag ) apiv1 . PUT ( \"/tags/:id\" , v1 . EditTag ) apiv1 . DELETE ( \"/tags/:id\" , v1 . DeleteTag ) apiv1 . GET ( \"/articles\" , v1 . GetArticles ) apiv1 . GET ( \"/articles/:id\" , v1 . GetArticle ) apiv1 . POST ( \"/articles\" , v1 . AddArticle ) apiv1 . PUT ( \"/articles/:id\" , v1 . EditTag ) apiv1 . DELETE ( \"/atricles/:id\" , v1 . DeleteTag ) } return r } 调用 访问 http://127.0.0.1:8000/auth?username=test&password=test123456 获得token 带着token访问api http://127.0.0.1:8000/api/v1/articles?token=eyJhbGci...","text_tokens":["\"","中间","&","生成","gettags","map","有","如果","go","invalid","*","deletetag","recovery","new","false","setting","timeout","engine","logger","middleware","return","int","工具","msg","处理","success","c","edittag","、","router","接口","articles","validation","http",")","var","time","声明","type",",","字符串","写入","err","abort","获取","包含","后","掉","import","}","nowtime","修改","-","所有"," ","方案",":","功能","都","getarticle","package","!","依赖","工具包","dgrijalva","blog",">","token","丢弃","json","tokenclaims","时候","id","0","带","调用","...","settings","对","params","获得","password","gorm","test","中","util","加密","now","目录","net","apiv1","group","(","handlerfunc","主要","github","包","的","example","standardclaims",";","gonic","key","[","eyjhbgci","get","编写","getmsg","for","expiresat","e","`","50","models","其中","where","primary","checkauth","initrouter","bool","true","?","jwtsecret","setmode","test123456","3","ok","=","struct","不","db","println","signingmethodhs512","确保","三种",".","当前","8000","context","handler","expiretime","jwt","errors","]","路由","make","解析","statusok","tags","被","，","一个","hash","string","hour","statusunauthorized","api","signingmethodhs384","认证","pkg","u","：","username","claims","valid","range","通过","maxsize","getarticles","0.1","需要","初始","addtag","初始化","if","正确","进行","signingmethodhs256","/","经过","delete","&&","猜测","在","新建","check","beego","为","astaxie","unix","next","query","未","存在","结构","该","select","getauth","账号","use","a","着","atricles","message","密钥","v1","interface","中间件","byte","error","generatetoken","parsetoken","gin","code","put","web","内","_","com","add","请求","signedstring","访问","auth","runmode","{","字符","127.0","fail","即当","post","cropto","isexist","first","routers","文件","func","下","h","nil","parsewithclaims","给","体","data","log","required","newwithclaims","方法","验证","else","r","addarticle","issuer","下载"],"title":"如何使用JWT","title_tokens":["jwt","如何","使用"]},{"location":"Golang/Project/go-gin-example/08 Swagger/","text":"go-gin-example 08： Swagger Swagger是什么? 接口生成器：自动生成接口文档 如何在golang中使用Swagger 安装 安装swag go get -u github.com/swaggo/swag/cmd/swag ，如果没有将 $GOROOT/bin 添加到 $PATH 中，则需要将swag的可执行文件移到 $GOBIN 中 验证是否安装成功 $ swag -v swag version v1.6.3 安装gin-swagger go get -u github.com/swaggo/gin-swagger go get -u github.com/swaggo/gin-swagger/swaggerFiles 编写swag // Response 定义 swag 文档返回的结构体 type Response struct { Code int ` json : \" code \" ` Msg string ` json : \" msg \" ` Data interface {} ` json : \" data \" ` } // GetArticles 获取多个文章 // @ Summary 获取多个文章 // @ Produce json // @ Param tag_id body int false \" TagID \" // @ Param state body int false \" State \" // @ Param created_by body int false \" CreatedBy \" // @ Success 200 { object } Response // @ Failure 500 { object } Response // @ Router / api / v1 / articles [ get ] func GetArticles ( c * gin . Context ) { data : = make ( map [ string ] interface {} ) maps : = make ( map [ string ] interface {} ) valid : = validation . Validation {} var state = - 1 if arg : = c . Query ( \" state \" ) ; arg != \"\" { state = com . StrTo ( arg ) . MustInt () maps [ \" state \" ] = state valid . Range ( state , 0 , 1 , \" state \" ) . Message ( \" 状态只允许0或1 \" ) } var tagID = - 1 if arg : = c . Query ( \" tag_id \" ) ; arg != \"\" { tagID = com . StrTo ( arg ) . MustInt () maps [ \" tag_id \" ] = tagID valid . Min ( tagID , 1 , \" tag_id \" ) . Message ( \" 标签ID必须大于0 \" ) } code : = e . INVALID_PARAMS if ! valid . HasErrors () { data [ \" list \" ] = models . GetArticles ( util . GetPage ( c ) , setting . PageSize , maps ) data [ \" total \" ] = models . GetTagTotal ( maps ) code = e . SUCCESS } else { for _ , err : = range valid . Errors { log . Printf ( \" err.key:%s, err.message:%s \" , err . Key , err . Message ) } } c . JSON ( http . StatusOK , gin . H { \" code \" : code , \" msg \" : e . GetMsg ( code ) , \" data \" : data , } ) } 格式 // @Summary API描述 // @Produce json[生成..内容] // @Param id path/body/query int[type] false/true \"ID\"[程序中对应变量名字] // @Success 200 string \"ok\" --成功返回信息 // @Failure 500 string \"bad\" --失败返回信息 // @Routers api/v1/article/{id} [GET] 请求id, 请求方法 效果 访问 http://127.0.0.1:8000/swagger/index.html","text_tokens":["\"","bad","生成","500","或","golang","swag","map","如果","go","swagger","invalid","v","*","false","setting","int","添加","文章","msg","produce","success","c","router","$","接口","articles","validation","http","type",")","var",",","err","获取","效果","可执行文件","index","}","-","total","对应"," ",":","标签","haserrors","goroot","!","成器","@","id","swaggerfiles","json","0","arg","使用","failure","html","params","返回","中","util","cmd","(","状态","key","github","example","的",";","[","get","编写","for","文档","getmsg","自动","e","多个","只","createdby","`","object","定义","models","list","什么","格式","则","?","true","必须","3","执行","path","ok","=","struct","描述","%","变量",".","1","8000","context","信息","article","param","gettagtotal","errors","内容","state","]","make","statusok","到","没有","，","api","string","pagesize","u","：","tagid","valid","名字","range","getarticles","printf","0.1","需要","将","..","if","失败","是","安装","/","swaggo","s","在","08","bin","移","query","mustint","tag","行文","是否","结构","message","response","summary","by","v1","min","gobin","interface","允许","maps","body","生成器","gin","成功","code","200","v1.6","_","com","请求","访问","version","{","如何","127.0","strto","程序","created","routers","文件","大于","func","h","getpage","体","data","log","验证","方法","else"],"title":"go-gin-example 08： Swagger","title_tokens":["example"," ","gin","go","：","-","swagger","08"]},{"location":"Golang/Project/go-gin-example/08 Swagger/#go-gin-example-08-swagger","text":"","text_tokens":[],"title":"go-gin-example 08： Swagger","title_tokens":["example"," ","gin","go","：","-","swagger","08"]},{"location":"Golang/Project/go-gin-example/08 Swagger/#swagger","text":"接口生成器：自动生成接口文档","text_tokens":["接口","文档","生成","自动","成器","生成器","："],"title":"Swagger是什么?","title_tokens":["swagger","什么","是","?"]},{"location":"Golang/Project/go-gin-example/08 Swagger/#golangswagger","text":"","text_tokens":[],"title":"如何在golang中使用Swagger","title_tokens":["中","golang","如何","在","swagger","使用"]},{"location":"Golang/Project/go-gin-example/08 Swagger/#_1","text":"安装swag go get -u github.com/swaggo/swag/cmd/swag ，如果没有将 $GOROOT/bin 添加到 $PATH 中，则需要将swag的可执行文件移到 $GOBIN 中 验证是否安装成功 $ swag -v swag version v1.6.3 安装gin-swagger go get -u github.com/swaggo/gin-swagger go get -u github.com/swaggo/gin-swagger/swaggerFiles","text_tokens":["bin","移","."," ","行文","goroot","是否","swag","如果","go","swagger","swaggerfiles","到","v","没有","，","gobin","中","cmd","添加","u","成功","gin","github","v1.6","的","com","$","get","version","需要","将","安装","/","文件","则","可执行文件","swaggo","执行","验证","path","3","-"],"title":"安装","title_tokens":["安装"]},{"location":"Golang/Project/go-gin-example/08 Swagger/#swag","text":"// Response 定义 swag 文档返回的结构体 type Response struct { Code int ` json : \" code \" ` Msg string ` json : \" msg \" ` Data interface {} ` json : \" data \" ` } // GetArticles 获取多个文章 // @ Summary 获取多个文章 // @ Produce json // @ Param tag_id body int false \" TagID \" // @ Param state body int false \" State \" // @ Param created_by body int false \" CreatedBy \" // @ Success 200 { object } Response // @ Failure 500 { object } Response // @ Router / api / v1 / articles [ get ] func GetArticles ( c * gin . Context ) { data : = make ( map [ string ] interface {} ) maps : = make ( map [ string ] interface {} ) valid : = validation . Validation {} var state = - 1 if arg : = c . Query ( \" state \" ) ; arg != \"\" { state = com . StrTo ( arg ) . MustInt () maps [ \" state \" ] = state valid . Range ( state , 0 , 1 , \" state \" ) . Message ( \" 状态只允许0或1 \" ) } var tagID = - 1 if arg : = c . Query ( \" tag_id \" ) ; arg != \"\" { tagID = com . StrTo ( arg ) . MustInt () maps [ \" tag_id \" ] = tagID valid . Min ( tagID , 1 , \" tag_id \" ) . Message ( \" 标签ID必须大于0 \" ) } code : = e . INVALID_PARAMS if ! valid . HasErrors () { data [ \" list \" ] = models . GetArticles ( util . GetPage ( c ) , setting . PageSize , maps ) data [ \" total \" ] = models . GetTagTotal ( maps ) code = e . SUCCESS } else { for _ , err : = range valid . Errors { log . Printf ( \" err.key:%s, err.message:%s \" , err . Key , err . Message ) } } c . JSON ( http . StatusOK , gin . H { \" code \" : code , \" msg \" : e . GetMsg ( code ) , \" data \" : data , } ) } 格式 // @Summary API描述 // @Produce json[生成..内容] // @Param id path/body/query int[type] false/true \"ID\"[程序中对应变量名字] // @Success 200 string \"ok\" --成功返回信息 // @Failure 500 string \"bad\" --失败返回信息 // @Routers api/v1/article/{id} [GET] 请求id, 请求方法","text_tokens":["\"","bad","生成","500","或","swag","map","invalid","*","false","setting","int","文章","msg","produce","success","c","router","articles","validation","http","type",")","var",",","err","获取","}","-","total","对应"," ",":","标签","haserrors","!","@","id","json","0","arg","failure","params","返回","中","util","(","状态","key","的",";","[","get","getmsg","for","文档","e","多个","只","createdby","`","object","定义","models","list","格式","true","必须","path","ok","=","struct","描述","%","变量",".","1","context","信息","article","param","gettagtotal","errors","内容","state","]","make","statusok","api","string","pagesize","tagid","valid","名字","range","getarticles","printf","..","if","失败","/","s","query","mustint","tag","结构","message","response","summary","by","v1","min","interface","允许","maps","body","成功","code","gin","200","_","com","请求","{","strto","程序","created","routers","大于","func","h","getpage","体","data","log","方法","else"],"title":"编写swag","title_tokens":["编写","swag"]},{"location":"Golang/Project/go-gin-example/08 Swagger/#_2","text":"访问 http://127.0.0.1:8000/swagger/index.html","text_tokens":["/","访问","."," ",":","8000","index","0.1","127.0","http","swagger","html"],"title":"效果","title_tokens":["效果"]},{"location":"Golang/Project/go-gin-example/09 Docker/","text":"go-gin-example 09：Docker Docker是什么 Docker is a set of platform as a service (PaaS) products that use OS-level virtualization to deliver software in packages called containers.[6] Containers are isolated from one another and bundle their own software, libraries and configuration files; they can communicate with each other through well-defined channels.[7] All containers are run by a single operating-system kernel and are thus more lightweight than virtual machines.[8] Docker是Paas的产品, 通过被成为 容器 的 系统级别 的虚拟化交付软件. 如何使用Docker 安装Docker(WIN10 PRO) 右键WINDOWS - 应用和功能 - 程序和功能 - 启用或关闭WINDOS功能 - 开启Hyper-V 开启 Hyper-V 可能导致 ShadowSocksR 端口被占用 官网 Docker基本指令 编写Dockerfile FROM golang:latest ENV GOPROXY https://goproxy.cn,direct WORKDIR $GOPATH /src/go-gin-example COPY . $GOPATH /src/go-gin-example RUN go build . EXPOSE 8000 ENTRYPOINT [ \"./go-gin-example\" ] FROM : 指定基础镜像, 该指令必须要有,且得为第一条 WORKDIR : 指定工作目录路径, 若目录不存在, 则会创建改目录 COPY : 源路径 ... 目标路径, COPY 指令将 Dockerfile 文件所存在的上下文目录 复制 到目标路径位置 RUN : 执行命令 EXPOSE : 声明 运行时容器 提供服务端口, 仅仅是一个 声明 , 不会因为这个声明而开启这个端口 ENTRYPOINT : 指定 容器 启动程序的及参数(执行 ./go-gin-example) 运行 docker build - t gin - blog - docker . docker images docker run - p 8000 : 8000 gin - blog - docker 在 . 当前环境运行 docker build 创建/构建镜像, -t 指定名称 docker images 查看镜像是否创建成功 在本地8000端口运行容器 发现 dial tcp 127.0.0.1:3306: connect: connection refused 错误 配置Mysql Docker docker pull mysql docker run --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root -d mysql 拉取mysql镜像 配置mysql端口 修改配置文件 conf.ini [database] TYPE = mysql USER = root PASSWORD = rootroot HOST = mysql:3306 NAME = blog TABLE_PREFIX = blog_ 关联Golang容器和Mysql容器 docker run --link mysql:mysql -p 8000:8000 gin-blog-docker 效果","text_tokens":["\"","database","defined","that","发现","host","关联","docker","或","golang","有","go","v","rootroot","容器","in","软件","成为","env","应用","镜像","images","p","下文","要","导致","deliver","libraries","one","cn","右键","可能","启用","workdir","$","pro","d","6",")",",","type","声明","mysql","are","all","第一条","connection","效果","system","src","user","virtualization","09","well","channels","of","service","os","-","修改","table","connect"," ",":","功能","产品","位置","blog","operating","as","thus","machines","指令","使用","关闭","...","改","own","password","configuration","执行命令","名称","copy","因为","目录","conf","查看","(","这个","会","example",";","的","虚拟","[","dockerfile","编写","other","提供","name","containers","e","和","link","level","什么","仅仅","占用","communicate","hyper","than","their","latest","则","源","时","virtual","dial","必须","root","基本","执行","第一","服务","windows","windos","entrypoint","错误","不","=","another",".","交付","当前","and","to","8000","上下","isolated","开启","]","创建","goproxy","不会","构建","run","到","被","ini","with","gopath","一个","can","3306","shadowsocksr","through","配置","：","路径","目标","端口","基础","bundle","lightweight","refused","通过","参数","一条","files","0.1","将","set","是","安装","/","指定","tcp","及","single","复制","启动","platform","在","https","is","得","官网","为","工作","存在","use","win10","该","命令","而","是否","software","a","且","kernel","called","build","上下文","by","拉取","环境","direct","若","they","more","7","成功","gin","运行","系统","_","paas","所","本地","each","如何","127.0","from","products","程序","文件","prefix","配置文件","expose","t","packages","8","虚拟化","级别","pull"],"title":"go-gin-example 09：Docker","title_tokens":["example"," ","gin","docker","09","go","：","-"]},{"location":"Golang/Project/go-gin-example/09 Docker/#go-gin-example-09docker","text":"","text_tokens":[],"title":"go-gin-example 09：Docker","title_tokens":["example"," ","gin","docker","09","go","：","-"]},{"location":"Golang/Project/go-gin-example/09 Docker/#docker","text":"Docker is a set of platform as a service (PaaS) products that use OS-level virtualization to deliver software in packages called containers.[6] Containers are isolated from one another and bundle their own software, libraries and configuration files; they can communicate with each other through well-defined channels.[7] All containers are run by a single operating-system kernel and are thus more lightweight than virtual machines.[8] Docker是Paas的产品, 通过被成为 容器 的 系统级别 的虚拟化交付软件.","text_tokens":["defined","that","docker","容器","in","软件","成为","deliver","libraries","one","6",")",",","are","all","system","virtualization","service","of","channels","well","os","-"," ","产品","operating","as","thus","machines","own","configuration","(","的",";","虚拟","[","other","containers","level","communicate","than","their","virtual","another",".","交付","and","to","isolated","]","run","被","with","can","through","bundle","lightweight","通过","files","set","是","single","platform","is","use","software","a","kernel","called","by","they","more","7","系统","paas","each","from","products","packages","8","虚拟化","级别"],"title":"Docker是什么","title_tokens":["什么","是","docker"]},{"location":"Golang/Project/go-gin-example/09 Docker/#docker_1","text":"","text_tokens":[],"title":"如何使用Docker","title_tokens":["如何","使用","docker"]},{"location":"Golang/Project/go-gin-example/09 Docker/#dockerwin10-pro","text":"右键WINDOWS - 应用和功能 - 程序和功能 - 启用或关闭WINDOS功能 - 开启Hyper-V 开启 Hyper-V 可能导致 ShadowSocksR 端口被占用 官网","text_tokens":[" ","功能","或","开启","关闭","v","被","应用","shadowsocksr","端口","导致","右键","可能","启用","和","程序","占用","hyper","windows","windos","-","官网"],"title":"安装Docker(WIN10 PRO)","title_tokens":["安装"," ","pro","docker","win10","(",")"]},{"location":"Golang/Project/go-gin-example/09 Docker/#docker_2","text":"","text_tokens":[],"title":"Docker基本指令","title_tokens":["基本","指令","docker"]},{"location":"Golang/Project/go-gin-example/09 Docker/#dockerfile","text":"FROM golang:latest ENV GOPROXY https://goproxy.cn,direct WORKDIR $GOPATH /src/go-gin-example COPY . $GOPATH /src/go-gin-example RUN go build . EXPOSE 8000 ENTRYPOINT [ \"./go-gin-example\" ] FROM : 指定基础镜像, 该指令必须要有,且得为第一条 WORKDIR : 指定工作目录路径, 若目录不存在, 则会创建改目录 COPY : 源路径 ... 目标路径, COPY 指令将 Dockerfile 文件所存在的上下文目录 复制 到目标路径位置 RUN : 执行命令 EXPOSE : 声明 运行时容器 提供服务端口, 仅仅是一个 声明 , 不会因为这个声明而开启这个端口 ENTRYPOINT : 指定 容器 启动程序的及参数(执行 ./go-gin-example)","text_tokens":["\"","golang","有","go","容器","镜像","env","下文","要","workdir","得","cn","$",",",")","声明","第一条","src","-"," ",":","位置","指令","...","改","执行命令","copy","因为","目录","(","这个","会","example","的","[","dockerfile","提供","仅仅","则","源","latest","时","必须","执行","服务","第一","entrypoint","不",".","8000","上下","创建","不会","]","开启","goproxy","run","到","gopath","一个","路径","目标","端口","基础","参数","一条","将","是","/","指定","及","复制","启动","https","为","工作","存在","而","该","命令","且","build","上下文","direct","若","gin","运行","所","from","程序","文件","expose"],"title":"编写Dockerfile","title_tokens":["编写","dockerfile"]},{"location":"Golang/Project/go-gin-example/09 Docker/#_1","text":"docker build - t gin - blog - docker . docker images docker run - p 8000 : 8000 gin - blog - docker 在 . 当前环境运行 docker build 创建/构建镜像, -t 指定名称 docker images 查看镜像是否创建成功 在本地8000端口运行容器 发现 dial tcp 127.0.0.1:3306: connect: connection refused 错误","text_tokens":["connect",".","当前"," ",":","8000","发现","docker","是否","blog","创建","构建","错误","run","build","容器","环境","名称","镜像","3306","images","p","查看","成功","gin","运行","端口","refused","本地","0.1","127.0",",","/","指定","dial","tcp","t","connection","在","-"],"title":"运行","title_tokens":["运行"]},{"location":"Golang/Project/go-gin-example/09 Docker/#mysql-docker","text":"docker pull mysql docker run --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root -d mysql 拉取mysql镜像 配置mysql端口","text_tokens":[" ",":","docker","run","拉取","password","镜像","3306","p","配置","端口","_","d","name","e","mysql","root","=","-","pull"],"title":"配置Mysql Docker","title_tokens":[" ","mysql","配置","docker"]},{"location":"Golang/Project/go-gin-example/09 Docker/#confini","text":"[database] TYPE = mysql USER = root PASSWORD = rootroot HOST = mysql:3306 NAME = blog TABLE_PREFIX = blog_","text_tokens":["database"," ",":","host","blog","]","rootroot","password","3306","_","[","name","type","mysql","prefix","root","user","table","="],"title":"修改配置文件conf.ini","title_tokens":["文件","ini","配置文件",".","修改","conf","配置"]},{"location":"Golang/Project/go-gin-example/09 Docker/#golangmysql","text":"docker run --link mysql:mysql -p 8000:8000 gin-blog-docker","text_tokens":["-","run"," ",":","8000","docker","mysql","blog","p","gin","link"],"title":"关联Golang容器和Mysql容器","title_tokens":["容器","关联","golang","和","mysql"]},{"location":"Golang/Project/go-gin-example/09 Docker/#_2","text":"","text_tokens":[],"title":"效果","title_tokens":["效果"]},{"location":"Golang/Project/go-gin-example/10 GORM-Callback/","text":"go-gin-example 10： GORM-Callback 定制GORM Callbacks GORM Callback 是什么 You could define callback methods to pointer of model struct, it will be called when creating, updating, querying, deleting, if any callback returns an error, gorm will stop future operations and rollback all changes. 可以给模型结构体指针定义回调函数, 它将会在被创建/更新/查询/删除的时候调用, 如果回调返回了错误, gorm会停止未来行为操作并且回退所有改变. 之前程序未实现 Callback 方法, 需要为所有文件单独写一次 BeforeCreate 、 BeforeUpdate 方法 使用 gorm支持的callback方法 创建：BeforeSave、BeforeCreate、AfterCreate、AfterSave 更新：BeforeSave、BeforeUpdate、AfterUpdate、AfterSave 删除：BeforeDelete、AfterDelete 查询：AfterFind 定义callback 在 model.go 文件中定义 // updateTimeStampForCreateCallback will set `CreatedOn`, `ModifiedOn` when creating func updateTimeStampForCreateCallback ( scope * gorm . Scope ) { if ! scope . HasError () { nowTime := time . Now (). Unix () if createTimeField , ok := scope . FieldByName ( \"CreatedOn\" ); ok { if createTimeField . IsBlank { createTimeField . Set ( nowTime ) } } if modifyTimeField , ok := scope . FieldByName ( \"ModifiedOn\" ); ok { if modifyTimeField . IsBlank { modifyTimeField . Set ( nowTime ) } } } } // updateTimeStampForUpdateCallback will set `ModifyTime` when updating func updateTimeStampForUpdateCallback ( scope * gorm . Scope ) { if _ , ok := scope . Get ( \"gorm:update_column\" ); ! ok { scope . SetColumn ( \"ModifiedOn\" , time . Now (). Unix ()) } } 通过 scope.FieldByName(name) 判断是否存在相关字段, 该方法通过 scope.Fields() 获取所有字段 通过 .IsBlank 判断值是否为空 通过 .Set(interface{}) 设置相关值 通过 scope.Get() 获取参数的参数值, 案例中回去查找 gorm:update_column 这个字段的属性 通过 scope.SetColumn(Field, value) 设定字段的值 调用callback 在 model.go 的 ini 函数中注册callback db . Callback (). Create (). Replace ( \"gorm:update_time_stamp\" , updateTimeStampForCreateCallback ) db . Callback (). Update (). Replace ( \"gorm:update_time_stamp\" , updateTimeStampForUpdateCallback ) 效果 当程序写了 Callback 方法的时候, 当GORM执行到相关的操作会自动触发相应的 Callback 方法 拓展 软删除, 添加删除时间, 为 model.go 的 Model 结构体添加 DeletedOn 字段 type Model struct { ID int `gorm:\"primary_key\" json:\"id\"` CreatedOn int `json:\"created_on\"` ModifiedOn int `json:\"modified_on\"` DeletedOn int `json:\"deleted_on\"` } func deleteCallback ( scope * gorm . Scope ) { if ! scope . HasError () { var extraOption string if str , ok := scope . Get ( \"gorm:delete_option\" ); ok { extraOption = fmt . Sprint ( str ) } deletedOnField , hasDeletedOnField := scope . FieldByName ( \"DeletedOn\" ) if ! scope . Search . Unscoped && hasDeletedOnField { scope . Raw ( fmt . Sprintf ( \"UPDATE %v SET %v=%v%v%v\" , scope . QuotedTableName (), scope . Quote ( deletedOnField . DBName ), scope . AddToVars ( time . Now (). Unix ()), addExtraSpaceIfExist ( scope . CombinedConditionSql ()), addExtraSpaceIfExist ( extraOption ), )). Exec () } else { scope . Raw ( fmt . Sprintf ( \"DELETE FROM %v%v%v\" , scope . QuotedTableName (), addExtraSpaceIfExist ( scope . CombinedConditionSql ()), addExtraSpaceIfExist ( extraOption ), )). Exec () } } } func addExtraSpaceIfExist ( str string ) string { if str != \"\" { return \" \" + str } return \"\" } 在 model.go 的 ini函数 中添加 db.Callback().Delete().Replace(\"gorm:delete\", deleteCallback) 1. scope.QuotedTableName() 返回引用的表名 2. scope.Raw() 构建原生sql 3. fmt.Sprintf() 格式化并且返回格式化后的字符串数据 4. scope.AddToVars(value) 为字段添加参数 5. scope.Quote() 转义 6. scope 当你在数据库中文完成任何操作, scope包含了当前操作信息 // Scope contain current operation's information when you perform any operation on the database type Scope struct { Search * search Value interface {} SQL string SQLVars [] interface {} db * DB instanceID string primaryKeyField * Field skipLeft bool fields * [] * Field selectAttrs * [] string } REF: official: callback in gorm","text_tokens":["skipleft","\"","设置","addtovars","changes","beforesave","database","aftersave","modifytimefield","如果","注册","转义","go","exec","*","create","v","10","更新","判断","aftercreate","拓展","据库","when","in","查找","return","int","触发","createtimefield","添加","'","querying","operations","an","数值","、","afterfind","selectattrs","并且","deleted","on","quotedtablename","实现","6","createdon",",",")","stop","updatetimestampforcreatecallback","time","type","var","fields","字符串","为空","all","获取","效果","后","引用","raw","4","包含","}","支持","define","of","nowtime","updatetimestampforupdatecallback","回退","-","所有"," ","methods",":","information","!","id","fmt","json","时候","使用","调用","column","设定","任何","gorm","返回","一次","中","now","(","field","这个","会","key","extraoption","example","的","creating",";","相关","参数值","[","get","数据","any","name","自动","deletedon","你","returns","`","定义","will","什么","you","格式","primary","primarykeyfield","deleting","bool","deletecallback","3","执行","deletedonfield","ok","modifiedon","之前","错误","=","struct","perform","db","%","段","回调",".","1","当前","and","to","未来","+","模型","中文","信息","current","sqlvars","创建","时间","构建","停止","]","了","到","update","被","ini","be","查询","string","属性","the","案例","定制","：","setcolumn","could","instanceid","当","原生","通过","beforedelete","option","参数","软","unscoped","pointer","需要","将","if","set","hasdeletedonfield","是","/","可以","delete","dbname","combinedconditionsql","beforeupdate","modifytime","&&","fieldbyname","删除","search","s","stamp","在","完成","格式化","为","sprint","callbacks","表名","unix","scope","model","未","值","函数","操作","replace","指针","str","存在","结构","是否","该","called","value","interface","单独","future","error","rollback","gin","addextraspaceifexist","it","_","afterdelete","quote","2","v%","sql","ref","official","写","回去","{","5","haserror","字段","sprintf","字符","isblank","from","相应","callback","改变","程序","created","modified","文件","func","字","beforecreate","给","体","updating","它","afterupdate","数据库","方法","contain","else","operation","行为"],"title":"go-gin-example 10： GORM-Callback","title_tokens":["example","10"," ","gin","gorm","go","：","callback","-"]},{"location":"Golang/Project/go-gin-example/10 GORM-Callback/#go-gin-example-10-gorm-callback","text":"","text_tokens":[],"title":"go-gin-example 10： GORM-Callback","title_tokens":["example","10"," ","gin","gorm","go","：","callback","-"]},{"location":"Golang/Project/go-gin-example/10 GORM-Callback/#gorm-callbacks","text":"","text_tokens":[],"title":"定制GORM Callbacks","title_tokens":["callbacks","gorm","定制"," "]},{"location":"Golang/Project/go-gin-example/10 GORM-Callback/#gorm-callback","text":"You could define callback methods to pointer of model struct, it will be called when creating, updating, querying, deleting, if any callback returns an error, gorm will stop future operations and rollback all changes. 可以给模型结构体指针定义回调函数, 它将会在被创建/更新/查询/删除的时候调用, 如果回调返回了错误, gorm会停止未来行为操作并且回退所有改变. 之前程序未实现 Callback 方法, 需要为所有文件单独写一次 BeforeCreate 、 BeforeUpdate 方法","text_tokens":["changes","如果","更新","when","querying","operations","an","、","并且","实现",",","stop","all","define","of","回退","所有"," ","methods","时候","调用","gorm","返回","一次","会","的","creating","any","returns","定义","will","you","deleting","之前","错误","struct","回调",".","and","to","未来","模型","创建","停止","了","被","be","查询","could","pointer","需要","将","if","/","可以","beforeupdate","删除","在","为","model","未","函数","操作","指针","结构","called","单独","future","error","rollback","it","写","callback","改变","程序","文件","beforecreate","给","体","updating","它","方法","行为"],"title":"GORM Callback 是什么","title_tokens":["gorm"," ","是","callback","什么"]},{"location":"Golang/Project/go-gin-example/10 GORM-Callback/#_1","text":"","text_tokens":[],"title":"使用","title_tokens":["使用"]},{"location":"Golang/Project/go-gin-example/10 GORM-Callback/#gormcallback","text":"创建：BeforeSave、BeforeCreate、AfterCreate、AfterSave 更新：BeforeSave、BeforeUpdate、AfterUpdate、AfterSave 删除：BeforeDelete、AfterDelete 查询：AfterFind","text_tokens":["afterdelete","更新","、","afterfind","aftercreate","beforedelete","beforesave"," ","beforecreate","beforeupdate","afterupdate","aftersave","查询","删除","创建","："],"title":"gorm支持的callback方法","title_tokens":["的","gorm","方法","支持","callback"]},{"location":"Golang/Project/go-gin-example/10 GORM-Callback/#callback","text":"在 model.go 文件中定义 // updateTimeStampForCreateCallback will set `CreatedOn`, `ModifiedOn` when creating func updateTimeStampForCreateCallback ( scope * gorm . Scope ) { if ! scope . HasError () { nowTime := time . Now (). Unix () if createTimeField , ok := scope . FieldByName ( \"CreatedOn\" ); ok { if createTimeField . IsBlank { createTimeField . Set ( nowTime ) } } if modifyTimeField , ok := scope . FieldByName ( \"ModifiedOn\" ); ok { if modifyTimeField . IsBlank { modifyTimeField . Set ( nowTime ) } } } } // updateTimeStampForUpdateCallback will set `ModifyTime` when updating func updateTimeStampForUpdateCallback ( scope * gorm . Scope ) { if _ , ok := scope . Get ( \"gorm:update_column\" ); ! ok { scope . SetColumn ( \"ModifiedOn\" , time . Now (). Unix ()) } } 通过 scope.FieldByName(name) 判断是否存在相关字段, 该方法通过 scope.Fields() 获取所有字段 通过 .IsBlank 判断值是否为空 通过 .Set(interface{}) 设置相关值 通过 scope.Get() 获取参数的参数值, 案例中回去查找 gorm:update_column 这个字段的属性 通过 scope.SetColumn(Field, value) 设定字段的值","text_tokens":["\"","设置","modifytimefield","go","*","判断","when","查找","createtimefield","数值","createdon",",",")","time","updatetimestampforcreatecallback","fields","为空","获取","}","nowtime","updatetimestampforupdatecallback","所有"," ",":","!","column","设定","gorm","中","now","(","field","这个","的",";","creating","相关","参数值","get","name","`","定义","will","ok","modifiedon","=","段",".","update","属性","案例","setcolumn","通过","参数","if","set","/","modifytime","fieldbyname","在","unix","scope","model","值","存在","是否","该","value","interface","_","回去","{","haserror","字段","isblank","文件","func","字","updating","方法"],"title":"定义callback","title_tokens":["定义","callback"]},{"location":"Golang/Project/go-gin-example/10 GORM-Callback/#callback_1","text":"在 model.go 的 ini 函数中注册callback db . Callback (). Create (). Replace ( \"gorm:update_time_stamp\" , updateTimeStampForCreateCallback ) db . Callback (). Update (). Replace ( \"gorm:update_time_stamp\" , updateTimeStampForUpdateCallback )","text_tokens":["\"","replace",".","model"," ","函数",":","注册","go","create","ini","update","gorm","中","(","的","_",")",",","time","callback","updatetimestampforcreatecallback","updatetimestampforupdatecallback","stamp","在","db"],"title":"调用callback","title_tokens":["调用","callback"]},{"location":"Golang/Project/go-gin-example/10 GORM-Callback/#_2","text":"当程序写了 Callback 方法的时候, 当GORM执行到相关的操作会自动触发相应的 Callback 方法","text_tokens":[" ","操作","时候","了","到","gorm","触发","会","的","相关","当","写","自动",",","相应","callback","程序","执行","方法"],"title":"效果","title_tokens":["效果"]},{"location":"Golang/Project/go-gin-example/10 GORM-Callback/#_3","text":"软删除, 添加删除时间, 为 model.go 的 Model 结构体添加 DeletedOn 字段 type Model struct { ID int `gorm:\"primary_key\" json:\"id\"` CreatedOn int `json:\"created_on\"` ModifiedOn int `json:\"modified_on\"` DeletedOn int `json:\"deleted_on\"` } func deleteCallback ( scope * gorm . Scope ) { if ! scope . HasError () { var extraOption string if str , ok := scope . Get ( \"gorm:delete_option\" ); ok { extraOption = fmt . Sprint ( str ) } deletedOnField , hasDeletedOnField := scope . FieldByName ( \"DeletedOn\" ) if ! scope . Search . Unscoped && hasDeletedOnField { scope . Raw ( fmt . Sprintf ( \"UPDATE %v SET %v=%v%v%v\" , scope . QuotedTableName (), scope . Quote ( deletedOnField . DBName ), scope . AddToVars ( time . Now (). Unix ()), addExtraSpaceIfExist ( scope . CombinedConditionSql ()), addExtraSpaceIfExist ( extraOption ), )). Exec () } else { scope . Raw ( fmt . Sprintf ( \"DELETE FROM %v%v%v\" , scope . QuotedTableName (), addExtraSpaceIfExist ( scope . CombinedConditionSql ()), addExtraSpaceIfExist ( extraOption ), )). Exec () } } } func addExtraSpaceIfExist ( str string ) string { if str != \"\" { return \" \" + str } return \"\" } 在 model.go 的 ini函数 中添加 db.Callback().Delete().Replace(\"gorm:delete\", deleteCallback) 1. scope.QuotedTableName() 返回引用的表名 2. scope.Raw() 构建原生sql 3. fmt.Sprintf() 格式化并且返回格式化后的字符串数据 4. scope.AddToVars(value) 为字段添加参数 5. scope.Quote() 转义 6. scope 当你在数据库中文完成任何操作, scope包含了当前操作信息 // Scope contain current operation's information when you perform any operation on the database type Scope struct { Search * search Value interface {} SQL string SQLVars [] interface {} db * DB instanceID string primaryKeyField * Field skipLeft bool fields * [] * Field selectAttrs * [] string }","text_tokens":["skipleft","\"","addtovars","database","转义","go","exec","*","v","据库","selectattrs","when","return","int","添加","'","deleted","quotedtablename","on","并且","6","createdon","type",",",")","var","time","字符串","fields","4","后","引用","raw","包含","}"," ",":","information","!","id","fmt","json","任何","gorm","返回","中","now","(","field","key","extraoption","的",";","[","get","数据","any","deletedon","你","`","you","格式","primary","primarykeyfield","bool","deletecallback","3","deletedonfield","ok","modifiedon","=","struct","perform","db","%","段",".","1","当前","+","信息","中文","sqlvars","current","时间","构建","]","了","update","ini","string","the","instanceid","原生","当","unscoped","option","软","参数","if","hasdeletedonfield","set","/","delete","dbname","combinedconditionsql","&&","fieldbyname","删除","search","s","完成","在","格式化","sprint","为","表名","unix","scope","model","str","replace","函数","2","操作","结构","value","interface","addextraspaceifexist","_","quote","sql","v%","{","5","haserror","sprintf","字符","from","callback","created","modified","func","字","数据库","operation","体","contain","else"],"title":"拓展","title_tokens":["拓展"]},{"location":"Golang/Project/go-gin-example/10 GORM-Callback/#ref","text":"official: callback in gorm","text_tokens":["official"," ",":","gorm","in","callback"],"title":"REF:","title_tokens":["ref",":"]},{"location":"Golang/Project/go-gin-example/FlowChart/","text":"流程图 请求流程图 URL 请求打到 gin ，由 gin 分发各个请求到相应的接口 接口对应 GET ， POST ， PUT ， DELETE 等多种请求方式 接口接收 URL 中的参数，构造相应的CRUD查询，查询数据库 将数据库返回的数据返回到前端调用者 JWT产生以及认证 生成JWT JWT认证","text_tokens":["对应"," ","多种","生成","流程","jwt","构造","打","各个","到","据库","调用","url","由","，","调用者","查询","返回","中","认证","gin","put","查询数据库","以及","的","流程图","请求","用者","接口","get","参数","数据","产生","crud","将","post","方式","相应","接收","delete","前端","数据库","分发","等"],"title":"流程图","title_tokens":["流程图","流程"]},{"location":"Golang/Project/go-gin-example/FlowChart/#_1","text":"","text_tokens":[],"title":"流程图","title_tokens":["流程图","流程"]},{"location":"Golang/Project/go-gin-example/FlowChart/#_2","text":"URL 请求打到 gin ，由 gin 分发各个请求到相应的接口 接口对应 GET ， POST ， PUT ， DELETE 等多种请求方式 接口接收 URL 中的参数，构造相应的CRUD查询，查询数据库 将数据库返回的数据返回到前端调用者","text_tokens":["对应"," ","多种","构造","打","各个","到","据库","调用","url","由","，","调用者","查询","返回","中","gin","put","查询数据库","的","请求","用者","接口","get","参数","数据","crud","将","post","方式","相应","接收","delete","前端","数据库","分发","等"],"title":"请求流程图","title_tokens":["流程","流程图","请求"]},{"location":"Golang/Project/go-gin-example/FlowChart/#jwt","text":"生成JWT JWT认证","text_tokens":["jwt"," ","认证","生成"],"title":"JWT产生以及认证","title_tokens":["jwt","认证","以及","产生"]},{"location":"Golang/Project/go-gin-example/InterfaceTestInstance/","text":"接口测试实例","text_tokens":["接口","实例","测试"],"title":"接口测试实例","title_tokens":["接口","实例","测试"]},{"location":"Golang/Project/go-gin-example/InterfaceTestInstance/#_1","text":"","text_tokens":[],"title":"接口测试实例","title_tokens":["接口","实例","测试"]},{"location":"Linux/01 FormattingUdisk/","text":"Linux01: 彻底格式化U盘 在 cmd 下输入 diskpart 在弹出的窗口输出 list disk 选择目标磁盘 select disk 1 清除 clean","text_tokens":["彻底","u盘","1","清除"," ",":","select","选择","在","输出","磁盘","窗口","cmd","disk","linux01","目标","的","clean","list","格式","下","弹出","输入","diskpart","格式化"],"title":"Linux01: 彻底格式化U盘","title_tokens":["彻底","格式","u盘"," ",":","linux01","格式化"]},{"location":"Linux/01 FormattingUdisk/#linux01-u","text":"在 cmd 下输入 diskpart 在弹出的窗口输出 list disk 选择目标磁盘 select disk 1 清除 clean","text_tokens":["1","清除"," ","select","选择","在","输出","窗口","cmd","disk","目标","的","clean","diskpart","list","下","弹出","输入","磁盘"],"title":"Linux01: 彻底格式化U盘","title_tokens":["彻底","格式","u盘"," ",":","linux01","格式化"]},{"location":"Linux/02 ChangeSources/","text":"Linux02: 更改Ubuntu源 备份源文件 添加源 更新 sudo cp /etc/apt/sources.list /etc/apt/sources_init.list sudo gedit /etc/apt/sources.list apt-get update","text_tokens":["sudo","."," ",":","linux02","更改","apt","update","更新","init","添加","ubuntu","_","gedit","get","备份","list","/","cp","文件","源","sources","etc","源文件","-"],"title":"Linux02: 更改Ubuntu源","title_tokens":["ubuntu","源"," ",":","linux02","更改"]},{"location":"Linux/02 ChangeSources/#linux02-ubuntu","text":"备份源文件 添加源 更新 sudo cp /etc/apt/sources.list /etc/apt/sources_init.list sudo gedit /etc/apt/sources.list apt-get update","text_tokens":["sudo","."," ","apt","update","更新","init","添加","_","gedit","get","备份","list","/","cp","文件","源","sources","etc","源文件","-"],"title":"Linux02: 更改Ubuntu源","title_tokens":["ubuntu","源"," ",":","linux02","更改"]},{"location":"Others/01 MySql/","text":"使用Mysql 安装 下载 配置 编辑 my.ini 文件 在Mysql安装文件夹下新建 my.ini 文件 [client] # 设置mysql客户端默认字符集 default-character-set = utf8 [mysqld] # 设置3306端口 port = 3306 # 设置mysql的安装目录 basedir = C:/Software/IDE/mysql-8.0.18 # 设置数据存放位置 datadir = C:/Software/IDE/mysql-8.0.18/data # 设置初始密码, 好像没有什么用 default_authentication_plugin = mysql_native_password # 允许最大连接数 max_connections = 20 # 服务端使用的字符集默认为8比特编码的latin1字符集 character-set-server = UTF8MB4 # 创建新表时将使用的默认存储引擎 default-storage-engine = INNODB 其中 datadir 不能有任何文件, 否则启动mysql服务会报错: --initialize specified but the data directory has files in it. Aborting. 配置完成后进入安装路径的 .\\bin 目录, 用管理员身份打开 CMD 键入: mysqld --initialize --console 进行初始化得到密码 输入mysql指令发现 You must reset your password using ALTER USER statement before executing this statement. , 需要通过 alter user user() identified by \"mypwd\"; 修改密码即可. mysql常用指令 [WINDOWS] mysqld install : 安装mysql服务 [WINDOWS管理员] net start mysql : 启动mysql服务 mysql -u root -p : 进入mysql alter user user() identified by \"passwrod\"; : 修改mysql密码 mysql可视化 heidi sql REF: 安装mysql 设置mysql密码","text_tokens":["最大","latin1","设置","\"","发现","用","存储","有","heidi","aborting","initialize","in","engine","管理","不能","p","好像","c","引擎","密码","否则","管理员","连接数","文件夹","connections",",",")","install","mysql","utf8","报错","must","进入","后","user","using","20","修改","-","has"," ",":","身份","console","位置","指令","使用","max","任何","默认","password","before","this","cmd","目录","default","executing","18","net","(","\\","会","的","客户",";","[","数据","authentication","比特","utf8mb4","其中","什么","you","alter","identified","root","客户端","plugin","服务","输入","=","windows","ide","可视",".","可视化","创建","]","server","新表时","ini","没有","服务端","8.0","datadir","the","3306","配置","u","路径","innodb","port","client","端口","通过","mypwd","files","需要","初始","将","初始化","set","进行","安装","/","初始密码","storage","得到","statement","启动","完成","在","新建","native","my","为","bin","即可","mysqld","常用","键入","software","but","字符集","character","by","directory","允许","passwrod","it","存放","_","sql","ref","reset","打开","件夹","字符","连接","specified","编辑","start","文件","your","下","编码","data","8","basedir","#","下载"],"title":"使用Mysql","title_tokens":["mysql","使用"]},{"location":"Others/01 MySql/#mysql","text":"","text_tokens":[],"title":"使用Mysql","title_tokens":["mysql","使用"]},{"location":"Others/01 MySql/#_1","text":"下载","text_tokens":["下载"],"title":"安装","title_tokens":["安装"]},{"location":"Others/01 MySql/#_2","text":"编辑 my.ini 文件 在Mysql安装文件夹下新建 my.ini 文件 [client] # 设置mysql客户端默认字符集 default-character-set = utf8 [mysqld] # 设置3306端口 port = 3306 # 设置mysql的安装目录 basedir = C:/Software/IDE/mysql-8.0.18 # 设置数据存放位置 datadir = C:/Software/IDE/mysql-8.0.18/data # 设置初始密码, 好像没有什么用 default_authentication_plugin = mysql_native_password # 允许最大连接数 max_connections = 20 # 服务端使用的字符集默认为8比特编码的latin1字符集 character-set-server = UTF8MB4 # 创建新表时将使用的默认存储引擎 default-storage-engine = INNODB 其中 datadir 不能有任何文件, 否则启动mysql服务会报错: --initialize specified but the data directory has files in it. Aborting. 配置完成后进入安装路径的 .\\bin 目录, 用管理员身份打开 CMD 键入: mysqld --initialize --console 进行初始化得到密码 输入mysql指令发现 You must reset your password using ALTER USER statement before executing this statement. , 需要通过 alter user user() identified by \"mypwd\"; 修改密码即可.","text_tokens":["最大","latin1","设置","\"","发现","用","存储","有","aborting","initialize","in","engine","管理","不能","好像","c","引擎","密码","否则","管理员","连接数","文件夹","connections",",",")","mysql","utf8","报错","must","进入","后","user","using","20","修改","-","has"," ",":","身份","console","位置","指令","使用","max","任何","默认","password","this","cmd","目录","default","executing","18","(","\\","会","的","客户",";","[","数据","authentication","比特","utf8mb4","其中","什么","you","alter","identified","客户端","plugin","服务","输入","=","ide",".","创建","]","server","新表时","ini","没有","服务端","8.0","datadir","the","3306","配置","路径","innodb","port","client","端口","通过","mypwd","files","需要","初始","将","初始化","set","进行","安装","/","初始密码","storage","得到","statement","启动","完成","在","新建","native","my","为","bin","即可","mysqld","键入","software","but","字符集","character","by","directory","允许","it","存放","_","reset","打开","件夹","字符","连接","specified","编辑","文件","your","下","编码","data","8","basedir","#","before"],"title":"配置","title_tokens":["配置"]},{"location":"Others/01 MySql/#mysql_1","text":"[WINDOWS] mysqld install : 安装mysql服务 [WINDOWS管理员] net start mysql : 启动mysql服务 mysql -u root -p : 进入mysql alter user user() identified by \"passwrod\"; : 修改mysql密码","text_tokens":["\"","mysqld"," ",":","]","by","管理","net","p","u","(","passwrod",";","密码","[","管理员",")","install","mysql","start","安装","alter","identified","进入","root","user","启动","修改","服务","windows","-"],"title":"mysql常用指令","title_tokens":["常用","mysql","指令"]},{"location":"Others/01 MySql/#mysql_2","text":"heidi sql","text_tokens":[" ","sql","heidi"],"title":"mysql可视化","title_tokens":["可视化","mysql","可视"]},{"location":"Others/01 MySql/#ref","text":"安装mysql 设置mysql密码","text_tokens":["安装","设置","密码"," ","mysql"],"title":"REF:","title_tokens":["ref",":"]},{"location":"Others/Excel/01 autoCreateTime/","text":"1. 自动创建数据时间，不受其他修改影响的 NOW() 在 选项 下的 公式 启用 迭代计算 使得excel不会报循环引用的警告⚠ 此处的 C列 会自动根据 D列 数据创建时间，该时间不会根据其他的列改变 excel = IF ( D2 = \"\" , \"\" , IF ( C2 = \"\" , NOW () , C2 )) 参考URL： 循环引用 自动创建时间后，锁定时间","text_tokens":["\"","1","."," ","⚠","该","计算","创建","时间","不会","c2","选项","报","excel","url","，","其他","参考","now","(","：","会","影响","的","迭代","c","启用","数据","受","d","自动",")","if",",","改变","锁定","循环","d2","下","公式","后","使得","引用","此处","警告","修改","列","在","=","不","根据"],"title":"\t1. 自动创建数据时间，不受其他修改影响的`NOW()`","title_tokens":["1","."," ","创建","时间","，","其他","now","(","影响","的","数据","自动","`",")","\t","修改","受","不"]},{"location":"Others/Excel/01 autoCreateTime/#1-now","text":"在 选项 下的 公式 启用 迭代计算 使得excel不会报循环引用的警告⚠ 此处的 C列 会自动根据 D列 数据创建时间，该时间不会根据其他的列改变 excel = IF ( D2 = \"\" , \"\" , IF ( C2 = \"\" , NOW () , C2 )) 参考URL： 循环引用 自动创建时间后，锁定时间","text_tokens":["\""," ","⚠","该","计算","不会","创建","时间","c2","选项","报","excel","url","，","其他","参考","now","(","：","会","的","c","迭代","启用","数据","d","自动","if",",",")","改变","锁定","循环","d2","下","公式","后","使得","引用","此处","警告","列","在","=","根据"],"title":"1. 自动创建数据时间，不受其他修改影响的NOW()","title_tokens":["影响","的","1","."," ","，","数据","其他","自动","now","创建","时间","修改","受",")","不","("]},{"location":"Others/Excel/02 autoCreateTimeByMacro/","text":"2. 用宏自动创建数据时间 Private Sub Worksheet_Change ( ByVal Target As Range ) ' ______说明 ↓ ___________________________________ '某列单元格发生变化 '若变化值不为空，对应列添加变化时间点日期时间 '若变化值为空，删除对应单元格数据 '示例为 A列第2行发生变化 ，对应的 B列添加或删除日期 ' ______说明 ↑ ___________________________________ Application . ScreenUpdating = False '关闭屏幕刷新 Dim cA , cB , startRG As String Dim offsetc As Long Dim rg As Range ' ______设置参数 ↓ _________________ cA = \"A\" '变化区域所在列 cB = \"B\" '日期生成列 startRG = \"A1\" '变化区域首单元格 ( 防止改动表头触发事件 ) ' ______设置参数 ↑ _________________ offsetc = Columns ( cB ). Column - Columns ( cA ). Column If Not Application . Intersect ( Target , Columns ( cA ), Range ( startRG , ActiveCell . SpecialCells ( xlLastCell ))) Is Nothing Then For Each rg In Intersect ( Target , Columns ( cA ), Range ( startRG , ActiveCell . SpecialCells ( xlLastCell ))) If rg <> \"\" Then With rg . Offset ( 0 , offsetc ) . Value = Now . NumberFormatLocal = \"yyyy/m/d h:mm:ss ; @\" End With Else rg . Offset ( 0 , offsetc ). Clear End If Next rg End If Application . ScreenUpdating = True '恢复屏幕刷新 End Sub","text_tokens":["columns","\"","点","设置","_________________","生成","或","nothing","xllastcell","false","刷新","in","添加","触发","用宏","'","值不为","end","d","rg","specialcells",")","日期",",","事件","↓","dim","-","示例","target","对应","application"," ","发生",":",">","as","activecell","@","0","关闭","column","表头","单元格","a1","now","(","的","<",";","long","for","数据","自动","防止","true","byval","恢复","列","=","某列","不为","numberformatlocal","首",".","发生变化","创建","时间","单元","m","with","，","string","说明","change","变化","空","range","参数","所在","ca","cb","if","值为","intersect","/","screenupdating","yyyy","行","删除","clear","___________________________________","______","is","为","生变","ss","next","private","2","↑","sub","a","第","value","then","若","startrg","offsetc","区域","worksheet","_","each","屏幕","改动","h","offset","else","mm","not","b"],"title":"2. 用宏自动创建数据时间","title_tokens":["2","."," ","数据","自动","创建","时间","用宏"]},{"location":"Others/Excel/02 autoCreateTimeByMacro/#2","text":"Private Sub Worksheet_Change ( ByVal Target As Range ) ' ______说明 ↓ ___________________________________ '某列单元格发生变化 '若变化值不为空，对应列添加变化时间点日期时间 '若变化值为空，删除对应单元格数据 '示例为 A列第2行发生变化 ，对应的 B列添加或删除日期 ' ______说明 ↑ ___________________________________ Application . ScreenUpdating = False '关闭屏幕刷新 Dim cA , cB , startRG As String Dim offsetc As Long Dim rg As Range ' ______设置参数 ↓ _________________ cA = \"A\" '变化区域所在列 cB = \"B\" '日期生成列 startRG = \"A1\" '变化区域首单元格 ( 防止改动表头触发事件 ) ' ______设置参数 ↑ _________________ offsetc = Columns ( cB ). Column - Columns ( cA ). Column If Not Application . Intersect ( Target , Columns ( cA ), Range ( startRG , ActiveCell . SpecialCells ( xlLastCell ))) Is Nothing Then For Each rg In Intersect ( Target , Columns ( cA ), Range ( startRG , ActiveCell . SpecialCells ( xlLastCell ))) If rg <> \"\" Then With rg . Offset ( 0 , offsetc ) . Value = Now . NumberFormatLocal = \"yyyy/m/d h:mm:ss ; @\" End With Else rg . Offset ( 0 , offsetc ). Clear End If Next rg End If Application . ScreenUpdating = True '恢复屏幕刷新 End Sub","text_tokens":["columns","\"","点","设置","_________________","生成","或","nothing","xllastcell","false","刷新","in","添加","触发","'","值不为","end","d","rg","specialcells",")","日期",",","事件","↓","dim","-","示例","target","对应","application"," ","发生",":",">","as","activecell","@","0","关闭","column","表头","单元格","a1","now","(","的","<",";","long","for","数据","防止","true","byval","恢复","列","=","某列","不为","numberformatlocal","首",".","发生变化","时间","单元","m","with","，","string","说明","change","变化","空","range","参数","所在","ca","cb","if","值为","intersect","/","screenupdating","yyyy","行","删除","clear","___________________________________","______","is","为","生变","ss","next","private","2","↑","sub","a","第","value","then","若","startrg","offsetc","区域","worksheet","_","each","屏幕","改动","h","offset","else","mm","not","b"],"title":"2. 用宏自动创建数据时间","title_tokens":["2","."," ","数据","自动","创建","时间","用宏"]},{"location":"Others/Excel/03 FormatUnit/","text":"3. 为单元格添加格式 选中需要操作列, 右键选择 设置单元格式 ,选择 自定义 , 输入 :G/[格式]","text_tokens":["设置","."," ",":","操作","自定","选择","]","单元","选中","单元格","添加","g","[","右键","需要",",","定义","自定义","格式","/","3","列","输入","为"],"title":"3. 为单元格添加格式","title_tokens":["格式","."," ","单元格","3","添加","单元","为"]},{"location":"Others/Excel/03 FormatUnit/#3","text":"选中需要操作列, 右键选择 设置单元格式 ,选择 自定义 , 输入 :G/[格式]","text_tokens":["设置"," ",":","操作","自定","选择","]","单元","选中","g","[","右键","需要",",","定义","自定义","格式","/","列","输入"],"title":"3. 为单元格添加格式","title_tokens":["格式","."," ","单元格","3","添加","单元","为"]},{"location":"Others/Excel/04 RepairArrowKey/","text":"4. 方向键无法控制excel表格上下、左右移动 解决： 可能是 SCROLL LOCK 键被打开，在笔记本电脑上可以通过 FN+C 或者 FN+NUMB LK 解锁","text_tokens":[".","解决"," ","+","无法","上下","numb","电脑","被","excel","笔记本电脑","无法控制","，","lock","：","方向键","上","c","lk","、","通过","可能","控制","打开","移动","笔记本","scroll","是","可以","笔记","解锁","表格","4","键","方向","左右","在","或者","fn"],"title":"4. 方向键无法控制excel表格上下、左右移动","title_tokens":["excel","表格","无法控制","4","."," ","控制","、","方向","无法","上下","左右","移动","方向键"]},{"location":"Others/Excel/04 RepairArrowKey/#4-excel","text":"解决： 可能是 SCROLL LOCK 键被打开，在笔记本电脑上可以通过 FN+C 或者 FN+NUMB LK 解锁","text_tokens":["解决"," ","+","numb","电脑","被","笔记本电脑","，","lock","：","上","c","lk","通过","可能","打开","笔记本","scroll","是","可以","笔记","解锁","键","在","或者","fn"],"title":"4. 方向键无法控制excel表格上下、左右移动","title_tokens":["excel","表格","无法控制","4","."," ","控制","、","方向","无法","上下","左右","移动","方向键"]},{"location":"Python/01 UsingTesseract/","text":"Tesseract 下载地址 安装 设置环境变量 系统变量Path Tesseract-OCR路径 新建 TESSDATA_PREFIX 系统变量，变量值为 ...\\Tesseract-OCR\\tessdata 测试 python安装pytesseract pip install pytesseract 修改Python37\\site-packages内的 pytesseract\\pytesseract.py 内的文件，指定安装路径 tesseract_cmd = '.../Tesseract-OCR/tesseract.exe') import pytesseract from PIL import Image // pytesseract . pytesseract . tesseract_cmd = 'C://Program Files (x86)/Tesseract-OCR/tesseract.exe' text = pytesseract . image_to_string ( Image . open ( './demo.jpg' )) print ( text ) REF: 安装 测试","text_tokens":["image","设置","tesseract","变量","jpg","."," ",":","to","环境变量","环境变","python","print","...","demo","exe","地址","pip","环境","，","测试","string","python37","cmd","量值","site","(","路径","\\","系统","'","py","program","的","c","内","_","open","ref","ocr","files","text","为",")","from","install","安装","/","pil","文件","指定","prefix","x86","tessdata","packages","import","path","修改","变量值","=","新建","-","pytesseract","下载"],"title":"Tesseract","title_tokens":["tesseract"]},{"location":"Python/01 UsingTesseract/#tesseract","text":"下载地址 安装 设置环境变量 系统变量Path Tesseract-OCR路径 新建 TESSDATA_PREFIX 系统变量，变量值为 ...\\Tesseract-OCR\\tessdata 测试 python安装pytesseract pip install pytesseract 修改Python37\\site-packages内的 pytesseract\\pytesseract.py 内的文件，指定安装路径 tesseract_cmd = '.../Tesseract-OCR/tesseract.exe') import pytesseract from PIL import Image // pytesseract . pytesseract . tesseract_cmd = 'C://Program Files (x86)/Tesseract-OCR/tesseract.exe' text = pytesseract . image_to_string ( Image . open ( './demo.jpg' )) print ( text )","text_tokens":["image","设置","变量","tesseract","jpg","."," ",":","to","环境变量","环境变","python","print","...","demo","exe","地址","pip","环境","，","测试","string","python37","cmd","量值","site","(","路径","\\","系统","'","py","program","的","c","内","_","open","ocr","files","text","为",")","from","install","安装","/","pil","文件","指定","prefix","x86","tessdata","packages","import","path","修改","变量值","=","新建","-","pytesseract","下载"],"title":"Tesseract","title_tokens":["tesseract"]},{"location":"Python/01 UsingTesseract/#ref","text":"安装 测试","text_tokens":["安装"," ","测试"],"title":"REF:","title_tokens":["ref",":"]},{"location":"Python/02 dzdianpingSpider/","text":"大众点评评价爬取逻辑 分析 如图，评价中的 孩 字在源码中时被 <svgmtsi class=\"cfd1i\"></svgmtsi> 标签加密了。 在css中可以看到该svg图片地址为 background-image: url(//s3plus.meituan.net/v1/mss_0a06a471f9514fc79c981b5466f56b91/svgtextcss/2ec02e25ea201ca1b6b415747003614e.svg); 进入该地址发现是字体文件 加密字体的css中有 background: -0.0px -1808.0px; ，通过搜索可知 x / font-size（svg文件中①） + 1 可以得到该字体在svg中的第几个；比较y坐标和②的比较，其中，取 y<N 中的N值 孩 字 background: -0.0px -1808.0px; 对照可知：x=1，y<1831的path id=47 REF： 大众点评评论抓取-加密评论信息完整抓取","text_tokens":["\"","发现","cfd1i","评论","①","地址","第几个","孩","点评","；","2ec02e25ea201ca1b6b415747003614e",")","源码","第几","进入","完整","-","meituan","0.0","）","看到","中有"," ",":","标签","大众",">","id","（","1831","y","s3plus","url","爬取","中","加密","net","(","background","几个","n","的","<",";","svgmtsi","x","和","mss","其中","可知","path","=","class",".","1","+","信息","px","中时","评价","了","被","坐标","，","svgtextcss","：","通过","svg","抓取","是","/","取","可以","分析","得到","比较","0a06a471f9514fc79c981b5466f56b91","在","为","image","值","css","搜索","该","对照","font","v1","。","②","字体","_","ref","47","size","图片","1808.0","如图","文件","逻辑","字"],"title":"大众点评评价爬取逻辑","title_tokens":["逻辑","爬取","大众","评价","点评"]},{"location":"Python/02 dzdianpingSpider/#_1","text":"","text_tokens":[],"title":"大众点评评价爬取逻辑","title_tokens":["逻辑","爬取","大众","评价","点评"]},{"location":"Python/02 dzdianpingSpider/#_2","text":"如图，评价中的 孩 字在源码中时被 <svgmtsi class=\"cfd1i\"></svgmtsi> 标签加密了。 在css中可以看到该svg图片地址为 background-image: url(//s3plus.meituan.net/v1/mss_0a06a471f9514fc79c981b5466f56b91/svgtextcss/2ec02e25ea201ca1b6b415747003614e.svg); 进入该地址发现是字体文件 加密字体的css中有 background: -0.0px -1808.0px; ，通过搜索可知 x / font-size（svg文件中①） + 1 可以得到该字体在svg中的第几个；比较y坐标和②的比较，其中，取 y<N 中的N值 孩 字 background: -0.0px -1808.0px; 对照可知：x=1，y<1831的path id=47","text_tokens":["\"","发现","cfd1i","①","地址","第几个","孩","；","2ec02e25ea201ca1b6b415747003614e",")","源码","第几","进入","-","meituan","0.0","）","看到","中有"," ",":","标签",">","id","（","1831","y","s3plus","url","中","加密","net","(","background","几个","n","的","<",";","svgmtsi","x","和","mss","其中","可知","path","=","class",".","1","+","px","中时","评价","了","被","坐标","，","svgtextcss","：","通过","svg","是","/","取","可以","得到","比较","0a06a471f9514fc79c981b5466f56b91","在","为","image","值","css","搜索","该","对照","font","v1","。","②","字体","_","47","size","图片","1808.0","如图","文件","字"],"title":"分析","title_tokens":["分析"]},{"location":"Python/02 dzdianpingSpider/#ref","text":"大众点评评论抓取-加密评论信息完整抓取","text_tokens":["信息","加密","大众","抓取","评论","完整","-","点评"],"title":"REF：","title_tokens":["：","ref"]}]}