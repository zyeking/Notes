{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Mysite","text_tokens":["mysite","welcome","to"," "],"title":"Welcome to Mysite","title_tokens":["mysite","welcome","to"," "]},{"location":"#welcome-to-mysite","text":"","text_tokens":[],"title":"Welcome to Mysite","title_tokens":["mysite","welcome","to"," "]},{"location":"Golang/Basic/channel/","text":"channel what is channel channel是goroutine和goroutine之间无锁交流的【媒介】，换句话说，channel是一种允许一个goroutine发送数据给另外一个goroutine的技术，默认的channel是双向的，意味着goroutines可以通过同一个channel发、收数据。 how syntax var Channel_name chan Type channel_name := make(chan Type) 在golang中, 我们用关键字 Channel_name chan Type 创建某种类型的channel，其中channel仅仅可以传递同种类型的数据，不同类型的数据不可以通过一个类型的channel传递。 Send and Receive Data From a Channel 在golang中，channel主要有两个操作，一个是 sending ，一个是 receiving ，这两种操作被称为通讯。 <- 箭头的方向表明是发送数据还是接受数据。在默认情况下，channel中的发送、接受操作块【直到另一端未就绪】 ，允许goroutine之间在没有显式锁或者条件变量的时候互相同步 发送操作：在channel的帮助下用来将goroutine的数据发送给另外一个goroutine，通过channel发送 float64 ， int ， bool 是安全切容易的，因为这些值会被 拷贝 一份，不会有意外并发的风险，同样的， strings 类型也是安全的，因为它是 immutable（不可更改） 。在发送 pointers 或者 slice ， map 等引用的时候，channel是不安全的，因为指针或者引用会被发送者或者接收者在同一时间修改，结果是不可预知的，因此需要==确保只有一个goroutine能够访问== Mychannel <- element 表明了数据（element）发送给了Mychannel 接受操作： element := <- Mychannel package main import \"fmt\" func main () { fmt . Println ( \"starting Main method\" ) ch := make ( chan int ) go myfunc ( ch ) ch <- 23 fmt . Println ( \"End Main method\" ) } func myfunc ( ch chan int ) { fmt . Println ( 234 + <- ch ) } Closing a Channel close() 这是一个内置函数，设了一个表示表明不会再有值发送给该channel。 ele, ok = <- Mychannel 通过循环，接受者会检查该channel是打开的还是关闭的，如果ok是真，则意味着该channel是打开的。 package main import \"fmt\" func main () { c := make ( chan string ) // 调用goroutine go myFunc ( c ) for { res , ok := <- c if ok == false { fmt . Println ( \"Channel Close\" , ok ) break } fmt . Println ( \"Channel Open\" , res , ok ) } } func myFunc ( mychnl chan string ) { for v := 0 ; v < 4 ; v ++ { mychnl <- \"GeeksforGeeks\" } close ( mychnl ) } Blocking Send and Receive 在channel中，当数据发送给一个channel，直到另外的goroutine读取这个channel前，发送的声明是被阻塞的（发送完后必须等待该信息被读取才能够继续发送）。同样的，当一个channel接受数据的时候在接收到数据前都是被阻塞的。 channel中的零值是 nil 。 for 循环可以迭代channel中所有连续的值，直到该channel。 package main import \"fmt\" func main () { mychnl := make ( chan string ) go func () { mychnl <- \"GFG\" mychnl <- \"ABC\" mychnl <- \"ASDJH\" mychnl <- \"asdjjak\" close ( mychnl ) }() for res := range mychnl { fmt . Println ( res ) } } Length of the Channel len() 表明在channel缓冲区中==值的数量== package main import \"fmt\" func main () { mychnl := make ( chan string , 4 ) mychnl <- \"GFG\" mychnl <- \"ABC\" mychnl <- \"ASDJH\" mychnl <- \"asdjjak\" fmt . Println ( \"Length of the channel is:\" , len ( mychnl )) } Capacity of the Channel cap() 表明channel缓冲区的大小 package main import \"fmt\" func main () { mychnl := make ( chan string , 8 ) mychnl <- \"GFG\" mychnl <- \"ABC\" mychnl <- \"ASDJH\" fmt . Println ( \"Capacity of the channel is:\" , cap ( mychnl )) }","text_tokens":["blocking","锁","main","还是","<","一份","真","是","时候","immutable","asdjh","goroutines","。","、","的","主要","float64","信息","data","接受者","一时间","这个","（","该",";","23","都","同一时间","给","一端","所有","变量","ch","send","我们","bool"," ","打开","通过","int","不可","等","能够","另一端","】","关键","不同","res","0","channel","零值","缓冲","大小","并发","import","修改","range","两种","_","到","收","这些","可以","pointers","from","syntax","预知","gfg","=","就绪","golang","意味","同一个","访问","(","声明","引用","因为","234","当","of","值会","缓冲区","closing","值","element","必须","拷贝","互相","myfunc","end","通讯","}","条件","mychannel","chan",",","因此","确保","length","切","用来","接收","nil","更改","检查","意味着","它","同一时","is","capacity","and","the","strings","其中","指针","结果","method","go","表示","送给","【","类型","len","-","传递","数据","关键字","风险","完后","open","how",".","循环","string","媒介","创建","某种","操作","sending","箭头","会","称为","+","受者","slice","不会","函数","goroutine","允许","在","数量","8","等待","继续","另外","geeksforgeeks","方向","var","starting","迭代","type","同步","连续","阻塞","中","接收者","name","：","func","则","break","这","再有","情况","++","发送数据","ele","package","for","发送者","两个","容易","/","需要","asdjjak","false","块","同种","mychnl","if","技术","只有","前","cap","println","无锁","what","帮助","a","不","交流","了","换句话说","表明","close","abc","fmt","双向","ok","读取","换句话","将","同样","才","\"","4","发","意外","显式","如果","仅仅","发送给","换句","receive","设","v","下","接受",")","）","同一","这是","调用","map","，","也","和","receiving","用","被","一个","没有","关闭","有","内置","make","发送","或者","一种","安全","{",":","时间","直到","一时","未","之间","c","默认"],"title":"channel","title_tokens":["channel"]},{"location":"Golang/Basic/channel/#channel","text":"","text_tokens":[],"title":"channel","title_tokens":["channel"]},{"location":"Golang/Basic/channel/#what-is-channel","text":"channel是goroutine和goroutine之间无锁交流的【媒介】，换句话说，channel是一种允许一个goroutine发送数据给另外一个goroutine的技术，默认的channel是双向的，意味着goroutines可以通过同一个channel发、收数据。","text_tokens":["换句话说","数据","双向","收","换句话","是","媒介","发","意味","同一个","goroutines","。","、","的","goroutine","允许","换句","另外","给","同一","，","和","发送数据","通过","一个","意味着","】","发送","一种","channel","技术","无锁","默认","【","之间","交流","可以"],"title":"what is channel","title_tokens":["channel","is"," ","what"]},{"location":"Golang/Basic/channel/#how","text":"syntax var Channel_name chan Type channel_name := make(chan Type) 在golang中, 我们用关键字 Channel_name chan Type 创建某种类型的channel，其中channel仅仅可以传递同种类型的数据，不同类型的数据不可以通过一个类型的channel传递。","text_tokens":["syntax","传递","关键字","数据","=","golang","创建","某种","。","的","(","在","仅仅","var","type",")","中","name","，","我们","chan",","," ","用","通过","一个","make","不同","关键","channel","不","同种",":","其中","_","类型","可以"],"title":"how","title_tokens":["how"]},{"location":"Golang/Basic/channel/#send-and-receive-data-from-a-channel","text":"在golang中，channel主要有两个操作，一个是 sending ，一个是 receiving ，这两种操作被称为通讯。 <- 箭头的方向表明是发送数据还是接受数据。在默认情况下，channel中的发送、接受操作块【直到另一端未就绪】 ，允许goroutine之间在没有显式锁或者条件变量的时候互相同步 发送操作：在channel的帮助下用来将goroutine的数据发送给另外一个goroutine，通过channel发送 float64 ， int ， bool 是安全切容易的，因为这些值会被 拷贝 一份，不会有意外并发的风险，同样的， strings 类型也是安全的，因为它是 immutable（不可更改） 。在发送 pointers 或者 slice ， map 等引用的时候，channel是不安全的，因为指针或者引用会被发送者或者接收者在同一时间修改，结果是不可预知的，因此需要==确保只有一个goroutine能够访问== Mychannel <- element 表明了数据（element）发送给了Mychannel 接受操作： element := <- Mychannel package main import \"fmt\" func main () { fmt . Println ( \"starting Main method\" ) ch := make ( chan int ) go myfunc ( ch ) ch <- 23 fmt . Println ( \"End Main method\" ) } func myfunc ( ch chan int ) { fmt . Println ( 234 + <- ch ) }","text_tokens":["锁","main","还是","<","一份","是","时候","immutable","。","、","的","主要","float64","一时间","（","23","同一时间","一端","变量","ch","bool"," ","通过","int","不可","等","能够","另一端","】","channel","并发","import","修改","两种","这些","pointers","预知","=","就绪","golang","访问","(","引用","因为","234","值会","element","拷贝","互相","myfunc","end","通讯","}","条件","mychannel","因此","chan","确保","切","用来","接收","更改","它","同一时","strings","指针","结果","go","method","送给","【","类型","-","数据","风险",".","sending","操作","会","+","箭头","称为","slice","不会","在","允许","goroutine","另外","方向","starting","同步","中","接收者","func","：","这","情况","发送数据","package","发送者","两个","容易","需要","块","只有","println","帮助","不","了","表明","fmt","将","同样","\"","意外","显式","发送给","下","接受","）",")","同一","map","，","也","receiving","被","一个","没有","有","make","发送","或者","安全","{","时间",":","直到","一时","未","之间","默认"],"title":"Send and Receive Data From a Channel","title_tokens":["from","send","channel","data","and","receive"," ","a"]},{"location":"Golang/Basic/channel/#closing-a-channel","text":"close() 这是一个内置函数，设了一个表示表明不会再有值发送给该channel。 ele, ok = <- Mychannel 通过循环，接受者会检查该channel是打开的还是关闭的，如果ok是真，则意味着该channel是打开的。 package main import \"fmt\" func main () { c := make ( chan string ) // 调用goroutine go myFunc ( c ) for { res , ok := <- c if ok == false { fmt . Println ( \"Channel Close\" , ok ) break } fmt . Println ( \"Channel Open\" , res , ok ) } } func myFunc ( mychnl chan string ) { for v := 0 ; v < 4 ; v ++ { mychnl <- \"GeeksforGeeks\" } close ( mychnl ) }","text_tokens":["main","还是","<","真","是","。","的","接受者","该",";"," ","打开","通过","res","0","channel","import","=","意味","(","值","myfunc","}","mychannel","chan",",","检查","意味着","go","表示","送给","-","open","循环","string",".","会","受者","不会","函数","goroutine","geeksforgeeks","则","func","break","再有","++","ele","package","for","/","false","mychnl","if","println","了","close","表明","ok","fmt","\"","4","如果","发送给","v","设","接受",")","这是","调用","，","一个","关闭","内置","make","发送","{",":","c"],"title":"Closing a Channel","title_tokens":["channel","closing","a"," "]},{"location":"Golang/Basic/channel/#blocking-send-and-receive","text":"在channel中，当数据发送给一个channel，直到另外的goroutine读取这个channel前，发送的声明是被阻塞的（发送完后必须等待该信息被读取才能够继续发送）。同样的，当一个channel接受数据的时候在接收到数据前都是被阻塞的。 channel中的零值是 nil 。 for 循环可以迭代channel中所有连续的值，直到该channel。 package main import \"fmt\" func main () { mychnl := make ( chan string ) go func () { mychnl <- \"GFG\" mychnl <- \"ABC\" mychnl <- \"ASDJH\" mychnl <- \"asdjjak\" close ( mychnl ) }() for res := range mychnl { fmt . Println ( res ) } }","text_tokens":["abc","main","close","完后","数据","fmt","<","读取","gfg","=","同样","循环","string","才","是","时候","\"","asdjh",".","。","的","(","声明","在","goroutine","信息","当","发送给","等待","这个","另外","继续","值","（","该","迭代","必须","接受","都","连续","）",")","阻塞","所有","}","中","func","，","chan","被"," ","package","一个","接收","for","能够","nil","make","发送","res","asdjjak","channel","零值","前","mychnl","{",":","import","println","go","range","直到","送给","到","-","可以"],"title":"Blocking Send and Receive","title_tokens":["blocking","send","and","receive"," "]},{"location":"Golang/Basic/channel/#length-of-the-channel","text":"len() 表明在channel缓冲区中==值的数量== package main import \"fmt\" func main () { mychnl := make ( chan string , 4 ) mychnl <- \"GFG\" mychnl <- \"ABC\" mychnl <- \"ASDJH\" mychnl <- \"asdjjak\" fmt . Println ( \"Length of the channel is:\" , len ( mychnl )) }","text_tokens":["abc","表明","main","fmt","<","gfg","=","string",".","\"","asdjh","4","的","(","在","数量","of","缓冲区","值",")","}","中","func","chan",","," ","length","package","make","asdjjak","is","channel","缓冲","mychnl","{",":","import","println","the","len","-"],"title":"Length of the Channel","title_tokens":["channel","of","the"," ","length"]},{"location":"Golang/Basic/channel/#capacity-of-the-channel","text":"cap() 表明channel缓冲区的大小 package main import \"fmt\" func main () { mychnl := make ( chan string , 8 ) mychnl <- \"GFG\" mychnl <- \"ABC\" mychnl <- \"ASDJH\" fmt . Println ( \"Capacity of the channel is:\" , cap ( mychnl )) }","text_tokens":["abc","表明","main","fmt","<","gfg","=","string",".","\"","asdjh","的","(","8","of","缓冲区",")","}","func","chan",","," ","package","make","is","cap","channel","缓冲","大小","mychnl","capacity","{",":","import","println","the","-"],"title":"Capacity of the Channel","title_tokens":["channel","capacity","of","the"," "]},{"location":"Golang/Project/01 Config/","text":"go-gin-example 01：配置 Golang 环境安装配置 下载 配置环境变量 文件配置 $ mkdir go-gin-example && cd go-gin-example $ go env -w GO111MODULE = on $ go env -w GOPROXY = https://goproxy.cn,direct $ go mod init [ MODULE_PATH ] $ ls > go.mod mkdir go-gin-example && cd go-gin-example ：创建并切换到项目目录。 go env -w GO111MUDOLE=on ：打开Go module 开关。 go env -w GOPROXY=... ：设置GOPROXY代理，第一个为七牛Go代理， direct 为Go在拉取模块遇到错误会回源到原模块版本的源地址去抓取。 go mod init [Module_Path] ：初始化Go module，产生go.mod文件 module go-gin-example go 1 .12 GOMODULE基础使用 go get ：拉取新的依赖 拉取最新的版本： go get golang/org/x/text@lastest 拉取 master 分支的最新commit： go get golang.org/x/text@master go tidy ：整理依","text_tokens":["1","&&","direct","$","。","版本","的","mkdir","新","module","gin","w","变量"," ","打开","[","到","_","第一个","产生","为","初始","cn","=","golang","第一","依赖","mod","抓取","x","依","]","目录","01","遇到","回源","get","text","原","切换","错误","源地","commit","模块","拉取",",","init","path","项目","分支","...","go","on",">","@","地址","-",".","基础","org","创建","会","在","为七牛","安装","文件","：","go111mudole","初始化","tidy","/","环境变量","整理","设置","使用","master","gomodule","go111module","配置","goproxy","https","ls","12","源地址","下载","代理","cd","环境变","example","，","一个","并","环境","开关","去","lastest","env",":","最新"],"title":"go-gin-example 01：配置","title_tokens":["01","：","example"," ","配置","go","gin","-"]},{"location":"Golang/Project/01 Config/#go-gin-example-01","text":"","text_tokens":[],"title":"go-gin-example 01：配置","title_tokens":["01","：","example"," ","配置","go","gin","-"]},{"location":"Golang/Project/01 Config/#golang","text":"","text_tokens":[],"title":"Golang 环境安装配置","title_tokens":[" ","配置","golang","安装","环境"]},{"location":"Golang/Project/01 Config/#_1","text":"","text_tokens":[],"title":"下载","title_tokens":["下载"]},{"location":"Golang/Project/01 Config/#_2","text":"","text_tokens":[],"title":"配置环境变量","title_tokens":["环境变","变量","配置","环境变量","环境"]},{"location":"Golang/Project/01 Config/#_3","text":"$ mkdir go-gin-example && cd go-gin-example $ go env -w GO111MODULE = on $ go env -w GOPROXY = https://goproxy.cn,direct $ go mod init [ MODULE_PATH ] $ ls > go.mod mkdir go-gin-example && cd go-gin-example ：创建并切换到项目目录。 go env -w GO111MUDOLE=on ：打开Go module 开关。 go env -w GOPROXY=... ：设置GOPROXY代理，第一个为七牛Go代理， direct 为Go在拉取模块遇到错误会回源到原模块版本的源地址去抓取。 go mod init [Module_Path] ：初始化Go module，产生go.mod文件 module go-gin-example go 1 .12","text_tokens":["设置","&&","产生","为","1","初始","cn","=",".","go111module","goproxy","创建","第一","会","direct","mod","$","。","版本","到","抓取","]","mkdir","https","ls","目录","在","遇到","回源","的","12","源地址","module","为七牛","代理","cd","w","gin","原","文件","切换","错误","：","example","，","源地","模块","go111mudole",","," ","打开","init","拉取","一个","初始化","[","并","/","开关","去","path","项目","env",":","...","go","on",">","_","第一个","地址","-"],"title":"文件配置","title_tokens":["配置","文件"]},{"location":"Golang/Project/01 Config/#gomodule","text":"go get ：拉取新的依赖 拉取最新的版本： go get golang/org/x/text@lastest 拉取 master 分支的最新commit： go get golang.org/x/text@master go tidy ：整理依","text_tokens":["master",".","org","golang","依赖","版本","x","依","的","新","get","text","：","commit","拉取"," ","tidy","lastest","/","分支","go","@","最新","整理"],"title":"GOMODULE基础使用","title_tokens":["基础","使用","gomodule"]},{"location":"Golang/Project/02 API-1/","text":"go-gin-example 02：API-1 初始设置 项目目录 go-gin-example/ ├─conf ├─middleware ├─models ├─pkg ├─routers └─runtime conf：用于存储配置文件 middleware：应用中间件 models：应用数据库模型 pkg：第三方包 routers：路由逻辑处理 runtime：应用运行时数据 添加Go Modules Replace配置本地模块路径 （好像不必要） module go - gin - example go 1.12 require ( ··· ) replace ( . / go - gin - example / conf => . / go - gin - example / pkg / conf . / go - gin - example / middleware => . / go - gin - example / middleware . / go - gin - example / models => . / go - gin - example / models . / go - gin - example / pkg / e => . / go - gin - example / pkg / e . / go - gin - example / pkg / setting => . / go - gin - example / pkg / setting . / go - gin - example / pkg / util => . / go - gin - example / pkg / util . / go - gin - example / routers => . / go - gin - example / routers ) # 用 replace 将其指定读取本地的模块路径 ， 这样子就可以解决本地模块读取的问题 使用ini配置文件库/编写项目配置包 应用配置文件 将公共配置部分提取出来，写成专门的配置文件，统一写数据库环境、服务器环境等。 在 ./conf 目录下新建 app.ini 文件 定义RUN_MODE 定义数据库端口、账号、表格等 定义公共参数：分页 定义服务器端口、TIMEOUT时间等 # debug or release RUN_MODE = debug [app] PAGE_SIZE = 10 JWT_SECRET = 23347$040412 [server] HTTP_PORT = 8000 READ_TIMEOUT = 60 WRITE_TIMEOUT = 60 [database] TYPE = mysql USER = root # 数据库账号 PASSWORD = root # 数据库密码 HOST = 127.0.0.1:3306 # 数据库IP:数据库端口号 NAME = blog TABLE_PREFIX = blog_ 调用配置的setting模块 负责调用app.ini go get -u github.com/go-ini/ini 在 ./pkg/setting 目录下新建 setting.go 文件 package setting import ( \"log\" \"time\" \"github.com/go-ini/ini\" ) var ( Cfg * ini . File // Cfg为ini文件类型 // 声明app.ini文件写好的各种配置的类型 RunMode string HTTPPort int ReadTimeout time . Duration WriteTimeout time . Duration PageSize int JwtSecret string ) func init () { var err error // 加载初始化文件 Cfg , err = ini . Load ( \"conf/app.ini\" ) if err != nil { log . Fatalf ( \"Fail to parse 'conf/app.ini`: %v\" , err ) } LoadBase () LoadServer () LoadApp () } // 加载基础设置 func LoadBase () { // 设置RUN_MODE为'debug' RunMode = Cfg . Section ( \"\" ). Key ( \"RUN_MODE\" ). MustString ( \"debug\" ) } // LoadServer 加载服务器配置 func LoadServer () { // 获取'server'的section信息 // 这里的section包含'server'的各种信息, 由./config/app,ini配置文件提供 sec , err := Cfg . GetSection ( \"server\" ) if err != nil { log . Fatalf ( \"Fail to get section 'server':%v\" , err ) } RunMode = Cfg . Section ( \"\" ). Key ( \"RUN_MODE\" ). MustString ( \"debug\" ) // 自动类型转换 HTTPPort = sec . Key ( \"HTTP_PORT\" ). MustInt ( 8000 ) ReadTimeout = time . Duration ( sec . Key ( \"READ_TIMEOUT\" ). MustInt ( 60 )) * time . Second WriteTimeout = time . Duration ( sec . Key ( \"WRITE_TIMEOUT\" ). MustInt ( 60 )) * time . Second } // LoadApp 加载APP配置 func LoadApp () { // 获取./config/app.ini配置文件的APP配置 sec , err := Cfg . GetSection ( \"app\" ) if err != nil { log . Fatalf ( \"Fail to get section 'app':%v\" , err ) } JwtSecret = sec . Key ( \"JWT_SECRET\" ). MustString ( \"!@)*#)!@U#@*!@!)\" ) PageSize = sec . Key ( \"PAGE_SIZE\" ). MustInt ( 10 ) } API错误码包 建立错误码e模块 在 ./pkg/e 目录下新建 code.go 和 msg.go 文件 code.go package e // API错误代码 const ( SUCCESS = 200 ERROR = 500 INVALID_PARAMS = 400 ERROR_EXIST_TAG = 10001 ERROR_NOT_EXIST_TAG = 10002 ERROR_NOT_EXIST_ARTICLE = 10003 ERROR_AUTH_CHECK_TOKEN_FAIL = 20001 ERROR_AUTH_CHECK_TOKEN_TIMEOUT = 20002 ERROR_AUTH_TOKEN = 20003 ERROR_AUTH = 20004 ) msg.go package e //msg.go // MsgFlags 错误信息 var MsgFlags = map [ int ] string { SUCCESS : \"ok\" , ERROR : \"fail\" , INVALID_PARAMS : \"请求参数错误\" , ERROR_EXIST_TAG : \"已存在该标签名称\" , ERROR_NOT_EXIST_TAG : \"该标签不存在\" , ERROR_NOT_EXIST_ARTICLE : \"该文章不存在\" , ERROR_AUTH_CHECK_TOKEN_FAIL : \"Token鉴权失败\" , ERROR_AUTH_CHECK_TOKEN_TIMEOUT : \"Token鉴权超时\" , ERROR_AUTH_TOKEN : \"Token生成失败\" , ERROR_AUTH : \"Token错误\" , } // GetMsg 获取错误信息 func GetMsg ( code int ) string { msg , ok := MsgFlags [ code ] if ok { return msg } return MsgFlags [ ERROR ] } 工具包 公共方法：例如获取分页页码等 go get -u github.com/unknwon/com 在 ./pkg/util 目录下新建 pagination.go 文件 package util import ( setting \"go-gin-example/pkg/settings\" \"github.com/gin-gonic/gin\" \"github.com/unknwon/com\" ) // GetPage 获取page数量 func GetPage ( c * gin . Context ) int { result := 0 // page转换为int page , _ := com . StrTo ( c . Query ( \"page\" )). Int () if page > 0 { result = ( page - 1 ) * setting . PageSize } return result } 数据库模型映射 通过gorm将golang结构体映射到数据库中自动生成模型 go get -u github.com/jinzhu/gorm go get -u github.com/go-sql-driver/mysql 在 ./models 目录下新建 models.go 文件。 package models import ( \"fmt\" setting \"go-gin-example/pkg/settings\" \"log\" \"github.com/jinzhu/gorm\" ) var db * gorm . DB // Model 数据库模型 type Model struct { ID int `gorm:\"primary_key\" json:id` CreatedOn int `json:\"created_on\"` ModifiedOn int `json:\"modified_on\"` } func init () { var ( err error dbType , dbName , user , password , host , tablePrefix string ) // 获取配置文件的数据库配置 sec , err := setting . Cfg . GetSection ( \"database\" ) if err != nil { log . Fatal ( 2 , \"Fail to get get scetion `database`:%v\" , err ) } dbType = sec . Key ( \"TYPE\" ). String () dbName = sec . Key ( \"NAME\" ). String () user = sec . Key ( \"USER\" ). String () password = sec . Key ( \"PASSWORD\" ). String () host = sec . Key ( \"HOST\" ). String () tablePrefix = sec . Key ( \"TABLE_PREFIX\" ). String () db , err = gorm . Open ( dbtype , fmt . Sprintf ( \"%s:%s@tcp(%s)/%s?charset=utf8&parseTime=True&loc=Local\" , user , password , dbName )) if err != nil { log . Println ( err ) } gorm . DefaultTableNameHandler = func ( db * gorm . DB , defaultTableName string ) string { return tablePrefix + defaultTableName } db . SingularTable ( true ) db . LogMode ( true ) db . DB (). SetMaxIdleConns ( 10 ) db . DB (). SetMaxOpenConns ( 100 ) } // CloseDB 关闭数据库连接 func CloseDB () { defer db . Close () } Demo 实例程序 在 ./ 目录下新建 main.go 文件 package main import ( \"fmt\" setting \"go-gin-example/pkg/settings\" \"net/http\" \"github.com/gin-gonic/gin\" ) func main () { router := gin . Default () router . GET ( \"/test\" , func ( c * gin . Context ) { c . JSON ( 200 , gin . H { \"message\" : \"test\" , }) }) s := & http . Server { Addr : fmt . Sprintf ( \":%d\" , setting . HTTPPort ), Handler : router , ReadTimeout : setting . ReadTimeout , WriteTimeout : setting . WriteTimeout , MaxHeaderBytes : 1 << 20 , } // 调用在&http.Server中设置的参数,因此上面要用&,要改变参数的值 s . ListenAndServe () } 浏览器输入 localhost：8000/test 返回 {\"message\":\"test\"} 则成功 从main.go中分离路由 在 ./routers 目录下新建 router.go 文件 package routers import ( setting \"go-gin-example/pkg/settings\" \"github.com/gin-gonic/gin\" ) func InitRouter () * gin . Engine { r := gin . New () r . Use ( gin . Logger ()) r . Use ( gin . Recovery ()) gin . SetMode ( setting . RunMode ) r . GET ( \"/test\" , func ( c * gin . Context ) { c . JSON ( 200 , gin . H { \"message\" : \"test\" , }) }) return r } 修改 main.go 文件 package main import ( \"fmt\" setting \"go-gin-example/pkg/settings\" \"go-gin-example/routers\" \"net/http\" ) func main () { router := routers . InitRouter () s := & http . Server { Addr : fmt . Sprintf ( \":%d\" , setting . HTTPPort ), Handler : router , ReadTimeout : setting . ReadTimeout , WriteTimeout : setting . WriteTimeout , MaxHeaderBytes : 1 << 20 , } s . ListenAndServer () } 当前目录结构 go-gin-example/ ├── conf │ └── app.ini ├── main.go ├── middleware ├── models │ └── models.go ├── pkg │ ├── e │ │ ├── code.go │ │ └── msg.go │ ├── setting │ │ └── setting.go │ └── util │ └── pagination.go ├── routers │ └── router.go ├── runtime","text_tokens":["default","main","必要","60","closedb","or","msg","的","8000","这里","defaulttablename","conf","10002","created","not","mustint","问题","文章","logmode","setmode","check","样子","import","driver","muststring","中间","标签","到","请求","│","=","utf8","readtimeout","pagesize","context","prefix","误码","声明","api","err","其","database","编写",",","·","10","httpport","defer","项目","writetimeout","浏览","go","@","20001","2","数据","open",".","string","基础","+","模型","token","singulartable","mode","错误代码","三方","在","primary","配置文件","服务","文件","tcp","则","初始化","package","本地","println","handler","10001","ok","据库","\"","误信","输入","exist","log","调用","s","用","500","环境","专门","20003","routers","写成","loadbase","出来","200","$","listenandserve","setmaxidleconns","fail","类型转换","return","从","127.0","module","存储","工具","gin","3306","file","加载","second","名称","提供","返回"," ","int","[","已","要用","secret","0","fatal","addr","?","可以","#","r","golang","结构","%","port","20004","目录","例如","方法","query","值","错误","recovery","02","init","处理","nil","公共","pkg","存储配置","鉴权","section","model","部分","类型","charset","debug","表格","replace","maxheaderbytes","parsetime","setting","parse","中","：","23347","read","100","/","u","gorm","modules","load","fmt","改变","createdon","解决","params","用于","github","下","映射","代码","）","cfg","loadapp","struct","路由","和","ip","失败","务器","关闭","0.1","result","实例","d","超时","{",":","!","release","c","库","1","net","建立","util","invalid","包","自动","setmaxopenconns","config","。","、","信息","应用","initrouter","程序","上面","当前目录","指定","time","size","host","当前","新建","负责","*","写","id","修改","数据库","blog","jwt","settings","体","]","tableprefix","错误码","scetion","}","模块","root","db","auth","页码","-","─","好像","口号","└","var","口","运行","e","defaulttablenamehandler","name","20002","jwtsecret","分离","不必要","key","router","error","app","统一","json","logger","不","设置","使用","分页","040412","getmsg","将","由","h","参数","ini","v","逻辑","服务器","端口","mysql","`",")","pagination","定义","timeout","message","各种","demo","table","就","时间","msgflags","工具包","第三方","success","to","错误信息","生成","<","sql","article","http","page","（","该","400","sprintf","password","10003","local","通过","true","等","runmode","包含","_","时","第三","为","初始","账号","require","密码","loc","runtime","文件类型","好","(","tag","get","&","loadserver","sec","路径","因此","code","存在","modified","获取","端口号","getsection",">","on","modifiedon","'","strto","listenandserver","jinzhu","com","数量","use","dbtype","不必","type","write","func","run","engine","这","提取","gonic","middleware","if","服务器端","20","close","读取","配置","中间件","user","new","test","成功","├","连接","getpage","server","unknwon","添加","浏览器","fatalf","map","example","，","要","转换","localhost","dbname","1.12","duration","models","const"],"title":"go-gin-example 02：API-1","title_tokens":["1","api","：","example"," ","02","go","gin","-"]},{"location":"Golang/Project/02 API-1/#go-gin-example-02api-1","text":"初始设置","text_tokens":["设置","初始"],"title":"go-gin-example 02：API-1","title_tokens":["1","api","：","example"," ","02","go","gin","-"]},{"location":"Golang/Project/02 API-1/#_1","text":"go-gin-example/ ├─conf ├─middleware ├─models ├─pkg ├─routers └─runtime conf：用于存储配置文件 middleware：应用中间件 models：应用数据库模型 pkg：第三方包 routers：路由逻辑处理 runtime：应用运行时数据","text_tokens":["routers","数据","配置","据库","包","模型","中间件","runtime","─","三方","用于","├","└","应用","存储","运行","逻辑","gin","文件","路由","：","conf","example"," ","处理","/","middleware","pkg","存储配置","go","models","数据库","中间","第三方","时","第三","-"],"title":"项目目录","title_tokens":["目录","项目"]},{"location":"Golang/Project/02 API-1/#go-modules-replace","text":"module go - gin - example go 1.12 require ( ··· ) replace ( . / go - gin - example / conf => . / go - gin - example / pkg / conf . / go - gin - example / middleware => . / go - gin - example / middleware . / go - gin - example / models => . / go - gin - example / models . / go - gin - example / pkg / e => . / go - gin - example / pkg / e . / go - gin - example / pkg / setting => . / go - gin - example / pkg / setting . / go - gin - example / pkg / util => . / go - gin - example / pkg / util . / go - gin - example / routers => . / go - gin - example / routers ) # 用 replace 将其指定读取本地的模块路径 ， 这样子就可以解决本地模块读取的问题","text_tokens":["routers","util","读取","require","=",".","#","将","replace","解决","的","(","module","setting","e","gin","其","指定",")","路径","conf","example","，","这","模块","用"," ","·","就","/","1.12","pkg","middleware","问题","样子","本地","go",">","models","-","可以"],"title":"添加Go Modules Replace配置本地模块路径 （好像不必要）","title_tokens":["好像","必要","路径","本地","模块"," ","modules","配置","go","（","replace","不必要","不必","添加","）"]},{"location":"Golang/Project/02 API-1/#ini","text":"","text_tokens":[],"title":"使用ini配置文件库/编写项目配置包","title_tokens":["使用","ini","项目","编写","配置","配置文件","包","文件","库","/"]},{"location":"Golang/Project/02 API-1/#_2","text":"将公共配置部分提取出来，写成专门的配置文件，统一写数据库环境、服务器环境等。 在 ./conf 目录下新建 app.ini 文件 定义RUN_MODE 定义数据库端口、账号、表格等 定义公共参数：分页 定义服务器端口、TIMEOUT时间等 # debug or release RUN_MODE = debug [app] PAGE_SIZE = 10 JWT_SECRET = 23347$040412 [server] HTTP_PORT = 8000 READ_TIMEOUT = 60 WRITE_TIMEOUT = 60 [database] TYPE = mysql USER = root # 数据库账号 PASSWORD = root # 数据库密码 HOST = 127.0.0.1:3306 # 数据库IP:数据库端口号 NAME = blog TABLE_PREFIX = blog_","text_tokens":["写成","60","出来","$","。","or","、","的","http","8000","page","127.0","3306","size","password","conf","host"," ","等","[","新建","secret","写","数据库","_","blog","jwt","账号","=","#","密码","port","prefix","]","目录","database","root","10","公共","端口号","部分","debug","数据",".","表格","mode","口号","在","配置文件","服务","口","type","文件","write","name","run","：","提取","23347","read","/","服务器端","app","统一","分页","040412","将","配置","据库","user","参数","ini","下","server","服务器","端口","mysql","定义","timeout","，","ip","务器","table","0.1","环境","时间",":","专门","release"],"title":"应用配置文件","title_tokens":["应用","配置","文件","配置文件"]},{"location":"Golang/Project/02 API-1/#setting","text":"负责调用app.ini go get -u github.com/go-ini/ini 在 ./pkg/setting 目录下新建 setting.go 文件 package setting import ( \"log\" \"time\" \"github.com/go-ini/ini\" ) var ( Cfg * ini . File // Cfg为ini文件类型 // 声明app.ini文件写好的各种配置的类型 RunMode string HTTPPort int ReadTimeout time . Duration WriteTimeout time . Duration PageSize int JwtSecret string ) func init () { var err error // 加载初始化文件 Cfg , err = ini . Load ( \"conf/app.ini\" ) if err != nil { log . Fatalf ( \"Fail to parse 'conf/app.ini`: %v\" , err ) } LoadBase () LoadServer () LoadApp () } // 加载基础设置 func LoadBase () { // 设置RUN_MODE为'debug' RunMode = Cfg . Section ( \"\" ). Key ( \"RUN_MODE\" ). MustString ( \"debug\" ) } // LoadServer 加载服务器配置 func LoadServer () { // 获取'server'的section信息 // 这里的section包含'server'的各种信息, 由./config/app,ini配置文件提供 sec , err := Cfg . GetSection ( \"server\" ) if err != nil { log . Fatalf ( \"Fail to get section 'server':%v\" , err ) } RunMode = Cfg . Section ( \"\" ). Key ( \"RUN_MODE\" ). MustString ( \"debug\" ) // 自动类型转换 HTTPPort = sec . Key ( \"HTTP_PORT\" ). MustInt ( 8000 ) ReadTimeout = time . Duration ( sec . Key ( \"READ_TIMEOUT\" ). MustInt ( 60 )) * time . Second WriteTimeout = time . Duration ( sec . Key ( \"WRITE_TIMEOUT\" ). MustInt ( 60 )) * time . Second } // LoadApp 加载APP配置 func LoadApp () { // 获取./config/app.ini配置文件的APP配置 sec , err := Cfg . GetSection ( \"app\" ) if err != nil { log . Fatalf ( \"Fail to get section 'app':%v\" , err ) } JwtSecret = sec . Key ( \"JWT_SECRET\" ). MustString ( \"!@)*#)!@U#@*!@!)\" ) PageSize = sec . Key ( \"PAGE_SIZE\" ). MustInt ( 10 ) }","text_tokens":["loadbase","60","自动","config","的","http","fail","类型转换","信息","8000","page","这里","time","加载","file","size","second","提供","conf"," ","int","runmode","包含","新建","负责","*","mustint","secret","写","import","muststring","_","jwt","为","初始","=","#","readtimeout","pagesize","文件类型","%","port","好","目录","(","声明","get","loadserver","err","}","sec",",","init","10","nil","httpport","pkg","section","writetimeout","获取","getsection","go","@","'","类型","-","debug",".","string","基础","com","mode","在","var","setting","服务","配置文件","文件","parse","write","func","run","初始化","package","read","jwtsecret","key","/","u","if","error","app","load","设置","由","配置","\"","ini","github","v","下","server","log","服务器","`",")","fatalf","调用","cfg","loadapp","timeout","各种","务器","转换","duration","{",":","!","to"],"title":"调用配置的setting模块","title_tokens":["的","调用","模块","配置","setting"]},{"location":"Golang/Project/02 API-1/#api","text":"建立错误码e模块 在 ./pkg/e 目录下新建 code.go 和 msg.go 文件 code.go package e // API错误代码 const ( SUCCESS = 200 ERROR = 500 INVALID_PARAMS = 400 ERROR_EXIST_TAG = 10001 ERROR_NOT_EXIST_TAG = 10002 ERROR_NOT_EXIST_ARTICLE = 10003 ERROR_AUTH_CHECK_TOKEN_FAIL = 20001 ERROR_AUTH_CHECK_TOKEN_TIMEOUT = 20002 ERROR_AUTH_TOKEN = 20003 ERROR_AUTH = 20004 ) msg.go package e //msg.go // MsgFlags 错误信息 var MsgFlags = map [ int ] string { SUCCESS : \"ok\" , ERROR : \"fail\" , INVALID_PARAMS : \"请求参数错误\" , ERROR_EXIST_TAG : \"已存在该标签名称\" , ERROR_NOT_EXIST_TAG : \"该标签不存在\" , ERROR_NOT_EXIST_ARTICLE : \"该文章不存在\" , ERROR_AUTH_CHECK_TOKEN_FAIL : \"Token鉴权失败\" , ERROR_AUTH_CHECK_TOKEN_TIMEOUT : \"Token鉴权超时\" , ERROR_AUTH_TOKEN : \"Token生成失败\" , ERROR_AUTH : \"Token错误\" , } // GetMsg 获取错误信息 func GetMsg ( code int ) string { msg , ok := MsgFlags [ code ] if ok { return msg } return MsgFlags [ ERROR ] }","text_tokens":["20003","错误信息","建立","生成","invalid","article","200","msg","fail","信息","return","该","400","名称","10003"," ","10002","int","[","已","not","新建","文章","check","标签","_","请求","=","20004","]","目录","误码","(","api","tag","错误码","}","错误","模块",",","code","pkg","鉴权","存在","获取","auth","go","20001",".","string","token","错误代码","在","var","e","文件","func","20002","package","/","if","error","不","10001","ok","getmsg","\"","参数","params","误信","exist","下","代码",")","timeout","map","和","失败","500","超时","{",":","msgflags","success","const"],"title":"API错误码包","title_tokens":["误码","错误","api","包","错误码"]},{"location":"Golang/Project/02 API-1/#_3","text":"公共方法：例如获取分页页码等 go get -u github.com/unknwon/com 在 ./pkg/util 目录下新建 pagination.go 文件 package util import ( setting \"go-gin-example/pkg/settings\" \"github.com/gin-gonic/gin\" \"github.com/unknwon/com\" ) // GetPage 获取page数量 func GetPage ( c * gin . Context ) int { result := 0 // page转换为int page , _ := com . StrTo ( c . Query ( \"page\" )). Int () if page > 0 { result = ( page - 1 ) * setting . PageSize } return result }","text_tokens":["1","分页","settings","util","为","=",".","c","\"","com","context","pagesize","目录","(","在","数量","page","return","github","例如","getpage","get","方法","query","setting","下","unknwon","文件","gin",")","pagination","}","func","：","example","_",","," ","strto","package","int","等","新建","转换","*","公共","/","gonic","pkg","result","0","u","if","{","获取",":","import","go",">","页码","-"],"title":"工具包","title_tokens":["工具","工具包"]},{"location":"Golang/Project/02 API-1/#_4","text":"通过gorm将golang结构体映射到数据库中自动生成模型 go get -u github.com/jinzhu/gorm go get -u github.com/go-sql-driver/mysql 在 ./models 目录下新建 models.go 文件。 package models import ( \"fmt\" setting \"go-gin-example/pkg/settings\" \"log\" \"github.com/jinzhu/gorm\" ) var db * gorm . DB // Model 数据库模型 type Model struct { ID int `gorm:\"primary_key\" json:id` CreatedOn int `json:\"created_on\"` ModifiedOn int `json:\"modified_on\"` } func init () { var ( err error dbType , dbName , user , password , host , tablePrefix string ) // 获取配置文件的数据库配置 sec , err := setting . Cfg . GetSection ( \"database\" ) if err != nil { log . Fatal ( 2 , \"Fail to get get scetion `database`:%v\" , err ) } dbType = sec . Key ( \"TYPE\" ). String () dbName = sec . Key ( \"NAME\" ). String () user = sec . Key ( \"USER\" ). String () password = sec . Key ( \"PASSWORD\" ). String () host = sec . Key ( \"HOST\" ). String () tablePrefix = sec . Key ( \"TABLE_PREFIX\" ). String () db , err = gorm . Open ( dbtype , fmt . Sprintf ( \"%s:%s@tcp(%s)/%s?charset=utf8&parseTime=True&loc=Local\" , user , password , dbName )) if err != nil { log . Println ( err ) } gorm . DefaultTableNameHandler = func ( db * gorm . DB , defaultTableName string ) string { return tablePrefix + defaultTableName } db . SingularTable ( true ) db . LogMode ( true ) db . DB (). SetMaxIdleConns ( 10 ) db . DB (). SetMaxOpenConns ( 100 ) } // CloseDB 关闭数据库连接 func CloseDB () { defer db . Close () }","text_tokens":["生成","sql","自动","closedb","setmaxopenconns","。","setmaxidleconns","的","fail","return","sprintf","gin","password","defaulttablename","host"," ","local","通过","int","true","created","新建","*","logmode","fatal","import","id","driver","数据库","_","到","?","settings","体","=","utf8","golang","结构","loc","%","prefix","目录","(","tableprefix","get","&","err","scetion","}","sec","database",",","init","db","10","nil","pkg","defer","modified","model","获取","getsection","go","on","modifiedon","@","charset","-","2","数据","jinzhu","open",".","string","+","模型","com","singulartable","parsetime","在","dbtype","var","primary","setting","配置文件","type","文件","defaulttablenamehandler","tcp","中","func","name","package","100","key","/","gorm","u","if","error","println","json","close","fmt","将","createdon","据库","\"","配置","user","github","连接","v","下","log","映射","mysql","`",")","cfg","struct","s","example","关闭","table","dbname","{",":","models","!","to"],"title":"数据库模型映射","title_tokens":["数据","据库","模型","数据库","映射"]},{"location":"Golang/Project/02 API-1/#demo","text":"实例程序 在 ./ 目录下新建 main.go 文件 package main import ( \"fmt\" setting \"go-gin-example/pkg/settings\" \"net/http\" \"github.com/gin-gonic/gin\" ) func main () { router := gin . Default () router . GET ( \"/test\" , func ( c * gin . Context ) { c . JSON ( 200 , gin . H { \"message\" : \"test\" , }) }) s := & http . Server { Addr : fmt . Sprintf ( \":%d\" , setting . HTTPPort ), Handler : router , ReadTimeout : setting . ReadTimeout , WriteTimeout : setting . WriteTimeout , MaxHeaderBytes : 1 << 20 , } // 调用在&http.Server中设置的参数,因此上面要用&,要改变参数的值 s . ListenAndServe () } 浏览器输入 localhost：8000/test 返回 {\"message\":\"test\"} 则成功","text_tokens":["default","1","net","main","<","200","listenandserve","http","的","8000","程序","上面","sprintf","gin","返回"," ","新建","要用","*","addr","import","settings","=","readtimeout","context","%","目录","(","get","值","&","}","因此",",","httpport","pkg","writetimeout","浏览","go","-",".","com","maxheaderbytes","在","setting","文件","中","则","func","：","package","/","gonic","router","json","handler","20","设置","fmt","改变","h","\"","参数","test","成功","输入","github","下","server",")","浏览器","调用","s","message","example","要","localhost","实例","d","{",":","c"],"title":"Demo","title_tokens":["demo"]},{"location":"Golang/Project/02 API-1/#maingo","text":"在 ./routers 目录下新建 router.go 文件 package routers import ( setting \"go-gin-example/pkg/settings\" \"github.com/gin-gonic/gin\" ) func InitRouter () * gin . Engine { r := gin . New () r . Use ( gin . Logger ()) r . Use ( gin . Recovery ()) gin . SetMode ( setting . RunMode ) r . GET ( \"/test\" , func ( c * gin . Context ) { c . JSON ( 200 , gin . H { \"message\" : \"test\" , }) }) return r } 修改 main.go 文件 package main import ( \"fmt\" setting \"go-gin-example/pkg/settings\" \"go-gin-example/routers\" \"net/http\" ) func main () { router := routers . InitRouter () s := & http . Server { Addr : fmt . Sprintf ( \":%d\" , setting . HTTPPort ), Handler : router , ReadTimeout : setting . ReadTimeout , WriteTimeout : setting . WriteTimeout , MaxHeaderBytes : 1 << 20 , } s . ListenAndServer () }","text_tokens":["1","routers","main","net","settings","listenandserver","fmt","<","=",".","h","readtimeout","r","\"","c","com","context","200","new","%","maxheaderbytes","test","目录","(","http","在","use","return","github","get","initrouter","setting","下","&","server","sprintf","文件","gin",")","}","func","engine","message","example","s","recovery"," ",",","package","runmode","新建","*","httpport","/","router","pkg","gonic","d","setmode","writetimeout","{","addr",":","import","go","json","修改","handler","logger","-","20"],"title":"从main.go中分离路由","title_tokens":["main","中","路由","从",".","go","分离"]},{"location":"Golang/Project/02 API-1/#_5","text":"go-gin-example/ ├── conf │ └── app.ini ├── main.go ├── middleware ├── models │ └── models.go ├── pkg │ ├── e │ │ ├── code.go │ │ └── msg.go │ ├── setting │ │ └── setting.go │ └── util │ └── pagination.go ├── routers │ └── router.go ├── runtime","text_tokens":["routers","main","│","util",".","runtime","msg","─","ini","├","└","setting","e","gin","pagination","conf","example"," ","code","/","middleware","pkg","router","go","app","models","-"],"title":"当前目录结构","title_tokens":["当前","当前目录","目录","结构"]},{"location":"Golang/Project/03 API-2/","text":"go-gin-example 03：API-2 完成博客的标签类接口定义和编写 定义接口 定义文章标签的路由分发操作 获取标签列表：GET(“/tags”) 新建标签：POST(“/tags”) 更新指定标签：PUT(“/tags/:id”) 删除指定标签：DELETE(“/tags/:id”) 空壳路由 注册路由将请求分发到该路由中，由该API路由中函数处理 在./routers/api 下新建 v1 目录，目录内新建 tag.go 文件代表第一个API大版本 package v1 import ( \"github.com/gin-gonic/gin\" ) // GetTags 获取多个文章标签 func GetTags ( c * gin . Context ) { } // AddTag 新增文章标签 func AddTag ( c * gin . Context ) { } // EditTag 修改文章标签 func EditTag ( c * gin . Context ) { } // DeleteTag 删除文章标签 func DeleteTag ( c * gin . Context ) { } 注册路由 该路由负责分发各个api请求给相应的 handler 者 打开 ./routers 下的 router.go 文件，修改为： package routers import ( setting \"go-gin-example/pkg/settings\" v1 \"go-gin-example/routers/api/v1\" \"github.com/gin-gonic/gin\" ) // InitRouter 初始化路由 func InitRouter () * gin . Engine { r := gin . New () r . Use ( gin . Logger ()) r . Use ( gin . Recovery ()) gin . SetMode ( setting . RunMode ) apiv1 := r . Group ( \"/api/v1\" ) { apiv1 . GET ( \"/tags\" , v1 . GetTags ) apiv1 . POST ( \"/tags\" , v1 . AddTag ) apiv1 . PUT ( \"/tags/:id\" , v1 . EditTag ) apiv1 . DELETE ( \"/tags/:id\" , v1 . DeleteTag ) } return r } 用 go run main.go 检测是否成功注册路由 表单验证 用beego的validation来进行表单校验数据 该 tag.go 模型中继承了 model.Model 结构体外新增了标签结构体中的一些属性，在该文件下除了通过 gorm 映射数据库模型外还添加了对标签的CRUD操作方法，在 ./routers/api/v1/tag.go 中可以调用这些CRUD方法 go get -u github.com/astaxie/beego/validation 在 models 目录下的 tag.go 写入 package models import ( \"time\" \"github.com/jinzhu/gorm\" ) // Tag 标签结构体 // 给结构体赋予json属性, 在c.JSON中会自动转换 type Tag struct { // 继承Model的结构体 Model Name string `json:\"name\"` CreatedBy string `json:\"created_by\"` ModifiedBy string `json:\"modified_by\"` State int `json:\"state\"` } // BeforeCreate 创建标签之前自动补全CreatedOn时间 func ( tag * Tag ) BeforeCreate ( scope * gorm . Scope ) error { scope . SetColumn ( \"CreatedOn\" , time . Now (). Unix ()) return nil } // BeforeUpdate 更新标签之前自动补全ModifiedOn时间 func ( tag * Tag ) BeforeUpdate ( scope * gorm . Scope ) error { scope . SetColumn ( \"ModifiedOn\" , time . Now (). Unix ()) return nil } // GetTags 获取文章标签 func GetTags ( pageNum int , pageSize int , maps interface {}) ( tags [] Tag ) { db . Where ( maps ). Offset ( pageNum ). Limit ( pageSize ). Find ( & tags ) return } // GetTagTotal 获取全部文章标签 func GetTagTotal ( maps interface {}) ( count int ) { db . Model ( & Tag {}). Where ( maps ). Count ( & count ) return } // ExistTagByName 查询文章标签是否存在 func ExistTagByName ( name string ) bool { var tag Tag db . Select ( \"id\" ). Where ( \"name = ?\" , name ). First ( & tag ) if tag . ID > 0 { return true } return false } // ExistTagByID 查询ID文章是否存在 func ExistTagByID ( id int ) bool { var tag Tag db . Select ( \"id\" ). Where ( \"id = ?\" , id ). First ( & tag ) if tag . ID > 0 { return true } return false } // AddTag 添加文章标签 func AddTag ( name string , state int , createdBy string ) bool { db . Create ( & Tag { Name : name , State : state , CreatedBy : createdBy , }) return true } // DeleteTag 删除文章标签 func DeleteTag ( id int ) bool { db . Where ( \"id = ? \" , id ). Delete ( & Tag {}) return true } // EditTag 编辑文章标签 func EditTag ( id int , data interface {}) bool { db . Model ( & Tag {}). Where ( \"id = ? \" , id ). Update ( data ) return true } 编写标签列表的路由逻辑 完善空壳路由 通过 beego/validation 对URL传递进来的参数进行校验，操作为声明 validation.Validation 对象，调用其 .Required 、 .MaxSize 、 .Range 、 .Message 等方法 通过 c.Query 获取URL中 ?name=test&state=1 中的参数， c.DefaultQuery 则支持设置一个默认值 util.GetPage 确保各个接口的 page 处理是一致的 在 ./routers/v1/tag.go 写入 package v1 import ( \"go-gin-example/models\" \"go-gin-example/pkg/e\" setting \"go-gin-example/pkg/settings\" \"go-gin-example/pkg/util\" \"net/http\" \"github.com/astaxie/beego/validation\" \"github.com/gin-gonic/gin\" \"github.com/unknwon/com\" ) // GetTags 获取文章标签 func GetTags ( c * gin . Context ) { // 从URL获取参数 // localhost:8000/tags?name=test&state=1 name := c . Query ( \"name\" ) maps := make ( map [ string ] interface {}) data := make ( map [ string ] interface {}) if name != \"\" { // 如果存在name参数, 将其添加到maps中 maps [ \"name\" ] = name } var state = - 1 // should omit type , it will be inferred if arg := c . Query ( \"state\" ); arg != \"\" { // 如果URL中存在state参数, 且arg不等于空的时候 // 将state转换为int // 添加到maps[\"state\"]中 state = com . StrTo ( arg ). MustInt () maps [ \"state\" ] = state } code := e . SUCCESS // 找到该文章,将其添加到lists中返回 data [ \"lists\" ] = models . GetTags ( util . GetPage ( c ), setting . PageSize , maps ) data [ \"total\" ] = models . GetTagTotal ( maps ) c . JSON ( http . StatusOK , gin . H { \"code\" : code , \"msg\" : e . GetMsg ( code ), \"data\" : data , }) } // AddTag 增加文章标签 func AddTag ( c * gin . Context ) { name := c . Query ( \"name\" ) // state=0代表该标签不存在 // 设置默认值为0 state := com . StrTo ( c . DefaultQuery ( \"state\" , \"0\" )). MustInt () createdBy := c . Query ( \"created_by\" ) valid := validation . Validation {} valid . Required ( name , \"name\" ). Message ( \"名称不能为空\" ) valid . MaxSize ( name , 100 , \"name\" ). Message ( \"名称最长为100字符\" ) valid . Required ( createdBy , \"created_by\" ). Message ( \"创建人不能为空\" ) valid . MaxSize ( createdBy , 100 , \"created_by\" ). Message ( \"创建人最长为100字符\" ) valid . Range ( state , 0 , 1 , \"starte\" ). Message ( \"状态只允许0或1\" ) code := e . INVALID_PARAMS if ! valid . HasErrors () { if ! models . ExistTagByName ( name ) { code = e . SUCCESS models . AddTag ( name , state , createdBy ) } else { code = e . ERROR_EXIST_TAG } } c . JSON ( http . StatusOK , gin . H { \"code\" : code , \"msg\" : e . GetMsg ( code ), \"data\" : make ( map [ string ] string ), }) } // EditTag 修改文章标签 func EditTag ( c * gin . Context ) { id := com . StrTo ( c . Param ( \"id\" )). MustInt () name := c . Query ( \"name\" ) modifiedBy := c . Query ( \"modified_by\" ) valid := validation . Validation {} var state = - 1 if arg := c . Query ( \"state\" ); arg != \"\" { state = com . StrTo ( arg ). MustInt () valid . Range ( state , 0 , 1 , \"state\" ). Message ( \"状态只允许0或1\" ) } valid . Required ( id , \"id\" ). Message ( \"ID不能为空\" ) valid . Required ( modifiedBy , \"modiified_by\" ). Message ( \"修改人不能为空\" ) valid . MaxSize ( modifiedBy , 100 , \"modified_by\" ). Message ( \"修改人最长为100字符\" ) valid . MaxSize ( name , 100 , \"name\" ). Message ( \"名称最长为100字符\" ) code := e . INVALID_PARAMS if ! valid . HasErrors () { code = e . SUCCESS if models . ExistTagByID ( id ) { data := make ( map [ string ] interface {}) data [ \"modified_by\" ] = modifiedBy if name != \"\" { data [ \"name\" ] = name } if state != - 1 { data [ \"state\" ] = state } models . EditTag ( id , data ) } else { // 不存在, 无法修改标签 code = e . ERROR_NOT_EXIST_ARTICLE } } c . JSON ( http . StatusOK , gin . H { \"code\" : code , \"message\" : e . GetMsg ( code ), \"data\" : make ( map [ string ] string ), }) } // DeleteTag 删除文章标签 func DeleteTag ( c * gin . Context ) { id := com . StrTo ( c . Param ( \"id\" )). MustInt () valid := validation . Validation {} valid . Min ( id , 1 , \"id\" ). Message ( \"ID必须大于0\" ) code := e . INVALID_PARAMS if ! valid . HasErrors () { code = e . SUCCESS // 数据库操作 if models . ExistTagByID ( id ) { models . DeleteTag ( id ) } else { code = e . ERROR_NOT_EXIST_TAG } } c . JSON ( http . StatusOK , gin . H { \"code\" : code , \"msg\" : e . GetMsg ( code ), \"data\" : make ( map [ string ] string ), }) }","text_tokens":["main","版本","msg","查询","的","8000",";","检测","update","为空","created","not","”","mustint","文章","setmode","代表","import","相应","标签","到","请求","对","这些","=","pagesize","context","内","声明","haserrors","api","其","be","补全","编写",",","setcolumn","确保","delete","无法","modifiedby","go","2","数据",".","string","操作","模型","在","文件","则","不能","初始化","package","除了","edittag","赋予","false","handler","now","\"","据库","如果","多个","beforeupdate","exist","调用","用","crud","最长","大于","routers","deletetag","大","data","return","从","first","statusok","编辑","post","gin","url","名称","返回"," ","int","[","0","?","第一个","可以","属性","r","结构","字符","else","目录","find","方法","query","是否","修改文章","recovery","处理","由该","nil","只","操作方法","pkg","omit","model","对象","且","空壳","setting","中","：","100","lists","/","astaxie","gorm","u","addtag","了","createdon","total","params","starte","where","github","maxsize","should","下","映射","struct","路由","和","一个","inferred","或","{",":","!","c","1","net","校验","util","invalid","是","自动","、","initrouter","beforecreate","指定","time","bool","beego","新建","负责","*","gettags","“","v1","arg","id","修改","数据库","unix","create","settings","体","第一","]","validation","完成","必须","}","state","select","db","offset","tags","-","传递","modiified","创建","it","新增","允许","var","e","min","name","表单","增加","router","group","进来","error","进行","by","json","各个","logger","不","博客","设置","更新","03","getmsg","将","h","maps","count","参数","写入","逻辑","`",")","定义","message","类","interface","验证","时间","完善","默认值","success","时候","article","pagenum","http","createdby","page","一致","该","接口定义","一些","给","找到","打开","通过","true","gettagtotal","等","runmode","者","existtagbyid","range","_","为","初始","等于","继承","接口","(","tag","will","get","&","注册","put","支持","code","scope","存在","中会","modified","获取",">","modifiedon","strto","param","jinzhu","com","外","函数","use","还","type","required","func","engine","run","apiv1","创建人","gonic","空","列表","existtagbyname","if","体外","全部","limit","new","删除","成功","test","人","状态","分发","getpage","unknwon","体中","添加","map","example","，","来","之前","转换","localhost","make","defaultquery","models","valid","默认"],"title":"go-gin-example 03：API-2","title_tokens":["03","2","api","：","example"," ","go","gin","-"]},{"location":"Golang/Project/03 API-2/#go-gin-example-03api-2","text":"完成博客的标签类接口定义和编写","text_tokens":["博客","的","接口","定义","标签","完成","和","编写","类","接口定义"],"title":"go-gin-example 03：API-2","title_tokens":["03","2","api","：","example"," ","go","gin","-"]},{"location":"Golang/Project/03 API-2/#_1","text":"定义文章标签的路由分发操作 获取标签列表：GET(“/tags”) 新建标签：POST(“/tags”) 更新指定标签：PUT(“/tags/:id”) 删除指定标签：DELETE(“/tags/:id”)","text_tokens":["更新","操作","删除","的","(","分发","get","post","指定",")","定义","路由","：","put"," ","delete","新建","”","/","文章","“","列表","获取",":","id","tags","标签"],"title":"定义接口","title_tokens":["接口","定义"]},{"location":"Golang/Project/03 API-2/#_2","text":"注册路由将请求分发到该路由中，由该API路由中函数处理 在./routers/api 下新建 v1 目录，目录内新建 tag.go 文件代表第一个API大版本 package v1 import ( \"github.com/gin-gonic/gin\" ) // GetTags 获取多个文章标签 func GetTags ( c * gin . Context ) { } // AddTag 新增文章标签 func AddTag ( c * gin . Context ) { } // EditTag 修改文章标签 func EditTag ( c * gin . Context ) { } // DeleteTag 删除文章标签 func DeleteTag ( c * gin . Context ) { }","text_tokens":["addtag","routers","deletetag","将",".","c","\"","第一","com","context","版本","删除","新增","大","函数","目录","内","在","(","api","tag","分发","多个","github","该","下","文件","gin",")","}","中","路由","func","修改文章","，","注册"," ","处理","一个","package","由该","新建","*","gettags","/","gonic","文章","edittag","v1","代表","{","获取","import","go","修改","标签","到","第一个","请求","-"],"title":"空壳路由","title_tokens":["空壳","路由"]},{"location":"Golang/Project/03 API-2/#_3","text":"该路由负责分发各个api请求给相应的 handler 者 打开 ./routers 下的 router.go 文件，修改为： package routers import ( setting \"go-gin-example/pkg/settings\" v1 \"go-gin-example/routers/api/v1\" \"github.com/gin-gonic/gin\" ) // InitRouter 初始化路由 func InitRouter () * gin . Engine { r := gin . New () r . Use ( gin . Logger ()) r . Use ( gin . Recovery ()) gin . SetMode ( setting . RunMode ) apiv1 := r . Group ( \"/api/v1\" ) { apiv1 . GET ( \"/tags\" , v1 . GetTags ) apiv1 . POST ( \"/tags\" , v1 . AddTag ) apiv1 . PUT ( \"/tags/:id\" , v1 . EditTag ) apiv1 . DELETE ( \"/tags/:id\" , v1 . DeleteTag ) } return r } 用 go run main.go 检测是否成功注册路由","text_tokens":["routers","main","deletetag","的","return","initrouter","该","post","gin","给","检测"," ","打开","runmode","负责","*","者","gettags","v1","setmode","import","id","相应","修改","请求","为","settings","初始","=","r","(","api","get","是否","}","注册","recovery",",","put","delete","pkg","go","tags","-",".","com","use","setting","文件","func","：","engine","run","初始化","apiv1","package","/","router","gonic","edittag","group","handler","各个","logger","addtag","\"","new","成功","分发","github","下",")","路由","，","example","用","{",":"],"title":"注册路由","title_tokens":["路由","注册"]},{"location":"Golang/Project/03 API-2/#_4","text":"用beego的validation来进行表单校验数据 该 tag.go 模型中继承了 model.Model 结构体外新增了标签结构体中的一些属性，在该文件下除了通过 gorm 映射数据库模型外还添加了对标签的CRUD操作方法，在 ./routers/api/v1/tag.go 中可以调用这些CRUD方法 go get -u github.com/astaxie/beego/validation 在 models 目录下的 tag.go 写入 package models import ( \"time\" \"github.com/jinzhu/gorm\" ) // Tag 标签结构体 // 给结构体赋予json属性, 在c.JSON中会自动转换 type Tag struct { // 继承Model的结构体 Model Name string `json:\"name\"` CreatedBy string `json:\"created_by\"` ModifiedBy string `json:\"modified_by\"` State int `json:\"state\"` } // BeforeCreate 创建标签之前自动补全CreatedOn时间 func ( tag * Tag ) BeforeCreate ( scope * gorm . Scope ) error { scope . SetColumn ( \"CreatedOn\" , time . Now (). Unix ()) return nil } // BeforeUpdate 更新标签之前自动补全ModifiedOn时间 func ( tag * Tag ) BeforeUpdate ( scope * gorm . Scope ) error { scope . SetColumn ( \"ModifiedOn\" , time . Now (). Unix ()) return nil } // GetTags 获取文章标签 func GetTags ( pageNum int , pageSize int , maps interface {}) ( tags [] Tag ) { db . Where ( maps ). Offset ( pageNum ). Limit ( pageSize ). Find ( & tags ) return } // GetTagTotal 获取全部文章标签 func GetTagTotal ( maps interface {}) ( count int ) { db . Model ( & Tag {}). Where ( maps ). Count ( & count ) return } // ExistTagByName 查询文章标签是否存在 func ExistTagByName ( name string ) bool { var tag Tag db . Select ( \"id\" ). Where ( \"name = ?\" , name ). First ( & tag ) if tag . ID > 0 { return true } return false } // ExistTagByID 查询ID文章是否存在 func ExistTagByID ( id int ) bool { var tag Tag db . Select ( \"id\" ). Where ( \"id = ?\" , id ). First ( & tag ) if tag . ID > 0 { return true } return false } // AddTag 添加文章标签 func AddTag ( name string , state int , createdBy string ) bool { db . Create ( & Tag { Name : name , State : state , CreatedBy : createdBy , }) return true } // DeleteTag 删除文章标签 func DeleteTag ( id int ) bool { db . Where ( \"id = ? \" , id ). Delete ( & Tag {}) return true } // EditTag 编辑文章标签 func EditTag ( id int , data interface {}) bool { db . Model ( & Tag {}). Where ( \"id = ? \" , id ). Update ( data ) return true }","text_tokens":["routers","校验","deletetag","自动","pagenum","查询","的","createdby","data","return","first","该","编辑","beforecreate","一些","time","给","bool","update"," ","beego","通过","int","gettagtotal","true","[","created","*","gettags","文章","v1","0","existtagbyid","import","id","数据库","标签","_","unix","?","create","对","这些","可以","属性","体","=","结构","pagesize","继承","]","目录","(","find","validation","tag","api","get","方法","&","是否","}","补全",",","state","setcolumn","select","delete","db","offset","nil","操作方法","scope","存在","中会","modifiedby","modified","model","获取","go",">","modifiedon","tags","-","数据","jinzhu",".","string","创建","模型","操作","com","外","新增","在","var","还","type","文件","中","name","func","package","表单","除了","/","edittag","赋予","astaxie","false","gorm","u","existtagbyname","error","if","体外","进行","by","json","全部","addtag","了","更新","limit","now","createdon","据库","\"","maps","count","删除","写入","where","github","beforeupdate","下","体中","映射","`","添加",")","调用","struct","，","来","用","之前","转换","interface","crud","{",":","时间","models","c"],"title":"表单验证","title_tokens":["验证","表单"]},{"location":"Golang/Project/03 API-2/#_5","text":"完善空壳路由 通过 beego/validation 对URL传递进来的参数进行校验，操作为声明 validation.Validation 对象，调用其 .Required 、 .MaxSize 、 .Range 、 .Message 等方法 通过 c.Query 获取URL中 ?name=test&state=1 中的参数， c.DefaultQuery 则支持设置一个默认值 util.GetPage 确保各个接口的 page 处理是一致的 在 ./routers/v1/tag.go 写入 package v1 import ( \"go-gin-example/models\" \"go-gin-example/pkg/e\" setting \"go-gin-example/pkg/settings\" \"go-gin-example/pkg/util\" \"net/http\" \"github.com/astaxie/beego/validation\" \"github.com/gin-gonic/gin\" \"github.com/unknwon/com\" ) // GetTags 获取文章标签 func GetTags ( c * gin . Context ) { // 从URL获取参数 // localhost:8000/tags?name=test&state=1 name := c . Query ( \"name\" ) maps := make ( map [ string ] interface {}) data := make ( map [ string ] interface {}) if name != \"\" { // 如果存在name参数, 将其添加到maps中 maps [ \"name\" ] = name } var state = - 1 // should omit type , it will be inferred if arg := c . Query ( \"state\" ); arg != \"\" { // 如果URL中存在state参数, 且arg不等于空的时候 // 将state转换为int // 添加到maps[\"state\"]中 state = com . StrTo ( arg ). MustInt () maps [ \"state\" ] = state } code := e . SUCCESS // 找到该文章,将其添加到lists中返回 data [ \"lists\" ] = models . GetTags ( util . GetPage ( c ), setting . PageSize , maps ) data [ \"total\" ] = models . GetTagTotal ( maps ) c . JSON ( http . StatusOK , gin . H { \"code\" : code , \"msg\" : e . GetMsg ( code ), \"data\" : data , }) } // AddTag 增加文章标签 func AddTag ( c * gin . Context ) { name := c . Query ( \"name\" ) // state=0代表该标签不存在 // 设置默认值为0 state := com . StrTo ( c . DefaultQuery ( \"state\" , \"0\" )). MustInt () createdBy := c . Query ( \"created_by\" ) valid := validation . Validation {} valid . Required ( name , \"name\" ). Message ( \"名称不能为空\" ) valid . MaxSize ( name , 100 , \"name\" ). Message ( \"名称最长为100字符\" ) valid . Required ( createdBy , \"created_by\" ). Message ( \"创建人不能为空\" ) valid . MaxSize ( createdBy , 100 , \"created_by\" ). Message ( \"创建人最长为100字符\" ) valid . Range ( state , 0 , 1 , \"starte\" ). Message ( \"状态只允许0或1\" ) code := e . INVALID_PARAMS if ! valid . HasErrors () { if ! models . ExistTagByName ( name ) { code = e . SUCCESS models . AddTag ( name , state , createdBy ) } else { code = e . ERROR_EXIST_TAG } } c . JSON ( http . StatusOK , gin . H { \"code\" : code , \"msg\" : e . GetMsg ( code ), \"data\" : make ( map [ string ] string ), }) } // EditTag 修改文章标签 func EditTag ( c * gin . Context ) { id := com . StrTo ( c . Param ( \"id\" )). MustInt () name := c . Query ( \"name\" ) modifiedBy := c . Query ( \"modified_by\" ) valid := validation . Validation {} var state = - 1 if arg := c . Query ( \"state\" ); arg != \"\" { state = com . StrTo ( arg ). MustInt () valid . Range ( state , 0 , 1 , \"state\" ). Message ( \"状态只允许0或1\" ) } valid . Required ( id , \"id\" ). Message ( \"ID不能为空\" ) valid . Required ( modifiedBy , \"modiified_by\" ). Message ( \"修改人不能为空\" ) valid . MaxSize ( modifiedBy , 100 , \"modified_by\" ). Message ( \"修改人最长为100字符\" ) valid . MaxSize ( name , 100 , \"name\" ). Message ( \"名称最长为100字符\" ) code := e . INVALID_PARAMS if ! valid . HasErrors () { code = e . SUCCESS if models . ExistTagByID ( id ) { data := make ( map [ string ] interface {}) data [ \"modified_by\" ] = modifiedBy if name != \"\" { data [ \"name\" ] = name } if state != - 1 { data [ \"state\" ] = state } models . EditTag ( id , data ) } else { // 不存在, 无法修改标签 code = e . ERROR_NOT_EXIST_ARTICLE } } c . JSON ( http . StatusOK , gin . H { \"code\" : code , \"message\" : e . GetMsg ( code ), \"data\" : make ( map [ string ] string ), }) } // DeleteTag 删除文章标签 func DeleteTag ( c * gin . Context ) { id := com . StrTo ( c . Param ( \"id\" )). MustInt () valid := validation . Validation {} valid . Min ( id , 1 , \"id\" ). Message ( \"ID必须大于0\" ) code := e . INVALID_PARAMS if ! valid . HasErrors () { code = e . SUCCESS // 数据库操作 if models . ExistTagByID ( id ) { models . DeleteTag ( id ) } else { code = e . ERROR_NOT_EXIST_TAG } } c . JSON ( http . StatusOK , gin . H { \"code\" : code , \"msg\" : e . GetMsg ( code ), \"data\" : make ( map [ string ] string ), }) }","text_tokens":["1","routers","net","校验","util","deletetag","invalid","是","时候","article","msg","、","的","http","8000","createdby","page","data","一致","从","statusok","该",";","url","gin","名称","找到","返回"," ","通过","beego","int","等","gettagtotal","为空","[","created","not","*","gettags","mustint","文章","v1","arg","0","代表","existtagbyid","import","id","range","修改","数据库","标签","?","到","_","对","为","settings","=","pagesize","context","等于","字符","else","接口","(","]","声明","haserrors","validation","tag","will","方法","query","&","必须","其","be","}","修改文章","state",",","确保","处理","支持","code","只","无法","pkg","存在","omit","modifiedby","modified","获取","go","tags","strto","-","param","传递","modiified","数据",".","string","对象","操作","创建","com","it","且","在","允许","空壳","var","setting","e","type","required","min","中","则","name","func","不能","package","100","lists","创建人","增加","/","gonic","空","edittag","astaxie","existtagbyname","进来","if","error","进行","by","json","各个","不","addtag","设置","getmsg","将","h","total","\"","据库","maps","参数","删除","test","如果","写入","params","人","starte","状态","github","maxsize","getpage","should","exist","unknwon","添加",")","调用","路由","message","map","，","example","一个","inferred","转换","localhost","make","interface","或","{",":","完善","defaultquery","默认值","models","最长","!","valid","success","大于","c","默认"],"title":"编写标签列表的路由逻辑","title_tokens":["的","路由","列表","编写","标签","逻辑"]},{"location":"Golang/Project/04 API-3/","text":"go-gin-example 04：API-3 完成博客的文章类接口定义和编写 定义接口 定义文章的路由分发操作 获取文章列表：GET(“/articles”) 获取单篇文章：GET(“/articles/:id”) 更新文章：PUT(“/articles/:id”) 新建文章：POST(“/articles”) 删除文章：DELETE(“/tags/:id”) 空壳路由 文章请求处理API 在 ./routers/api/v1 下新建 article.go 文件 package v1 import ( \"go-gin-example/models\" \"go-gin-example/pkg/e\" setting \"go-gin-example/pkg/settings\" \"go-gin-example/pkg/util\" \"log\" \"net/http\" \"github.com/astaxie/beego/validation\" \"github.com/gin-gonic/gin\" \"github.com/unknwon/com\" ) // GetArticle 获取单个文章 func GetArticle ( c * gin . Context ) { id := com . StrTo ( c . Param ( \"id\" )). MustInt () valid := validation . Validation {} valid . Min ( id , 1 , \"id\" ). Message ( \"ID必须大于0\" ) code := e . INVALID_PARAMS var data interface {} if ! valid . HasErrors () { if models . ExistArticleByID ( id ) { data = models . GetArticle ( id ) code = e . SUCCESS } else { code = e . ERROR_NOT_EXIST_ARTICLE } } else { for _ , err := range valid . Errors { log . Printf ( \"err.key: %s, err.message: %s\" , err . Key , err . Message ) } } c . JSON ( http . StatusOK , gin . H { \"code\" : code , \"msg\" : e . GetMsg ( code ), \"data\" : data , }) } // GetArticles 获取多个文章 func GetArticles ( c * gin . Context ) { data := make ( map [ string ] interface {}) maps := make ( map [ string ] interface {}) valid := validation . Validation {} var state = - 1 if arg := c . Query ( \"state\" ); arg != \"\" { state = com . StrTo ( arg ). MustInt () maps [ \"state\" ] = state valid . Range ( state , 0 , 1 , \"state\" ). Message ( \"状态只允许0或1\" ) } var tagID = - 1 if arg := c . Query ( \"tag_id\" ); arg != \"\" { tagID = com . StrTo ( arg ). MustInt () maps [ \"tag_id\" ] = tagID valid . Min ( tagID , 1 , \"tag_id\" ). Message ( \"标签ID必须大于0\" ) } code := e . INVALID_PARAMS if ! valid . HasErrors () { data [ \"list\" ] = models . GetArticles ( util . GetPage ( c ), setting . PageSize , maps ) data [ \"total\" ] = models . GetTagTotal ( maps ) code = e . SUCCESS } else { for _ , err := range valid . Errors { log . Printf ( \"err.key:%s, err.message:%s\" , err . Key , err . Message ) } } c . JSON ( http . StatusOK , gin . H { \"code\" : code , \"msg\" : e . GetMsg ( code ), \"data\" : data , }) } // AddArticle 增加文章 func AddArticle ( c * gin . Context ) { tagID := com . StrTo ( c . Query ( \"tag_id\" )). MustInt () title := c . Query ( \"title\" ) desc := c . Query ( \"desc\" ) content := c . Query ( \"content\" ) createdBy := c . Query ( \"created_by\" ) state := com . StrTo ( c . Query ( \"state\" )). MustInt () valid := validation . Validation {} valid . Min ( tagID , 1 , \"tagID\" ). Message ( \"标签ID必须大于0\" ) valid . Required ( title , \"title\" ). Message ( \"题目不能为空\" ) valid . Required ( desc , \"desc\" ). Message ( \"描述不能为空\" ) valid . Required ( content , \"content\" ). Message ( \"内容不能为空\" ) valid . Required ( createdBy , \"created_by\" ). Message ( \"创建人不能为空\" ) valid . Range ( state , 0 , 1 , \"state\" ). Message ( \"状态只能是0或1\" ) code := e . INVALID_PARAMS if ! valid . HasErrors () { if models . ExistTagByID ( tagID ) { data := make ( map [ string ] interface {}) data [ \"tag_id\" ] = tagID data [ \"title\" ] = title data [ \"desc\" ] = desc data [ \"content\" ] = content data [ \"created_by\" ] = createdBy data [ \"state\" ] = state models . AddArticle ( data ) code = e . SUCCESS } else { code = e . ERROR_NOT_EXIST_TAG } } else { for _ , err := range valid . Errors { log . Printf ( \"err.key:%s, err.message%s\" , err . Key , err . Message ) } } c . JSON ( http . StatusOK , gin . H { \"code\" : code , \"msg\" : e . GetMsg ( code ), \"data\" : make ( map [ string ] string ), }) } // EditArticle 修改文章 func EditArticle ( c * gin . Context ) { valid := validation . Validation {} id := com . StrTo ( c . Query ( \"id\" )). MustInt () tagID := com . StrTo ( c . Query ( \"tag_id\" )). MustInt () title := c . Query ( \"title\" ) desc := c . Query ( \"desc\" ) content := c . Query ( \"content\" ) modifiedBy := c . Query ( \"modified_by\" ) var state = - 1 if arg := c . Query ( \"state\" ); arg != \"\" { state = com . StrTo ( arg ). MustInt () valid . Range ( state , 0 , 1 , \"state\" ). Message ( \"状态只能是0或1\" ) } valid . Min ( id , 1 , \"id\" ). Message ( \"ID必须大于0\" ) valid . MaxSize ( title , 100 , \"title\" ). Message ( \"标题最长为100字符\" ) valid . MaxSize ( desc , 255 , \"desc\" ). Message ( \"简述最长为255字符\" ) valid . MaxSize ( content , 65535 , \"content\" ). Message ( \"内容最长为65535字符\" ) valid . Required ( modifiedBy , \"modified_by\" ). Message ( \"修改人不能为空\" ) valid . MaxSize ( modifiedBy , 100 , \"modified_by\" ). Message ( \"修改人最长为100字符\" ) code := e . INVALID_PARAMS if ! valid . HasErrors () { if models . ExistArticleByID ( id ) { if models . ExistTagByID ( tagID ) { data := make ( map [ string ] interface {}) if tagID > 0 { data [ \"tag_id\" ] = tagID } if title != \"\" { data [ \"title\" ] = title } if desc != \"\" { data [ \"desc\" ] = desc } if content != \"\" { data [ \"content\" ] = content } data [ \"modified_by\" ] = modifiedBy models . EditArticle ( id , data ) code = e . SUCCESS } else { code = e . ERROR_NOT_EXIST_TAG } } else { code = e . ERROR_NOT_EXIST_ARTICLE } } else { for _ , err := range valid . Errors { log . Printf ( \"err.key:%s err.Message:%s\" , err . Key , err . Message ) } } c . JSON ( http . StatusOK , gin . H { \"code\" : code , \"msg\" : e . GetMsg ( code ), \"data\" : make ( map [ string ] string ), }) } // DeleteArticle 删除文章 func DeleteArticle ( c * gin . Context ) { id := com . StrTo ( c . Query ( \"id\" )). MustInt () valid := validation . Validation {} valid . Min ( id , 1 , \"id\" ). Message ( \"ID必须大于0\" ) code := e . INVALID_PARAMS if ! valid . HasErrors () { if models . ExistArticleByID ( id ) { models . DeleteArticle ( id ) code = e . SUCCESS } else { code = e . ERROR_NOT_EXIST_ARTICLE } } else { for _ , err := range valid . Errors { log . Printf ( \"err.Key:%s err.Message:%s\" , err . Key , err . Message ) } } c . JSON ( http . StatusOK , gin . H { \"code\" : code , \"msg\" : e . GetMsg ( code ), \"data\" : make ( map [ string ] string ), }) } 定义文章的数据库模型 数据库模型和相关CRUD操作 在 ./models 下新建 article.go 文件 package models import ( \"time\" \"github.com/jinzhu/gorm\" ) // Article 文章结构体 type Article struct { Model // 声明该`TagID`为索引 TagID int `json:\"tag_id\" gorm:\"index\"` Tag Tag `json:tag` Title string `json:\"title\"` Desc string `json:\"desc\"` Content string `json:\"content\"` CreatedBy string `json:\"created_by\"` ModifiedBy string `json:\"modified_by\"` State int `json:state\"` } // BeforeCreate 创建数据前的操作 func ( article * Article ) BeforeCreate ( scope * gorm . Scope ) error { // scope 包含当前执行的所有信息 scope . SetColumn ( \"CreateOn\" , time . Now (). Unix ()) return nil } // BeforeUpdate 更新(编辑)之前添加修改时间 func ( article * Article ) BeforeUpdate ( scope * gorm . Scope ) error { scope . SetColumn ( \"ModifiedOn\" , time . Now (). Unix ()) return nil } // ExistArticleByID 判断是否存在文章 func ExistArticleByID ( id int ) bool { var article Article db . Select ( \"id\" ). Where ( \"id = ?\" , id ). Find ( & article ) if article . ID > 0 { return true } return false } // GetArticleTotal 计算文章数量 func GetArticleTotal ( maps interface {}) ( count int ) { // 在Article数据库中查询所有数据后计数返回给count db . Model ( & Article {}). Where ( maps ). Count ( & count ) return count } // GetArticles 获取所有文章列表 func GetArticles ( pageNum int , pageSize int , maps interface {}) ( articles [] Article ) { // 根据条件预加载 db . Preload ( \"Tag\" ). Where ( maps ). Offset ( pageNum ). Limit ( pageSize ). Find ( & articles ) return articles } // GetArticle 获取单篇文章 func GetArticle ( id int ) ( article Article ) { // 找到该片文章, 返回到article中 db . Where ( \"id = ?\" , id ). First ( & article ) // 获取与该篇文章有关的Tag // 通过.Related关联到嵌套在Article内的Tag结构体 db . Model ( & article ). Related ( & article . Tag ) return article } // EditArticle 编辑文章 func EditArticle ( id int , data interface {}) bool { db . Model ( & Article {}). Where ( \"id = ?\" , id ). Update ( data ) return true } // AddArticle 添加文章 func AddArticle ( data map [ string ] interface {}) bool { db . Create ( & Article { // v.(I)类型断言: 判断接口v的实际类型是否为(I)类型 TagID : data [ \"tag_id\" ].( int ), Title : data [ \"title\" ].( string ), Desc : data [ \"desc\" ].( string ), Content : data [ \"content\" ].( string ), CreatedBy : data [ \"created_by\" ].( string ), State : data [ \"state\" ].( int ), }) return true } // DeleteArticle 删除文章 func DeleteArticle ( id int ) bool { db . Where ( \"id = ?\" , id ). Delete ( Article {}) return true }","text_tokens":["1","routers","net","util","invalid","是","article","简述","pagenum","msg","查询","根据","的","http","createdby","信息","data","return","计数","statusok","只能","该","编辑",";","first","beforecreate","post","接口定义","gin","time","给","加载","所有","getarticles","255","editarticle","找到","bool","返回"," ","update","beego","通过","为空","gettagtotal","int","true","[","created","not","新建","包含","”","*","mustint","当前","文章","“","计算","v1","0","arg","existtagbyid","嵌套","id","import","有关","实际","range","修改","数据库","标签","_","unix","?","请求","到","create","为","settings","articles","体","=","结构","pagesize","context","%","字符","else","i","接口","(","haserrors","]","声明","find","api","validation","tag","完成","内","list","get","query","&","必须","单个","printf","err","是否","desc","}","内容","相关","修改文章","条件","预","编写","put",",","state","delete","处理","setcolumn","select","code","索引","只","nil","db","04","offset","index","existarticlebyid","pkg","scope","存在","modifiedby","modified","model","获取","判断","go",">","modifiedon","tags","strto","类型","-","param","preload","数据","jinzhu",".","string","创建","操作","标题","com","模型","执行","在","允许","数量","篇文章","空壳","var","title","setting","getarticletotal","e","type","文件","required","min","addarticle","中","后","func","：","关联","content","不能","getarticle","package","for","题目","100","key","创建人","createon","增加","/","gonic","astaxie","false","列表","gorm","if","error","前","3","by","json","描述","与","博客","更新","limit","getmsg","now","h","total","\"","据库","单篇","errors","maps","count","删除","65535","params","人","多个","状态","where","分发","github","beforeupdate","getpage","maxsize","v","exist","下","log","message%","unknwon","`","添加",")","定义","struct","路由","s","message","map","example","tagid","和","断言","类","之前","interface","make","deletearticle","related","或","crud","{","该片",":","时间","models","最长","!","valid","success","大于","c"],"title":"go-gin-example 04：API-3","title_tokens":["api","：","example"," ","3","go","04","gin","-"]},{"location":"Golang/Project/04 API-3/#go-gin-example-04api-3","text":"完成博客的文章类接口定义和编写","text_tokens":["博客","的","文章","接口","定义","完成","和","编写","类","接口定义"],"title":"go-gin-example 04：API-3","title_tokens":["api","：","example"," ","3","go","04","gin","-"]},{"location":"Golang/Project/04 API-3/#_1","text":"定义文章的路由分发操作 获取文章列表：GET(“/articles”) 获取单篇文章：GET(“/articles/:id”) 更新文章：PUT(“/articles/:id”) 新建文章：POST(“/articles”) 删除文章：DELETE(“/tags/:id”)","text_tokens":["更新","articles","操作","单篇","删除","的","(","分发","get","post",")","定义","路由","：","put"," ","delete","新建","”","/","文章","“","列表","获取",":","id","tags"],"title":"定义接口","title_tokens":["接口","定义"]},{"location":"Golang/Project/04 API-3/#_2","text":"文章请求处理API 在 ./routers/api/v1 下新建 article.go 文件 package v1 import ( \"go-gin-example/models\" \"go-gin-example/pkg/e\" setting \"go-gin-example/pkg/settings\" \"go-gin-example/pkg/util\" \"log\" \"net/http\" \"github.com/astaxie/beego/validation\" \"github.com/gin-gonic/gin\" \"github.com/unknwon/com\" ) // GetArticle 获取单个文章 func GetArticle ( c * gin . Context ) { id := com . StrTo ( c . Param ( \"id\" )). MustInt () valid := validation . Validation {} valid . Min ( id , 1 , \"id\" ). Message ( \"ID必须大于0\" ) code := e . INVALID_PARAMS var data interface {} if ! valid . HasErrors () { if models . ExistArticleByID ( id ) { data = models . GetArticle ( id ) code = e . SUCCESS } else { code = e . ERROR_NOT_EXIST_ARTICLE } } else { for _ , err := range valid . Errors { log . Printf ( \"err.key: %s, err.message: %s\" , err . Key , err . Message ) } } c . JSON ( http . StatusOK , gin . H { \"code\" : code , \"msg\" : e . GetMsg ( code ), \"data\" : data , }) } // GetArticles 获取多个文章 func GetArticles ( c * gin . Context ) { data := make ( map [ string ] interface {}) maps := make ( map [ string ] interface {}) valid := validation . Validation {} var state = - 1 if arg := c . Query ( \"state\" ); arg != \"\" { state = com . StrTo ( arg ). MustInt () maps [ \"state\" ] = state valid . Range ( state , 0 , 1 , \"state\" ). Message ( \"状态只允许0或1\" ) } var tagID = - 1 if arg := c . Query ( \"tag_id\" ); arg != \"\" { tagID = com . StrTo ( arg ). MustInt () maps [ \"tag_id\" ] = tagID valid . Min ( tagID , 1 , \"tag_id\" ). Message ( \"标签ID必须大于0\" ) } code := e . INVALID_PARAMS if ! valid . HasErrors () { data [ \"list\" ] = models . GetArticles ( util . GetPage ( c ), setting . PageSize , maps ) data [ \"total\" ] = models . GetTagTotal ( maps ) code = e . SUCCESS } else { for _ , err := range valid . Errors { log . Printf ( \"err.key:%s, err.message:%s\" , err . Key , err . Message ) } } c . JSON ( http . StatusOK , gin . H { \"code\" : code , \"msg\" : e . GetMsg ( code ), \"data\" : data , }) } // AddArticle 增加文章 func AddArticle ( c * gin . Context ) { tagID := com . StrTo ( c . Query ( \"tag_id\" )). MustInt () title := c . Query ( \"title\" ) desc := c . Query ( \"desc\" ) content := c . Query ( \"content\" ) createdBy := c . Query ( \"created_by\" ) state := com . StrTo ( c . Query ( \"state\" )). MustInt () valid := validation . Validation {} valid . Min ( tagID , 1 , \"tagID\" ). Message ( \"标签ID必须大于0\" ) valid . Required ( title , \"title\" ). Message ( \"题目不能为空\" ) valid . Required ( desc , \"desc\" ). Message ( \"描述不能为空\" ) valid . Required ( content , \"content\" ). Message ( \"内容不能为空\" ) valid . Required ( createdBy , \"created_by\" ). Message ( \"创建人不能为空\" ) valid . Range ( state , 0 , 1 , \"state\" ). Message ( \"状态只能是0或1\" ) code := e . INVALID_PARAMS if ! valid . HasErrors () { if models . ExistTagByID ( tagID ) { data := make ( map [ string ] interface {}) data [ \"tag_id\" ] = tagID data [ \"title\" ] = title data [ \"desc\" ] = desc data [ \"content\" ] = content data [ \"created_by\" ] = createdBy data [ \"state\" ] = state models . AddArticle ( data ) code = e . SUCCESS } else { code = e . ERROR_NOT_EXIST_TAG } } else { for _ , err := range valid . Errors { log . Printf ( \"err.key:%s, err.message%s\" , err . Key , err . Message ) } } c . JSON ( http . StatusOK , gin . H { \"code\" : code , \"msg\" : e . GetMsg ( code ), \"data\" : make ( map [ string ] string ), }) } // EditArticle 修改文章 func EditArticle ( c * gin . Context ) { valid := validation . Validation {} id := com . StrTo ( c . Query ( \"id\" )). MustInt () tagID := com . StrTo ( c . Query ( \"tag_id\" )). MustInt () title := c . Query ( \"title\" ) desc := c . Query ( \"desc\" ) content := c . Query ( \"content\" ) modifiedBy := c . Query ( \"modified_by\" ) var state = - 1 if arg := c . Query ( \"state\" ); arg != \"\" { state = com . StrTo ( arg ). MustInt () valid . Range ( state , 0 , 1 , \"state\" ). Message ( \"状态只能是0或1\" ) } valid . Min ( id , 1 , \"id\" ). Message ( \"ID必须大于0\" ) valid . MaxSize ( title , 100 , \"title\" ). Message ( \"标题最长为100字符\" ) valid . MaxSize ( desc , 255 , \"desc\" ). Message ( \"简述最长为255字符\" ) valid . MaxSize ( content , 65535 , \"content\" ). Message ( \"内容最长为65535字符\" ) valid . Required ( modifiedBy , \"modified_by\" ). Message ( \"修改人不能为空\" ) valid . MaxSize ( modifiedBy , 100 , \"modified_by\" ). Message ( \"修改人最长为100字符\" ) code := e . INVALID_PARAMS if ! valid . HasErrors () { if models . ExistArticleByID ( id ) { if models . ExistTagByID ( tagID ) { data := make ( map [ string ] interface {}) if tagID > 0 { data [ \"tag_id\" ] = tagID } if title != \"\" { data [ \"title\" ] = title } if desc != \"\" { data [ \"desc\" ] = desc } if content != \"\" { data [ \"content\" ] = content } data [ \"modified_by\" ] = modifiedBy models . EditArticle ( id , data ) code = e . SUCCESS } else { code = e . ERROR_NOT_EXIST_TAG } } else { code = e . ERROR_NOT_EXIST_ARTICLE } } else { for _ , err := range valid . Errors { log . Printf ( \"err.key:%s err.Message:%s\" , err . Key , err . Message ) } } c . JSON ( http . StatusOK , gin . H { \"code\" : code , \"msg\" : e . GetMsg ( code ), \"data\" : make ( map [ string ] string ), }) } // DeleteArticle 删除文章 func DeleteArticle ( c * gin . Context ) { id := com . StrTo ( c . Query ( \"id\" )). MustInt () valid := validation . Validation {} valid . Min ( id , 1 , \"id\" ). Message ( \"ID必须大于0\" ) code := e . INVALID_PARAMS if ! valid . HasErrors () { if models . ExistArticleByID ( id ) { models . DeleteArticle ( id ) code = e . SUCCESS } else { code = e . ERROR_NOT_EXIST_ARTICLE } } else { for _ , err := range valid . Errors { log . Printf ( \"err.Key:%s err.Message:%s\" , err . Key , err . Message ) } } c . JSON ( http . StatusOK , gin . H { \"code\" : code , \"msg\" : e . GetMsg ( code ), \"data\" : make ( map [ string ] string ), }) }","text_tokens":["1","routers","net","util","invalid","是","article","简述","msg","http","createdby","data","statusok","只能",";","gin","getarticles","255","editarticle"," ","beego","为空","gettagtotal","[","created","not","新建","*","mustint","文章","v1","0","arg","existtagbyid","import","id","range","修改","标签","_","请求","为","settings","=","pagesize","context","%","字符","else","]","(","haserrors","api","validation","tag","list","query","必须","单个","printf","err","desc","}","内容","修改文章",",","state","处理","code","只","existarticlebyid","pkg","modifiedby","modified","获取","go",">","strto","param","-",".","string","创建","标题","com","在","允许","var","title","setting","e","文件","required","min","addarticle","func","content","不能","getarticle","package","for","题目","100","key","创建人","增加","/","gonic","astaxie","if","error","by","json","描述","getmsg","h","total","\"","errors","maps","65535","删除","params","人","多个","状态","github","getpage","maxsize","exist","下","log","message%","unknwon",")","s","message","map","example","tagid","interface","make","deletearticle","或","{",":","models","最长","!","valid","success","大于","c"],"title":"空壳路由","title_tokens":["空壳","路由"]},{"location":"Golang/Project/04 API-3/#_3","text":"数据库模型和相关CRUD操作 在 ./models 下新建 article.go 文件 package models import ( \"time\" \"github.com/jinzhu/gorm\" ) // Article 文章结构体 type Article struct { Model // 声明该`TagID`为索引 TagID int `json:\"tag_id\" gorm:\"index\"` Tag Tag `json:tag` Title string `json:\"title\"` Desc string `json:\"desc\"` Content string `json:\"content\"` CreatedBy string `json:\"created_by\"` ModifiedBy string `json:\"modified_by\"` State int `json:state\"` } // BeforeCreate 创建数据前的操作 func ( article * Article ) BeforeCreate ( scope * gorm . Scope ) error { // scope 包含当前执行的所有信息 scope . SetColumn ( \"CreateOn\" , time . Now (). Unix ()) return nil } // BeforeUpdate 更新(编辑)之前添加修改时间 func ( article * Article ) BeforeUpdate ( scope * gorm . Scope ) error { scope . SetColumn ( \"ModifiedOn\" , time . Now (). Unix ()) return nil } // ExistArticleByID 判断是否存在文章 func ExistArticleByID ( id int ) bool { var article Article db . Select ( \"id\" ). Where ( \"id = ?\" , id ). Find ( & article ) if article . ID > 0 { return true } return false } // GetArticleTotal 计算文章数量 func GetArticleTotal ( maps interface {}) ( count int ) { // 在Article数据库中查询所有数据后计数返回给count db . Model ( & Article {}). Where ( maps ). Count ( & count ) return count } // GetArticles 获取所有文章列表 func GetArticles ( pageNum int , pageSize int , maps interface {}) ( articles [] Article ) { // 根据条件预加载 db . Preload ( \"Tag\" ). Where ( maps ). Offset ( pageNum ). Limit ( pageSize ). Find ( & articles ) return articles } // GetArticle 获取单篇文章 func GetArticle ( id int ) ( article Article ) { // 找到该片文章, 返回到article中 db . Where ( \"id = ?\" , id ). First ( & article ) // 获取与该篇文章有关的Tag // 通过.Related关联到嵌套在Article内的Tag结构体 db . Model ( & article ). Related ( & article . Tag ) return article } // EditArticle 编辑文章 func EditArticle ( id int , data interface {}) bool { db . Model ( & Article {}). Where ( \"id = ?\" , id ). Update ( data ) return true } // AddArticle 添加文章 func AddArticle ( data map [ string ] interface {}) bool { db . Create ( & Article { // v.(I)类型断言: 判断接口v的实际类型是否为(I)类型 TagID : data [ \"tag_id\" ].( int ), Title : data [ \"title\" ].( string ), Desc : data [ \"desc\" ].( string ), Content : data [ \"content\" ].( string ), CreatedBy : data [ \"created_by\" ].( string ), State : data [ \"state\" ].( int ), }) return true } // DeleteArticle 删除文章 func DeleteArticle ( id int ) bool { db . Where ( \"id = ?\" , id ). Delete ( Article {}) return true }","text_tokens":["article","pagenum","查询","根据","的","createdby","信息","data","return","计数","first","该","编辑","beforecreate","time","给","加载","所有","getarticles","找到","editarticle","bool","返回"," ","update","通过","int","true","[","created","包含","新建","当前","*","文章","计算","0","嵌套","import","id","有关","实际","修改","数据库","unix","_","?","到","create","为","体","articles","=","结构","pagesize","i","]","(","内","声明","find","接口","tag","&","是否","desc","相关","}","条件","预","state","setcolumn",",","select","delete","索引","db","offset","nil","index","existarticlebyid","scope","存在","modifiedby","modified","model","获取","判断","go",">","modifiedon","类型","preload","数据","jinzhu",".","string","创建","模型","操作","com","执行","在","数量","篇文章","title","var","getarticletotal","type","文件","addarticle","后","中","func","关联","content","getarticle","package","createon","/","false","gorm","前","if","error","列表","by","json","与","更新","limit","now","据库","\"","maps","单篇","count","删除","where","github","beforeupdate","v","下","`","添加",")","struct","tagid","map","和","断言","之前","interface","deletearticle","related","crud","{","该片",":","时间","models"],"title":"定义文章的数据库模型","title_tokens":["文章","的","定义","数据","据库","模型","数据库"]},{"location":"Golang/Project/05 JWT/","text":"go-gin-example 05：JWT 为什么要JWT 当前的API接口虽然编写好了，但是这些API可以被随意调用，这样子是不安全的。因此需要通过 jwt-go 的方式来解决 如何使用JWT 下载依赖包： go get -u github.com/dgrijalva/jwt-go 编写 ./pkg/util 下的新建 jwt.go 文件 其中该工具包主要包含 生成Token 、 解析Token 功能 NewWithClaims 中加密方法有 SigningMethodHS256 ， SigningMethodHS384 、 SigningMethodHS512 三种 cropto.Hash 方案 package util import ( setting \"go-gin-example/pkg/settings\" \"time\" \"github.com/dgrijalva/jwt-go\" ) var jwtSecret = [] byte ( setting . JwtSecret ) // Claims 声明Claims结构体 type Claims struct { Username string `json: \"username\"` Password string `json: \"password\"` jwt . StandardClaims } // GenerateToken 生成密钥 func GenerateToken ( username , password string ) ( string , error ) { nowTime := time . Now () expireTime := nowTime . Add ( 3 * time . Hour ) claims := Claims { username , password , jwt . StandardClaims { ExpiresAt : expireTime . Unix (), Issuer : \"gin-blog\" , }, } // 对claims 进行加密 tokenClaims := jwt . NewWithClaims ( jwt . SigningMethodHS256 , claims ) // 获得加密后的token // 猜测为生成一个加密后的字符串给jwtSecret token , err := tokenClaims . SignedString ( jwtSecret ) return token , err } // ParseToken 解析密钥 func ParseToken ( token string ) ( * Claims , error ) { tokenClaims , err := jwt . ParseWithClaims ( token , & Claims {}, func ( token * jwt . Token ) ( interface {}, error ) { return jwtSecret , nil }) if tokenClaims != nil { if claims , ok := tokenClaims . Claims .( * Claims ); ok && tokenClaims . Valid { return claims , nil } } return nil , err } 编写Gin中间件，在 middleware 下新建 jwt 目录，在其中新建 jwt.go 文件写入 package jwt import ( \"go-gin-example/pkg/e\" \"go-gin-example/pkg/util\" \"net/http\" \"time\" \"github.com/gin-gonic/gin\" ) // JWT json web token func JWT () gin . HandlerFunc { return func ( c * gin . Context ) { var code int var data interface {} code = e . SUCCESS token := c . Query ( \"token\" ) if token == \"\" { code = e . INVALID_PARAMS } else { claims , err := util . ParseToken ( token ) if err != nil { code = e . ERROR_AUTH_CHECK_TOKEN_FAIL } else if time . Now (). Unix () > claims . ExpiresAt { code = e . ERROR_AUTH_CHECK_TOKEN_TIMEOUT } } if code != e . SUCCESS { c . JSON ( http . StatusUnauthorized , gin . H { \"code\" : code , \"msg\" : e . GetMsg ( code ), \"data\" : data , }) // 通过Abort确保当前的handler未被调用, 即当验证不正确的时候丢弃掉该处理 c . Abort () return } c . Next () } } 获得token，在 ./models 下新建 auth.go 文件写入 package models // Auth Token认证 type Auth struct { ID int `gorm:\"primary_key\" json:\"id\"` Username string `json:\"username\"` Password string `json:\"password\"` } // CheckAuth 验证token func CheckAuth ( username , password string ) bool { var auth Auth db . Select ( \"id\" ). Where ( Auth { Username : username , Password : password }). First ( & auth ) if auth . ID > 0 { return true } return false } 在 ./api 下新建 auth.go 文件写入 package api import ( \"go-gin-example/models\" \"go-gin-example/pkg/e\" \"go-gin-example/pkg/util\" \"log\" \"net/http\" \"github.com/astaxie/beego/validation\" \"github.com/gin-gonic/gin\" ) type auth struct { Username string `valid: \"Required; MaxSize(50)\" ` Password string `valid: \"Required; MaxSize(50)\"` } // GetAuth 获取认证 func GetAuth ( c * gin . Context ) { username := c . Query ( \"username\" ) password := c . Query ( \"password\" ) valid := validation . Validation {} a := auth { Username : username , Password : password } ok , _ := valid . Valid ( & a ) data := make ( map [ string ] interface {}) code := e . INVALID_PARAMS if ok { isExist := models . CheckAuth ( username , password ) // 如果存在该账号 if isExist { token , err := util . GenerateToken ( username , password ) if err != nil { code = e . ERROR_AUTH_TOKEN } else { data [ \"token\" ] = token code = e . SUCCESS } } else { // 不存在账号 code = e . ERROR_AUTH } } else { for _ , err := range valid . Errors { log . Println ( err . Key , err . Message ) } } c . JSON ( http . StatusOK , gin . H { \"code\" : code , \"msg\" : e . GetMsg ( code ), \"data\" : data , }) } 修改 router.go 文件 package routers import ( \"go-gin-example/middleware/jwt\" setting \"go-gin-example/pkg/settings\" \"go-gin-example/routers/api\" v1 \"go-gin-example/routers/api/v1\" \"github.com/gin-gonic/gin\" ) // InitRouter 初始化路由 func InitRouter () * gin . Engine { r := gin . New () r . Use ( gin . Logger ()) r . Use ( gin . Recovery ()) gin . SetMode ( setting . RunMode ) // 调用认证接口 r . GET ( \"/auth\" , api . GetAuth ) apiv1 := r . Group ( \"/api/v1\" ) // Group内的所有请求都需要经过JWT apiv1 . Use ( jwt . JWT ()) { apiv1 . GET ( \"/tags\" , v1 . GetTags ) apiv1 . POST ( \"/tags\" , v1 . AddTag ) apiv1 . PUT ( \"/tags/:id\" , v1 . EditTag ) apiv1 . DELETE ( \"/tags/:id\" , v1 . DeleteTag ) apiv1 . GET ( \"/articles\" , v1 . GetArticles ) apiv1 . GET ( \"/articles/:id\" , v1 . GetArticle ) apiv1 . POST ( \"/articles\" , v1 . AddArticle ) apiv1 . PUT ( \"/articles/:id\" , v1 . EditTag ) apiv1 . DELETE ( \"/atricles/:id\" , v1 . DeleteTag ) } return r } 调用 访问 http://127.0.0.1:8000/auth?username=test&password=test123456 获得token 带着token访问api http://127.0.0.1:8000/api/v1/articles?token=eyJhbGci...","text_tokens":["&&","net","routers","deletetag","util","生成","正确","nowtime","invalid","是","时候","包","。","expiretime","msg","、","的","如何","主要","http","fail","edittag","什么","data","8000","return","first","statusok","该","获得",";","initrouter","127.0","post","工具","gin","都","time","给","signedstring","所有","getarticles","password","解析","方式","bool"," ","猜测","通过","加密","signingmethodhs384","hour","int","true","[","包含","当前","新建","runmode","*","gettags","v1","0","setmode","check","样子","import","id","丢弃","range","unix","中间","_","修改","blog","请求","对","这些","?","可以","parsetoken","jwt","statusunauthorized","为","settings","初始","账号","体","articles","=","byte","结构","valid","tokenclaims","r","依赖","context","字符","好","else","访问","接口","(","]","声明","add","目录","api","validation","50","内","get","方法","&","query","为什么","eyjhbgci","虽然","err","isexist","}","newwithclaims","编写","因此",",","select","确保","recovery","处理","put","delete","expiresat","code","db","nil","着","pkg","存在","parsewithclaims","获取","...","其中","go","handlerfunc","auth",">","tags","beego","认证","-","字符串",".","string","token","com","generatetoken","随意","密钥","cropto","在","use","var","primary","setting","getauth","方案","三种","e","type","文件","required","checkauth","addarticle","后","中","atricles","func","：","engine","这","初始化","apiv1","package","getarticle","jwtsecret","for","next","key","claims","/","需要","middleware","gonic","web","router","astaxie","false","group","05","u","if","error","gorm","3","进行","println","json","standardclaims","handler","logger","功能","a","不","addtag","了","使用","ok","issuer","getmsg","username","now","h","\"","中间件","errors","new","解决","abort","如果","params","写入","test","where","github","maxsize","下","下载","log","`","hash","带",")","调用","struct","timeout","路由","map","message","example","，","来","被","dgrijalva","经过","要","signingmethodhs256","一个","即当","掉","signingmethodhs512","有","0.1","interface","验证","make","安全","test123456","{",":","但是","models","!","工具包","success","未","c"],"title":"go-gin-example 05：JWT","title_tokens":["jwt","：","05","example"," ","go","gin","-"]},{"location":"Golang/Project/05 JWT/#go-gin-example-05jwt","text":"","text_tokens":[],"title":"go-gin-example 05：JWT","title_tokens":["jwt","：","05","example"," ","go","gin","-"]},{"location":"Golang/Project/05 JWT/#jwt","text":"当前的API接口虽然编写好了，但是这些API可以被随意调用，这样子是不安全的。因此需要通过 jwt-go 的方式来解决","text_tokens":["了","jwt","是","-","。","随意","好","解决","的","接口","api","虽然","调用","方式","，","这","编写","因此","来","被","可以","通过"," ","当前","需要","安全","样子","但是","go","这些","不"],"title":"为什么要JWT","title_tokens":["jwt","要","为什么","什么"]},{"location":"Golang/Project/05 JWT/#jwt_1","text":"下载依赖包： go get -u github.com/dgrijalva/jwt-go 编写 ./pkg/util 下的新建 jwt.go 文件 其中该工具包主要包含 生成Token 、 解析Token 功能 NewWithClaims 中加密方法有 SigningMethodHS256 ， SigningMethodHS384 、 SigningMethodHS512 三种 cropto.Hash 方案 package util import ( setting \"go-gin-example/pkg/settings\" \"time\" \"github.com/dgrijalva/jwt-go\" ) var jwtSecret = [] byte ( setting . JwtSecret ) // Claims 声明Claims结构体 type Claims struct { Username string `json: \"username\"` Password string `json: \"password\"` jwt . StandardClaims } // GenerateToken 生成密钥 func GenerateToken ( username , password string ) ( string , error ) { nowTime := time . Now () expireTime := nowTime . Add ( 3 * time . Hour ) claims := Claims { username , password , jwt . StandardClaims { ExpiresAt : expireTime . Unix (), Issuer : \"gin-blog\" , }, } // 对claims 进行加密 tokenClaims := jwt . NewWithClaims ( jwt . SigningMethodHS256 , claims ) // 获得加密后的token // 猜测为生成一个加密后的字符串给jwtSecret token , err := tokenClaims . SignedString ( jwtSecret ) return token , err } // ParseToken 解析密钥 func ParseToken ( token string ) ( * Claims , error ) { tokenClaims , err := jwt . ParseWithClaims ( token , & Claims {}, func ( token * jwt . Token ) ( interface {}, error ) { return jwtSecret , nil }) if tokenClaims != nil { if claims , ok := tokenClaims . Claims .( * Claims ); ok && tokenClaims . Valid { return claims , nil } } return nil , err } 编写Gin中间件，在 middleware 下新建 jwt 目录，在其中新建 jwt.go 文件写入 package jwt import ( \"go-gin-example/pkg/e\" \"go-gin-example/pkg/util\" \"net/http\" \"time\" \"github.com/gin-gonic/gin\" ) // JWT json web token func JWT () gin . HandlerFunc { return func ( c * gin . Context ) { var code int var data interface {} code = e . SUCCESS token := c . Query ( \"token\" ) if token == \"\" { code = e . INVALID_PARAMS } else { claims , err := util . ParseToken ( token ) if err != nil { code = e . ERROR_AUTH_CHECK_TOKEN_FAIL } else if time . Now (). Unix () > claims . ExpiresAt { code = e . ERROR_AUTH_CHECK_TOKEN_TIMEOUT } } if code != e . SUCCESS { c . JSON ( http . StatusUnauthorized , gin . H { \"code\" : code , \"msg\" : e . GetMsg ( code ), \"data\" : data , }) // 通过Abort确保当前的handler未被调用, 即当验证不正确的时候丢弃掉该处理 c . Abort () return } c . Next () } } 获得token，在 ./models 下新建 auth.go 文件写入 package models // Auth Token认证 type Auth struct { ID int `gorm:\"primary_key\" json:\"id\"` Username string `json:\"username\"` Password string `json:\"password\"` } // CheckAuth 验证token func CheckAuth ( username , password string ) bool { var auth Auth db . Select ( \"id\" ). Where ( Auth { Username : username , Password : password }). First ( & auth ) if auth . ID > 0 { return true } return false } 在 ./api 下新建 auth.go 文件写入 package api import ( \"go-gin-example/models\" \"go-gin-example/pkg/e\" \"go-gin-example/pkg/util\" \"log\" \"net/http\" \"github.com/astaxie/beego/validation\" \"github.com/gin-gonic/gin\" ) type auth struct { Username string `valid: \"Required; MaxSize(50)\" ` Password string `valid: \"Required; MaxSize(50)\"` } // GetAuth 获取认证 func GetAuth ( c * gin . Context ) { username := c . Query ( \"username\" ) password := c . Query ( \"password\" ) valid := validation . Validation {} a := auth { Username : username , Password : password } ok , _ := valid . Valid ( & a ) data := make ( map [ string ] interface {}) code := e . INVALID_PARAMS if ok { isExist := models . CheckAuth ( username , password ) // 如果存在该账号 if isExist { token , err := util . GenerateToken ( username , password ) if err != nil { code = e . ERROR_AUTH_TOKEN } else { data [ \"token\" ] = token code = e . SUCCESS } } else { // 不存在账号 code = e . ERROR_AUTH } } else { for _ , err := range valid . Errors { log . Println ( err . Key , err . Message ) } } c . JSON ( http . StatusOK , gin . H { \"code\" : code , \"msg\" : e . GetMsg ( code ), \"data\" : data , }) } 修改 router.go 文件 package routers import ( \"go-gin-example/middleware/jwt\" setting \"go-gin-example/pkg/settings\" \"go-gin-example/routers/api\" v1 \"go-gin-example/routers/api/v1\" \"github.com/gin-gonic/gin\" ) // InitRouter 初始化路由 func InitRouter () * gin . Engine { r := gin . New () r . Use ( gin . Logger ()) r . Use ( gin . Recovery ()) gin . SetMode ( setting . RunMode ) // 调用认证接口 r . GET ( \"/auth\" , api . GetAuth ) apiv1 := r . Group ( \"/api/v1\" ) // Group内的所有请求都需要经过JWT apiv1 . Use ( jwt . JWT ()) { apiv1 . GET ( \"/tags\" , v1 . GetTags ) apiv1 . POST ( \"/tags\" , v1 . AddTag ) apiv1 . PUT ( \"/tags/:id\" , v1 . EditTag ) apiv1 . DELETE ( \"/tags/:id\" , v1 . DeleteTag ) apiv1 . GET ( \"/articles\" , v1 . GetArticles ) apiv1 . GET ( \"/articles/:id\" , v1 . GetArticle ) apiv1 . POST ( \"/articles\" , v1 . AddArticle ) apiv1 . PUT ( \"/articles/:id\" , v1 . EditTag ) apiv1 . DELETE ( \"/atricles/:id\" , v1 . DeleteTag ) } return r } 调用 访问 http://127.0.0.1:8000/auth?username=test&password=test123456 获得token 带着token访问api http://127.0.0.1:8000/api/v1/articles?token=eyJhbGci...","text_tokens":["&&","net","routers","deletetag","util","生成","正确","nowtime","invalid","时候","包","expiretime","msg","、","的","http","主要","fail","edittag","8000","data","return","first","statusok","该","获得",";","initrouter","127.0","post","工具","gin","都","time","给","signedstring","所有","getarticles","password","解析","bool"," ","猜测","加密","signingmethodhs384","hour","int","通过","true","[","包含","当前","新建","runmode","*","gettags","v1","0","setmode","check","import","id","丢弃","range","unix","中间","_","修改","blog","请求","对","?","parsetoken","jwt","statusunauthorized","为","settings","初始","账号","体","articles","=","byte","结构","valid","tokenclaims","r","依赖","context","字符","else","访问","]","(","add","声明","目录","接口","api","validation","50","内","get","方法","&","query","eyjhbgci","err","isexist","}","newwithclaims","编写",",","select","确保","recovery","处理","put","delete","expiresat","code","db","nil","着","pkg","存在","parsewithclaims","获取","...","其中","go","handlerfunc","auth",">","tags","beego","认证","-","字符串",".","string","token","com","generatetoken","密钥","cropto","在","use","var","primary","setting","getauth","方案","三种","e","type","文件","required","checkauth","addarticle","后","中","atricles","func","：","engine","初始化","apiv1","package","getarticle","jwtsecret","for","next","key","claims","/","middleware","gonic","router","web","需要","astaxie","false","group","u","gorm","if","error","3","进行","println","json","standardclaims","handler","logger","功能","a","不","addtag","ok","issuer","getmsg","username","now","h","\"","中间件","errors","new","abort","如果","params","写入","test","where","github","maxsize","下","下载","log","`","hash","带",")","调用","struct","timeout","路由","map","message","，","example","被","dgrijalva","经过","signingmethodhs256","一个","即当","掉","signingmethodhs512","有","0.1","interface","验证","make","test123456","{",":","models","!","工具包","success","未","c"],"title":"如何使用JWT","title_tokens":["如何","jwt","使用"]},{"location":"Golang/Project/08 Swagger/","text":"go-gin-example 08： Swagger Swagger是什么? 接口生成器：自动生成接口文档 如何在golang中使用Swagger 安装 安装swag go get -u github.com/swaggo/swag/cmd/swag ，如果没有将 $GOROOT/bin 添加到 $PATH 中，则需要将swag的可执行文件移到 $GOBIN 中 验证是否安装成功 $ swag -v swag version v1.6.3 安装gin-swagger go get -u github.com/swaggo/gin-swagger go get -u github.com/swaggo/gin-swagger/swaggerFiles 编写swag // Response 定义 swag 文档返回的结构体 type Response struct { Code int ` json : \" code \" ` Msg string ` json : \" msg \" ` Data interface {} ` json : \" data \" ` } // GetArticles 获取多个文章 // @ Summary 获取多个文章 // @ Produce json // @ Param tag_id body int false \" TagID \" // @ Param state body int false \" State \" // @ Param created_by body int false \" CreatedBy \" // @ Success 200 { object } Response // @ Failure 500 { object } Response // @ Router / api / v1 / articles [ get ] func GetArticles ( c * gin . Context ) { data : = make ( map [ string ] interface {} ) maps : = make ( map [ string ] interface {} ) valid : = validation . Validation {} var state = - 1 if arg : = c . Query ( \" state \" ) ; arg != \"\" { state = com . StrTo ( arg ) . MustInt () maps [ \" state \" ] = state valid . Range ( state , 0 , 1 , \" state \" ) . Message ( \" 状态只允许0或1 \" ) } var tagID = - 1 if arg : = c . Query ( \" tag_id \" ) ; arg != \"\" { tagID = com . StrTo ( arg ) . MustInt () maps [ \" tag_id \" ] = tagID valid . Min ( tagID , 1 , \" tag_id \" ) . Message ( \" 标签ID必须大于0 \" ) } code : = e . INVALID_PARAMS if ! valid . HasErrors () { data [ \" list \" ] = models . GetArticles ( util . GetPage ( c ) , setting . PageSize , maps ) data [ \" total \" ] = models . GetTagTotal ( maps ) code = e . SUCCESS } else { for _ , err : = range valid . Errors { log . Printf ( \" err.key:%s, err.message:%s \" , err . Key , err . Message ) } } c . JSON ( http . StatusOK , gin . H { \" code \" : code , \" msg \" : e . GetMsg ( code ) , \" data \" : data , } ) } 格式 // @Summary API描述 // @Produce json[生成..内容] // @Param id path/body/query int[type] false/true \"ID\"[程序中对应变量名字] // @Success 200 string \"ok\" --成功返回信息 // @Failure 500 string \"bad\" --失败返回信息 // @Routers api/v1/article/{id} [GET] 请求id, 请求方法 效果 访问 http://127.0.0.1:8000/swagger/index.html","text_tokens":["1","routers","bin","util","生成","summary","08","是","gobin","invalid","自动","article","200","$","msg","如何","的","http","8000","createdby","什么","data","信息","bad","statusok","127.0","程序",";","gin","getarticles","变量","html","返回"," ","行文","int","gettagtotal","true","[","created","*","mustint","文章","v1","arg","0","id","range","标签","到","?","_","请求","体","articles","=","golang","结构","pagesize","context","swagger","%","格式","else","访问","接口","]","(","haserrors","tag","api","validation","list","get","failure","query","方法","必须","对应","printf","err","文档","是否","移","}","内容","编写","state",",","code","只","index","path","cmd","swaggo","获取","go","@","strto","名字","-","produce","param",".","string","执行","com","response","在","允许","成器","var","goroot","setting","e","安装","文件","type","min","中","则","func","：","body","for","key","/","需要","router","false","u","if","3","by","json","描述","object","使用","ok","getmsg","将","swag","h","total","\"","maps","errors","v1.6","生成器","..","如果","成功","params","多个","状态","效果","github","v","getpage","log","`","添加",")","定义","struct","s","tagid","map","example","，","message","没有","500","失败","0.1","interface","验证","swaggerfiles","make","version","或","{",":","models","可执行文件","!","valid","success","大于","c"],"title":"go-gin-example 08： Swagger","title_tokens":["：","example"," ","08","go","swagger","gin","-"]},{"location":"Golang/Project/08 Swagger/#go-gin-example-08-swagger","text":"","text_tokens":[],"title":"go-gin-example 08： Swagger","title_tokens":["：","example"," ","08","go","swagger","gin","-"]},{"location":"Golang/Project/08 Swagger/#swagger","text":"接口生成器：自动生成接口文档","text_tokens":["接口","：","生成","成器","自动","生成器","文档"],"title":"Swagger是什么?","title_tokens":["?","swagger","是","什么"]},{"location":"Golang/Project/08 Swagger/#golangswagger","text":"","text_tokens":[],"title":"如何在golang中使用Swagger","title_tokens":["如何","使用","在","中","golang","swagger"]},{"location":"Golang/Project/08 Swagger/#_1","text":"安装swag go get -u github.com/swaggo/swag/cmd/swag ，如果没有将 $GOROOT/bin 添加到 $PATH 中，则需要将swag的可执行文件移到 $GOBIN 中 验证是否安装成功 $ swag -v swag version v1.6.3 安装gin-swagger go get -u github.com/swaggo/gin-swagger go get -u github.com/swaggo/gin-swagger/swaggerFiles","text_tokens":["bin","将","swag",".","gobin","执行","com","v1.6","$","swagger","如果","的","成功","github","v","get","goroot","安装","文件","添加","移","是否","gin","中","则","，"," ","行文","没有","/","需要","验证","swaggerfiles","path","version","cmd","u","swaggo","3","go","可执行文件","到","-"],"title":"安装","title_tokens":["安装"]},{"location":"Golang/Project/08 Swagger/#swag","text":"// Response 定义 swag 文档返回的结构体 type Response struct { Code int ` json : \" code \" ` Msg string ` json : \" msg \" ` Data interface {} ` json : \" data \" ` } // GetArticles 获取多个文章 // @ Summary 获取多个文章 // @ Produce json // @ Param tag_id body int false \" TagID \" // @ Param state body int false \" State \" // @ Param created_by body int false \" CreatedBy \" // @ Success 200 { object } Response // @ Failure 500 { object } Response // @ Router / api / v1 / articles [ get ] func GetArticles ( c * gin . Context ) { data : = make ( map [ string ] interface {} ) maps : = make ( map [ string ] interface {} ) valid : = validation . Validation {} var state = - 1 if arg : = c . Query ( \" state \" ) ; arg != \"\" { state = com . StrTo ( arg ) . MustInt () maps [ \" state \" ] = state valid . Range ( state , 0 , 1 , \" state \" ) . Message ( \" 状态只允许0或1 \" ) } var tagID = - 1 if arg : = c . Query ( \" tag_id \" ) ; arg != \"\" { tagID = com . StrTo ( arg ) . MustInt () maps [ \" tag_id \" ] = tagID valid . Min ( tagID , 1 , \" tag_id \" ) . Message ( \" 标签ID必须大于0 \" ) } code : = e . INVALID_PARAMS if ! valid . HasErrors () { data [ \" list \" ] = models . GetArticles ( util . GetPage ( c ) , setting . PageSize , maps ) data [ \" total \" ] = models . GetTagTotal ( maps ) code = e . SUCCESS } else { for _ , err : = range valid . Errors { log . Printf ( \" err.key:%s, err.message:%s \" , err . Key , err . Message ) } } c . JSON ( http . StatusOK , gin . H { \" code \" : code , \" msg \" : e . GetMsg ( code ) , \" data \" : data , } ) } 格式 // @Summary API描述 // @Produce json[生成..内容] // @Param id path/body/query int[type] false/true \"ID\"[程序中对应变量名字] // @Success 200 string \"ok\" --成功返回信息 // @Failure 500 string \"bad\" --失败返回信息 // @Routers api/v1/article/{id} [GET] 请求id, 请求方法","text_tokens":["1","routers","util","生成","summary","invalid","article","200","msg","的","http","createdby","信息","data","bad","statusok","程序",";","gin","getarticles","变量","返回"," ","int","gettagtotal","true","[","created","*","mustint","文章","v1","arg","0","id","range","标签","_","请求","体","articles","=","结构","pagesize","context","%","格式","else","]","(","haserrors","tag","api","validation","list","get","failure","query","方法","必须","对应","printf","err","文档","}","内容","state",",","code","只","path","获取","@","strto","名字","-","param","produce","string",".","com","response","允许","var","setting","e","type","min","中","func","body","for","key","/","router","false","if","by","json","描述","object","ok","getmsg","swag","h","total","\"","maps","errors","..","成功","params","多个","状态","getpage","log","`",")","定义","struct","s","tagid","map","message","失败","500","interface","make","或","{",":","models","!","valid","success","大于","c"],"title":"编写swag","title_tokens":["编写","swag"]},{"location":"Golang/Project/08 Swagger/#_2","text":"访问 http://127.0.0.1:8000/swagger/index.html","text_tokens":["http","8000","html",".",":"," ","127.0","swagger","0.1","index","访问","/"],"title":"效果","title_tokens":["效果"]},{"location":"Golang/Project/09 Docker/","text":"go-gin-example 09：Docker Docker是什么 Docker is a set of platform as a service (PaaS) products that use OS-level virtualization to deliver software in packages called containers.[6] Containers are isolated from one another and bundle their own software, libraries and configuration files; they can communicate with each other through well-defined channels.[7] All containers are run by a single operating-system kernel and are thus more lightweight than virtual machines.[8] Docker是Paas的产品, 通过被成为 容器 的 系统级别 的虚拟化交付软件. 如何使用Docker 安装Docker(WIN10 PRO) 右键WINDOWS - 应用和功能 - 程序和功能 - 启用或关闭WINDOS功能 - 开启Hyper-V 开启 Hyper-V 可能导致 ShadowSocksR 端口被占用 官网 Docker基本指令 编写Dockerfile FROM golang:latest ENV GOPROXY https://goproxy.cn,direct WORKDIR $GOPATH /src/go-gin-example COPY . $GOPATH /src/go-gin-example RUN go build . EXPOSE 8000 ENTRYPOINT [ \"./go-gin-example\" ] FROM : 指定基础镜像, 该指令必须要有,且得为第一条 WORKDIR : 指定工作目录路径, 若目录不存在, 则会创建改目录 COPY : 源路径 ... 目标路径, COPY 指令将 Dockerfile 文件所存在的上下文目录 复制 到目标路径位置 RUN : 执行命令 EXPOSE : 声明 运行时容器 提供服务端口, 仅仅是一个 声明 , 不会因为这个声明而开启这个端口 ENTRYPOINT : 指定 容器 启动程序的及参数(执行 ./go-gin-example) 运行 docker build - t gin - blog - docker . docker images docker run - p 8000 : 8000 gin - blog - docker 在 . 当前环境运行 docker build 创建/构建镜像, -t 指定名称 docker images 查看镜像是否创建成功 在本地8000端口运行容器 发现 dial tcp 127.0.0.1:3306: connect: connection refused 错误 配置Mysql Docker docker pull mysql docker run --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root -d mysql 拉取mysql镜像 配置mysql端口 修改配置文件 conf.ini [database] TYPE = mysql USER = root PASSWORD = rootroot HOST = mysql:3306 NAME = blog TABLE_PREFIX = blog_ 关联Golang容器和Mysql容器 docker run --link mysql:mysql -p 8000:8000 gin-blog-docker 效果","text_tokens":["第一条","workdir","own","one","是","defined","direct","$","查看","的","成为","如何","are","each","8000","什么","应用","platform","这个","右键","09","官网","src","程序","该",";","127.0","set","p","gin","指定","dockerfile","3306","password","命令","名称","提供","conf","they","host","上下文"," ","another","通过","交付","docker","[","启动","当前","libraries","level","latest","in","configuration","all","修改","到","时","容器","blog","_","得","from","shadowsocksr","为","若","cn","expose","=","一条","files","golang","第一","虚拟","service","prefix","]","(","目录","声明","rootroot","因为","占用","of","而","gopath","必须","pro","than","软件","是否","database","错误","路径","编写","拉取",",","pull","copy","virtualization","root","virtual","dial","系统","上下","改","存在","基本","is","and","启用","...","other","go","connection","bundle","build","执行命令","-","through","复制","镜像",".","基础","创建","containers","会","执行","且","refused","single","不会","use","在","下文","8","级别","well","operating","配置文件","服务","their","win10","运行","及","with","安装","文件","e","connect","type","tcp","lightweight","则","name","：","run","关联","images","packages","t","communicate","导致","hyper","/","工作","products","本地","paas","by","可能","windows","功能","channels","a","不","位置","使用","can","将","thus","配置","goproxy","\"","user","参数","that","指令","isolated","windos","开启","https","成功","ini","效果","仅仅","发现","called","v","more","端口","目标","mysql",")","as","os","software","example","和","link","被","要","一个","7","关闭","table","entrypoint","有","0.1","环境","deliver","虚拟化","产品","machines","所","d","或","构建","env",":","system","kernel","源","6","to"],"title":"go-gin-example 09：Docker","title_tokens":["：","example","09"," ","go","docker","gin","-"]},{"location":"Golang/Project/09 Docker/#go-gin-example-09docker","text":"","text_tokens":[],"title":"go-gin-example 09：Docker","title_tokens":["：","example","09"," ","go","docker","gin","-"]},{"location":"Golang/Project/09 Docker/#docker","text":"Docker is a set of platform as a service (PaaS) products that use OS-level virtualization to deliver software in packages called containers.[6] Containers are isolated from one another and bundle their own software, libraries and configuration files; they can communicate with each other through well-defined channels.[7] All containers are run by a single operating-system kernel and are thus more lightweight than virtual machines.[8] Docker是Paas的产品, 通过被成为 容器 的 系统级别 的虚拟化交付软件.","text_tokens":["own","one","是","defined","的","成为","are","each","platform",";","set","they"," ","another","通过","交付","docker","[","libraries","level","in","configuration","all","容器","from","files","虚拟","service","]","(","of","than","软件",",","virtualization","virtual","系统","is","and","other","bundle","-","through",".","containers","single","use","8","级别","well","operating","their","with","lightweight","run","packages","communicate","products","paas","by","channels","a","can","thus","that","isolated","called","more",")","as","os","software","被","7","deliver","虚拟化","产品","machines","system","kernel","6","to"],"title":"Docker是什么","title_tokens":["是","什么","docker"]},{"location":"Golang/Project/09 Docker/#docker_1","text":"","text_tokens":[],"title":"如何使用Docker","title_tokens":["如何","使用","docker"]},{"location":"Golang/Project/09 Docker/#dockerwin10-pro","text":"右键WINDOWS - 应用和功能 - 程序和功能 - 启用或关闭WINDOS功能 - 开启Hyper-V 开启 Hyper-V 可能导致 ShadowSocksR 端口被占用 官网","text_tokens":["shadowsocksr","windos","开启","占用","应用","右键","v","官网","程序","端口","和"," ","被","关闭","导致","hyper","或","启用","可能","windows","功能","-"],"title":"安装Docker(WIN10 PRO)","title_tokens":["(","pro"," ","win10","docker","安装",")"]},{"location":"Golang/Project/09 Docker/#docker_2","text":"","text_tokens":[],"title":"Docker基本指令","title_tokens":["指令","基本","docker"]},{"location":"Golang/Project/09 Docker/#dockerfile","text":"FROM golang:latest ENV GOPROXY https://goproxy.cn,direct WORKDIR $GOPATH /src/go-gin-example COPY . $GOPATH /src/go-gin-example RUN go build . EXPOSE 8000 ENTRYPOINT [ \"./go-gin-example\" ] FROM : 指定基础镜像, 该指令必须要有,且得为第一条 WORKDIR : 指定工作目录路径, 若目录不存在, 则会创建改目录 COPY : 源路径 ... 目标路径, COPY 指令将 Dockerfile 文件所存在的上下文目录 复制 到目标路径位置 RUN : 执行命令 EXPOSE : 声明 运行时容器 提供服务端口, 仅仅是一个 声明 , 不会因为这个声明而开启这个端口 ENTRYPOINT : 指定 容器 启动程序的及参数(执行 ./go-gin-example)","text_tokens":["第一条","workdir","是","direct","$","的","8000","这个","src","该","程序","gin","指定","dockerfile","命令","提供","上下文"," ","[","启动","latest","到","时","容器","得","from","若","为","cn","expose","一条","golang","第一","]","目录","(","声明","因为","而","gopath","必须","路径",",","copy","上下","改","存在","...","go","执行命令","build","-","复制","镜像",".","基础","创建","会","执行","且","不会","下文","服务","运行","及","文件","则","run","/","工作","不","位置","将","goproxy","\"","参数","指令","https","开启","仅仅","目标","端口",")","example","要","一个","entrypoint","有","所","env",":","源"],"title":"编写Dockerfile","title_tokens":["编写","dockerfile"]},{"location":"Golang/Project/09 Docker/#_1","text":"docker build - t gin - blog - docker . docker images docker run - p 8000 : 8000 gin - blog - docker 在 . 当前环境运行 docker build 创建/构建镜像, -t 指定名称 docker images 查看镜像是否创建成功 在本地8000端口运行容器 发现 dial tcp 127.0.0.1:3306: connect: connection refused 错误","text_tokens":["镜像",".","创建","查看","refused","成功","在","8000","容器","发现","127.0","p","运行","端口","是否","gin","指定","connect","3306","tcp","名称","run","错误","images"," ",",","docker","t","当前","dial","0.1","/","环境","构建","本地",":","connection","blog","build","-"],"title":"运行","title_tokens":["运行"]},{"location":"Golang/Project/09 Docker/#mysql-docker","text":"docker pull mysql docker run --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root -d mysql 拉取mysql镜像 配置mysql端口","text_tokens":["镜像","=","配置","p","e","端口","mysql","3306","password","name","run","拉取","pull"," ","root","docker","d",":","_","-"],"title":"配置Mysql Docker","title_tokens":["配置","mysql","docker"," "]},{"location":"Golang/Project/09 Docker/#confini","text":"[database] TYPE = mysql USER = root PASSWORD = rootroot HOST = mysql:3306 NAME = blog TABLE_PREFIX = blog_","text_tokens":["=","user","prefix","]","rootroot","type","mysql","3306","database","password","name","host"," ","root","table","[",":","_","blog"],"title":"修改配置文件conf.ini","title_tokens":["ini","conf",".","配置","配置文件","修改","文件"]},{"location":"Golang/Project/09 Docker/#golangmysql","text":"docker run --link mysql:mysql -p 8000:8000 gin-blog-docker","text_tokens":["p","8000","run","link"," ",":","docker","blog","mysql","-","gin"],"title":"关联Golang容器和Mysql容器","title_tokens":["关联","和","golang","容器","mysql"]},{"location":"Golang/Project/09 Docker/#_2","text":"","text_tokens":[],"title":"效果","title_tokens":["效果"]},{"location":"Golang/Project/10 GORM-Callback/","text":"go-gin-example 10： GORM-Callback 定制GORM Callbacks GORM Callback 是什么 You could define callback methods to pointer of model struct, it will be called when creating, updating, querying, deleting, if any callback returns an error, gorm will stop future operations and rollback all changes. 可以给模型结构体指针定义回调函数, 它将会在被创建/更新/查询/删除的时候调用, 如果回调返回了错误, gorm会停止未来行为操作并且回退所有改变. 之前程序未实现 Callback 方法, 需要为所有文件单独写一次 BeforeCreate 、 BeforeUpdate 方法 使用 gorm支持的callback方法 创建：BeforeSave、BeforeCreate、AfterCreate、AfterSave 更新：BeforeSave、BeforeUpdate、AfterUpdate、AfterSave 删除：BeforeDelete、AfterDelete 查询：AfterFind 定义callback 在 model.go 文件中定义 // updateTimeStampForCreateCallback will set `CreatedOn`, `ModifiedOn` when creating func updateTimeStampForCreateCallback ( scope * gorm . Scope ) { if ! scope . HasError () { nowTime := time . Now (). Unix () if createTimeField , ok := scope . FieldByName ( \"CreatedOn\" ); ok { if createTimeField . IsBlank { createTimeField . Set ( nowTime ) } } if modifyTimeField , ok := scope . FieldByName ( \"ModifiedOn\" ); ok { if modifyTimeField . IsBlank { modifyTimeField . Set ( nowTime ) } } } } // updateTimeStampForUpdateCallback will set `ModifyTime` when updating func updateTimeStampForUpdateCallback ( scope * gorm . Scope ) { if _ , ok := scope . Get ( \"gorm:update_column\" ); ! ok { scope . SetColumn ( \"ModifiedOn\" , time . Now (). Unix ()) } } 通过 scope.FieldByName(name) 判断是否存在相关字段, 该方法通过 scope.Fields() 获取所有字段 通过 .IsBlank 判断值是否为空 通过 .Set(interface{}) 设置相关值 通过 scope.Get() 获取参数的参数值, 案例中回去查找 gorm:update_column 这个字段的属性 通过 scope.SetColumn(Field, value) 设定字段的值 调用callback 在 model.go 的 ini 函数中注册callback db . Callback (). Create (). Replace ( \"gorm:update_time_stamp\" , updateTimeStampForCreateCallback ) db . Callback (). Update (). Replace ( \"gorm:update_time_stamp\" , updateTimeStampForUpdateCallback ) 效果 当程序写了 Callback 方法的时候, 当GORM执行到相关的操作会自动触发相应的 Callback 方法 拓展 软删除, 添加删除时间, 为 model.go 的 Model 结构体添加 DeletedOn 字段 type Model struct { ID int `gorm:\"primary_key\" json:\"id\"` CreatedOn int `json:\"created_on\"` ModifiedOn int `json:\"modified_on\"` DeletedOn int `json:\"deleted_on\"` } func deleteCallback ( scope * gorm . Scope ) { if ! scope . HasError () { var extraOption string if str , ok := scope . Get ( \"gorm:delete_option\" ); ok { extraOption = fmt . Sprint ( str ) } deletedOnField , hasDeletedOnField := scope . FieldByName ( \"DeletedOn\" ) if ! scope . Search . Unscoped && hasDeletedOnField { scope . Raw ( fmt . Sprintf ( \"UPDATE %v SET %v=%v%v%v\" , scope . QuotedTableName (), scope . Quote ( deletedOnField . DBName ), scope . AddToVars ( time . Now (). Unix ()), addExtraSpaceIfExist ( scope . CombinedConditionSql ()), addExtraSpaceIfExist ( extraOption ), )). Exec () } else { scope . Raw ( fmt . Sprintf ( \"DELETE FROM %v%v%v\" , scope . QuotedTableName (), addExtraSpaceIfExist ( scope . CombinedConditionSql ()), addExtraSpaceIfExist ( extraOption ), )). Exec () } } } func addExtraSpaceIfExist ( str string ) string { if str != \"\" { return \" \" + str } return \"\" } 在 model.go 的 ini函数 中添加 db.Callback().Delete().Replace(\"gorm:delete\", deleteCallback) 1. scope.QuotedTableName() 返回引用的表名 2. scope.Raw() 构建原生sql 3. fmt.Sprintf() 格式化并且返回格式化后的字符串数据 4. scope.AddToVars(value) 为字段添加参数 5. scope.Quote() 转义 6. scope 当你在数据库中文完成任何操作, scope包含了当前操作信息 // Scope contain current operation's information when you perform any operation on the database type Scope struct { Search * search Value interface {} SQL string SQLVars [] interface {} db * DB instanceID string primaryKeyField * Field skipLeft bool fields * [] * Field selectAttrs * [] string } REF: official: callback in gorm","text_tokens":["beforesave","设定","&&","1","createtimefield","deleted","haserror","option","sql","nowtime","是","creating","时候","自动","instanceid","an","格式化","查询","、","的","operations","raw","str","search","什么","信息","official","return","回去","这个","aftersave","unscoped","程序","该",";","addextraspaceifexist","转义","beforecreate","set","sprintf","gin","你","给","time","所有","返回","单独"," ","modifytimefield","update","通过","回调","为空","int","combinedconditionsql","[","created","包含","当前","*","selectattrs","aftercreate","stop","写","isblank","id","停止","sprint","相应","all","in","unix","create","_","到","数据库","ref","future","可以","数值","from","为","属性","回退","体","rollback","=","methods","结构","定制","%","格式","字符","else","returns","(","]","引用","will","当","未来","of","完成","get","方法","值","callbacks","表名","案例","contain","sqlvars","5","perform","是否","实现","任何","be","}","相关","database","错误","注册",",","setcolumn","delete","支持","10","afterdelete","db","afterupdate","它","scope","存在","行为","modified","model","and","获取","the","判断","指针","go","on","modifiedon","column","'","information","并且","stamp","-","字符串","operation","2","数据","一次","quote","when",".","string","hasdeletedonfield","创建","模型","会","操作","replace","执行","it","+","updatetimestampforupdatecallback","字","函数","deletedonfield","在","bool","参数值","deletecallback","var","updating","fields","primary","deleting","changes","type","文件","modifytime","后","中","func","：","name","key","/","需要","quotedtablename","gorm","if","error","3","beforedelete","json","段","afterfind","了","设置","更新","使用","current","ok","fmt","could","将","改变","now","createdon","\"","据库","4","define","updatetimestampforcreatecallback","fieldbyname","参数","查找","pointer","删除","如果","skipleft","any","ini","字段","拓展","效果","called","beforeupdate","field","querying","v","v%","原生","`","添加",")","调用","定义","struct","中文","s","example","callback","extraoption","被","you","addtovars","之前","exec","dbname","interface","deletedon","primarykeyfield","构建","{",":","时间","value","!","软","未","6","to","触发"],"title":"go-gin-example 10： GORM-Callback","title_tokens":["：","gorm","example","callback"," ","go","10","gin","-"]},{"location":"Golang/Project/10 GORM-Callback/#go-gin-example-10-gorm-callback","text":"","text_tokens":[],"title":"go-gin-example 10： GORM-Callback","title_tokens":["：","gorm","example","callback"," ","go","10","gin","-"]},{"location":"Golang/Project/10 GORM-Callback/#gorm-callbacks","text":"","text_tokens":[],"title":"定制GORM Callbacks","title_tokens":["gorm","callbacks","定制"," "]},{"location":"Golang/Project/10 GORM-Callback/#gorm-callback","text":"You could define callback methods to pointer of model struct, it will be called when creating, updating, querying, deleting, if any callback returns an error, gorm will stop future operations and rollback all changes. 可以给模型结构体指针定义回调函数, 它将会在被创建/更新/查询/删除的时候调用, 如果回调返回了错误, gorm会停止未来行为操作并且回退所有改变. 之前程序未实现 Callback 方法, 需要为所有文件单独写一次 BeforeCreate 、 BeforeUpdate 方法","text_tokens":["creating","时候","an","查询","、","的","operations","程序","beforecreate","给","所有","返回","单独"," ","回调","stop","写","停止","all","future","可以","为","回退","体","rollback","methods","结构","returns","will","未来","of","方法","实现","be","错误",",","它","行为","model","and","指针","并且","一次","when",".","创建","模型","会","操作","it","函数","在","updating","deleting","changes","文件","/","需要","gorm","if","error","了","更新","could","将","改变","define","pointer","删除","如果","any","called","beforeupdate","querying","调用","定义","struct","callback","被","you","之前","未","to"],"title":"GORM Callback 是什么","title_tokens":["什么","gorm","callback"," ","是"]},{"location":"Golang/Project/10 GORM-Callback/#_1","text":"","text_tokens":[],"title":"使用","title_tokens":["使用"]},{"location":"Golang/Project/10 GORM-Callback/#gormcallback","text":"创建：BeforeSave、BeforeCreate、AfterCreate、AfterSave 更新：BeforeSave、BeforeUpdate、AfterUpdate、AfterSave 删除：BeforeDelete、AfterDelete 查询：AfterFind","text_tokens":["aftercreate","beforesave","afterupdate","更新","：","beforeupdate","aftersave"," ","beforedelete","创建","beforecreate","afterdelete","afterfind","删除","查询","、"],"title":"gorm支持的callback方法","title_tokens":["的","gorm","callback","方法","支持"]},{"location":"Golang/Project/10 GORM-Callback/#callback","text":"在 model.go 文件中定义 // updateTimeStampForCreateCallback will set `CreatedOn`, `ModifiedOn` when creating func updateTimeStampForCreateCallback ( scope * gorm . Scope ) { if ! scope . HasError () { nowTime := time . Now (). Unix () if createTimeField , ok := scope . FieldByName ( \"CreatedOn\" ); ok { if createTimeField . IsBlank { createTimeField . Set ( nowTime ) } } if modifyTimeField , ok := scope . FieldByName ( \"ModifiedOn\" ); ok { if modifyTimeField . IsBlank { modifyTimeField . Set ( nowTime ) } } } } // updateTimeStampForUpdateCallback will set `ModifyTime` when updating func updateTimeStampForUpdateCallback ( scope * gorm . Scope ) { if _ , ok := scope . Get ( \"gorm:update_column\" ); ! ok { scope . SetColumn ( \"ModifiedOn\" , time . Now (). Unix ()) } } 通过 scope.FieldByName(name) 判断是否存在相关字段, 该方法通过 scope.Fields() 获取所有字段 通过 .IsBlank 判断值是否为空 通过 .Set(interface{}) 设置相关值 通过 scope.Get() 获取参数的参数值, 案例中回去查找 gorm:update_column 这个字段的属性 通过 scope.SetColumn(Field, value) 设定字段的值","text_tokens":["设定","createtimefield","haserror","nowtime","creating","的","回去","这个","该",";","set","time","所有","update"," ","modifytimefield","通过","为空","*","isblank","unix","_","数值","属性","=","(","will","get","方法","值","案例","是否","}","相关",",","setcolumn","scope","存在","model","获取","判断","go","modifiedon","column",".","when","updatetimestampforupdatecallback","字","在","参数值","updating","fields","文件","modifytime","中","func","name","/","gorm","if","段","设置","ok","now","createdon","\"","updatetimestampforcreatecallback","fieldbyname","查找","参数","字段","field","`",")","定义","interface","{",":","value","!"],"title":"定义callback","title_tokens":["callback","定义"]},{"location":"Golang/Project/10 GORM-Callback/#callback_1","text":"在 model.go 的 ini 函数中注册callback db . Callback (). Create (). Replace ( \"gorm:update_time_stamp\" , updateTimeStampForCreateCallback ) db . Callback (). Update (). Replace ( \"gorm:update_time_stamp\" , updateTimeStampForUpdateCallback )","text_tokens":[".","\"","updatetimestampforcreatecallback","replace","updatetimestampforupdatecallback","的","函数","(","在","ini","time",")","中","callback","注册","update"," ",",","db","gorm","model",":","go","create","_","stamp"],"title":"调用callback","title_tokens":["调用","callback"]},{"location":"Golang/Project/10 GORM-Callback/#_2","text":"当程序写了 Callback 方法的时候, 当GORM执行到相关的操作会自动触发相应的 Callback 方法","text_tokens":["了","时候","操作","执行","会","自动","的","当","方法","程序","相关","callback",","," ","写","gorm","相应","到","触发"],"title":"效果","title_tokens":["效果"]},{"location":"Golang/Project/10 GORM-Callback/#_3","text":"软删除, 添加删除时间, 为 model.go 的 Model 结构体添加 DeletedOn 字段 type Model struct { ID int `gorm:\"primary_key\" json:\"id\"` CreatedOn int `json:\"created_on\"` ModifiedOn int `json:\"modified_on\"` DeletedOn int `json:\"deleted_on\"` } func deleteCallback ( scope * gorm . Scope ) { if ! scope . HasError () { var extraOption string if str , ok := scope . Get ( \"gorm:delete_option\" ); ok { extraOption = fmt . Sprint ( str ) } deletedOnField , hasDeletedOnField := scope . FieldByName ( \"DeletedOn\" ) if ! scope . Search . Unscoped && hasDeletedOnField { scope . Raw ( fmt . Sprintf ( \"UPDATE %v SET %v=%v%v%v\" , scope . QuotedTableName (), scope . Quote ( deletedOnField . DBName ), scope . AddToVars ( time . Now (). Unix ()), addExtraSpaceIfExist ( scope . CombinedConditionSql ()), addExtraSpaceIfExist ( extraOption ), )). Exec () } else { scope . Raw ( fmt . Sprintf ( \"DELETE FROM %v%v%v\" , scope . QuotedTableName (), addExtraSpaceIfExist ( scope . CombinedConditionSql ()), addExtraSpaceIfExist ( extraOption ), )). Exec () } } } func addExtraSpaceIfExist ( str string ) string { if str != \"\" { return \" \" + str } return \"\" } 在 model.go 的 ini函数 中添加 db.Callback().Delete().Replace(\"gorm:delete\", deleteCallback) 1. scope.QuotedTableName() 返回引用的表名 2. scope.Raw() 构建原生sql 3. fmt.Sprintf() 格式化并且返回格式化后的字符串数据 4. scope.AddToVars(value) 为字段添加参数 5. scope.Quote() 转义 6. scope 当你在数据库中文完成任何操作, scope包含了当前操作信息 // Scope contain current operation's information when you perform any operation on the database type Scope struct { Search * search Value interface {} SQL string SQLVars [] interface {} db * DB instanceID string primaryKeyField * Field skipLeft bool fields * [] * Field selectAttrs * [] string }","text_tokens":["1","&&","deleted","haserror","option","sql","instanceid","格式化","的","raw","str","search","信息","return","unscoped",";","addextraspaceifexist","转义","set","sprintf","你","time","返回","update"," ","bool","combinedconditionsql","int","[","created","包含","当前","*","selectattrs","id","sprint","unix","数据库","_","from","为","体","=","结构","%","格式","字符","else","]","(","引用","当","完成","get","表名","contain","sqlvars","5","perform","任何","}","database",",","delete","db","scope","modified","model","the","information","go","on","modifiedon","'","并且","字符串","operation","2","数据","quote",".","string","hasdeletedonfield","when","+","操作","replace","字","函数","deletedonfield","在","deletecallback","var","primary","fields","type","后","中","func","key","/","quotedtablename","gorm","if","3","json","段","了","current","ok","fmt","now","createdon","\"","据库","4","fieldbyname","参数","删除","any","ini","field","v","v%","原生","`","添加",")","struct","中文","s","extraoption","callback","addtovars","you","exec","dbname","interface","deletedon","primarykeyfield","构建","{","时间",":","value","软","!","6","skipleft"],"title":"拓展","title_tokens":["拓展"]},{"location":"Golang/Project/10 GORM-Callback/#ref","text":"official: callback in gorm","text_tokens":["official","gorm","callback"," ",":","in"],"title":"REF:","title_tokens":["ref",":"]},{"location":"Golang/Project/FlowChart/","text":"流程图 请求流程图 URL 请求打到 gin ，由 gin 分发各个请求到相应的接口 接口对应 GET ， POST ， PUT ， DELETE 等多种请求方式 接口接收 URL 中的参数，构造相应的CRUD查询，查询数据库 将数据库返回的数据返回到前端调用者 JWT产生以及认证 生成JWT JWT认证","text_tokens":["jwt","产生","数据","生成","流程图","由","将","多种","据库","流程","参数","查询","的","接口","构造","用者","分发","查询数据库","get","post","对应","前端","url","gin","调用","打","中","方式","，","以及","返回","put"," ","delete","等","接收","crud","调用者","相应","数据库","各个","到","认证","请求"],"title":"流程图","title_tokens":["流程","流程图"]},{"location":"Golang/Project/FlowChart/#_1","text":"","text_tokens":[],"title":"流程图","title_tokens":["流程","流程图"]},{"location":"Golang/Project/FlowChart/#_2","text":"URL 请求打到 gin ，由 gin 分发各个请求到相应的接口 接口对应 GET ， POST ， PUT ， DELETE 等多种请求方式 接口接收 URL 中的参数，构造相应的CRUD查询，查询数据库 将数据库返回的数据返回到前端调用者","text_tokens":["数据","将","由","多种","据库","参数","查询","的","接口","构造","用者","分发","查询数据库","get","post","对应","前端","url","gin","调用","打","中","方式","，","返回","put"," ","delete","等","接收","crud","调用者","相应","数据库","各个","到","请求"],"title":"请求流程图","title_tokens":["请求","流程","流程图"]},{"location":"Golang/Project/FlowChart/#jwt","text":"生成JWT JWT认证","text_tokens":["jwt","认证"," ","生成"],"title":"JWT产生以及认证","title_tokens":["jwt","以及","产生","认证"]},{"location":"Golang/Project/InterfaceTestInstance/","text":"接口测试实例","text_tokens":["接口","测试","实例"],"title":"接口测试实例","title_tokens":["接口","测试","实例"]},{"location":"Golang/Project/InterfaceTestInstance/#_1","text":"","text_tokens":[],"title":"接口测试实例","title_tokens":["接口","测试","实例"]},{"location":"Linux/changeSources/","text":"Linux02: 更改Ubuntu源 备份源文件 添加源 更新 sudo cp /etc/apt/sources.list /etc/apt/sources_init.list sudo gedit /etc/apt/sources.list apt-get update","text_tokens":["更新","apt","sources","备份",".","etc","list","ubuntu","get","文件","添加","cp","update"," ","linux02","init","更改","/","sudo","源文件","gedit",":","源","_","-"],"title":"Linux02: 更改Ubuntu源","title_tokens":["ubuntu"," ","linux02",":","源","更改"]},{"location":"Linux/changeSources/#linux02-ubuntu","text":"备份源文件 添加源 更新 sudo cp /etc/apt/sources.list /etc/apt/sources_init.list sudo gedit /etc/apt/sources.list apt-get update","text_tokens":["更新","apt","sources","备份",".","etc","list","get","文件","添加","cp","update"," ","init","/","sudo","源文件","gedit","源","_","-"],"title":"Linux02: 更改Ubuntu源","title_tokens":["ubuntu"," ","linux02",":","源","更改"]},{"location":"Linux/formattingUdisk/","text":"Linux01: 彻底格式化U盘 在 cmd 下输入 diskpart 在弹出的窗口输出 list disk 选择目标磁盘 select disk 1 清除 clean","text_tokens":["1","输出","弹出","彻底","u盘","clean","格式","格式化","diskpart","的","在","disk","输入","list","下","窗口","清除","目标","linux01"," ","select","cmd","选择",":","磁盘"],"title":"Linux01: 彻底格式化U盘","title_tokens":["linux01","彻底","u盘",":"," ","格式","格式化"]},{"location":"Linux/formattingUdisk/#linux01-u","text":"在 cmd 下输入 diskpart 在弹出的窗口输出 list disk 选择目标磁盘 select disk 1 清除 clean","text_tokens":["1","输出","弹出","clean","diskpart","的","在","disk","输入","list","下","窗口","清除","目标"," ","select","cmd","选择","磁盘"],"title":"Linux01: 彻底格式化U盘","title_tokens":["linux01","彻底","u盘",":"," ","格式","格式化"]}]}