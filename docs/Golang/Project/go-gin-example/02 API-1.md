# go-gin-example 02：API-1


+ 初始设置

## 项目目录

```shell
go-gin-example/
├─conf
├─middleware
├─models
├─pkg
├─routers
└─runtime
```

- conf：用于存储配置文件
- middleware：应用中间件
- models：应用数据库模型
- pkg：第三方包
- routers：路由逻辑处理
- runtime：应用运行时数据

## 添加Go Modules Replace配置本地模块路径 （好像不必要）

```plaintext
module go-gin-example

go 1.12

require (···)

replace (
	./go-gin-example/conf => ./go-gin-example/pkg/conf
	./go-gin-example/middleware => ./go-gin-example/middleware
	./go-gin-example/models => ./go-gin-example/models
	./go-gin-example/pkg/e => ./go-gin-example/pkg/e
	./go-gin-example/pkg/setting => ./go-gin-example/pkg/setting
	./go-gin-example/pkg/util => ./go-gin-example/pkg/util
	./go-gin-example/routers => ./go-gin-example/routers
)
# 用 replace 将其指定读取本地的模块路径，这样子就可以解决本地模块读取的问题
```

## 使用ini配置文件库/编写项目配置包


### 应用配置文件

> 将公共配置部分提取出来，写成专门的配置文件，统一写数据库环境、服务器环境等。

+ 在`./conf`目录下新建`app.ini`文件

+ 定义RUN_MODE

- 定义数据库端口、账号、表格等
- 定义公共参数：分页
- 定义服务器端口、TIMEOUT时间等

```ini
# debug or release
RUN_MODE = debug

[app]
PAGE_SIZE = 10
JWT_SECRET = 23347$040412

[server]
HTTP_PORT = 8000
READ_TIMEOUT = 60
WRITE_TIMEOUT = 60

[database]
TYPE = mysql
USER = root # 数据库账号
PASSWORD = root # 数据库密码
HOST = 127.0.0.1:3306 # 数据库IP:数据库端口号
NAME = blog
TABLE_PREFIX = blog_
```

### 调用配置的setting模块

> 负责调用app.ini

+ `go get -u github.com/go-ini/ini`
+ 在`./pkg/setting`目录下新建`setting.go`文件

```go
package setting

import (
	"log"
	"time"

	"github.com/go-ini/ini"
)

var (
	Cfg *ini.File // Cfg为ini文件类型

  	   // 声明app.ini文件写好的各种配置的类型
	RunMode string	

	HTTPPort     int
	ReadTimeout  time.Duration
	WriteTimeout time.Duration

	PageSize  int
	JwtSecret string
)

func init() {
	var err error
	// 加载初始化文件
	Cfg, err = ini.Load("conf/app.ini")
	if err != nil {
		log.Fatalf("Fail to parse 'conf/app.ini`: %v", err)
	}
	LoadBase()
	LoadServer()
	LoadApp()
}

// 加载基础设置
func LoadBase() {
	// 设置RUN_MODE为'debug'
	RunMode = Cfg.Section("").Key("RUN_MODE").MustString("debug")
}

// LoadServer 加载服务器配置
func LoadServer() {
	// 获取'server'的section信息
    // 这里的section包含'server'的各种信息, 由./config/app,ini配置文件提供
	sec, err := Cfg.GetSection("server")
	if err != nil {
		log.Fatalf("Fail to get section 'server':%v", err)
	}
	RunMode = Cfg.Section("").Key("RUN_MODE").MustString("debug")
	// 自动类型转换
	HTTPPort = sec.Key("HTTP_PORT").MustInt(8000)
	ReadTimeout = time.Duration(sec.Key("READ_TIMEOUT").MustInt(60)) * time.Second
	WriteTimeout = time.Duration(sec.Key("WRITE_TIMEOUT").MustInt(60)) * time.Second
}

// LoadApp 加载APP配置
func LoadApp() {
    // 获取./config/app.ini配置文件的APP配置
	sec, err := Cfg.GetSection("app")
	if err != nil {
		log.Fatalf("Fail to get section 'app':%v", err)
	}

	JwtSecret = sec.Key("JWT_SECRET").MustString("!@)*#)!@U#@*!@!)")
	PageSize = sec.Key("PAGE_SIZE").MustInt(10)
}

```

### API错误码包

> 建立错误码e模块

+ 在`./pkg/e`目录下新建`code.go`和`msg.go`文件

+ code.go

```go
package e 

// API错误代码
const (
	SUCCESS        = 200
	ERROR          = 500
	INVALID_PARAMS = 400

	ERROR_EXIST_TAG         = 10001
	ERROR_NOT_EXIST_TAG     = 10002
	ERROR_NOT_EXIST_ARTICLE = 10003

	ERROR_AUTH_CHECK_TOKEN_FAIL    = 20001
	ERROR_AUTH_CHECK_TOKEN_TIMEOUT = 20002
	ERROR_AUTH_TOKEN               = 20003
	ERROR_AUTH                     = 20004
)
```

+ msg.go

```go
package e
//msg.go

// MsgFlags 错误信息
var MsgFlags = map[int]string{
	SUCCESS:                        "ok",
	ERROR:                          "fail",
	INVALID_PARAMS:                 "请求参数错误",
	ERROR_EXIST_TAG:                "已存在该标签名称",
	ERROR_NOT_EXIST_TAG:            "该标签不存在",
	ERROR_NOT_EXIST_ARTICLE:        "该文章不存在",
	ERROR_AUTH_CHECK_TOKEN_FAIL:    "Token鉴权失败",
	ERROR_AUTH_CHECK_TOKEN_TIMEOUT: "Token鉴权超时",
	ERROR_AUTH_TOKEN:               "Token生成失败",
	ERROR_AUTH:                     "Token错误",
}

// GetMsg 获取错误信息
func GetMsg(code int) string {
	msg, ok := MsgFlags[code]
	if ok {
		return msg
	}
	return MsgFlags[ERROR]
}

```

### 工具包

> 公共方法：例如获取分页页码等

+ `go get -u github.com/unknwon/com`
+ 在`./pkg/util`目录下新建`pagination.go`文件

```GO
package util

import (
	setting "go-gin-example/pkg/settings"

	"github.com/gin-gonic/gin"
	"github.com/unknwon/com"
)

// GetPage 获取page数量
func GetPage(c *gin.Context) int {
	result := 0
	// page转换为int
	page, _ := com.StrTo(c.Query("page")).Int()
	if page > 0 {
		result = (page - 1) * setting.PageSize
	}
    return result
}
```

### 数据库模型映射

> 通过gorm将golang结构体映射到数据库中自动生成模型

+ `go get -u github.com/jinzhu/gorm`
+ `go get -u github.com/go-sql-driver/mysql`
+ 在`./models`目录下新建`models.go`文件。

```GO
package models

import (
	"fmt"
	setting "go-gin-example/pkg/settings"
	"log"

	"github.com/jinzhu/gorm"
)

var db *gorm.DB

// Model 数据库模型
type Model struct {
	ID         int `gorm:"primary_key" json:id`
	CreatedOn  int `json:"created_on"`
	ModifiedOn int `json:"modified_on"`
}

func init() {
	var (
		err                                               error
		dbType, dbName, user, password, host, tablePrefix string
	)
	// 获取配置文件的数据库配置
	sec, err := setting.Cfg.GetSection("database")
	if err != nil {
		log.Fatal(2, "Fail to get get scetion `database`:%v", err)
	}
	
	dbType = sec.Key("TYPE").String()
	dbName = sec.Key("NAME").String()
	user = sec.Key("USER").String()
	password = sec.Key("PASSWORD").String()
	host = sec.Key("HOST").String()
	tablePrefix = sec.Key("TABLE_PREFIX").String()

	db, err = gorm.Open(dbtype, fmt.Sprintf("%s:%s@tcp(%s)/%s?charset=utf8&parseTime=True&loc=Local",
		user,
		password,
		dbName))

	if err != nil {
		log.Println(err)
	}

	gorm.DefaultTableNameHandler = func(db *gorm.DB, defaultTableName string) string {
		return tablePrefix + defaultTableName
	}

	db.SingularTable(true)
	db.LogMode(true)
	db.DB().SetMaxIdleConns(10)
	db.DB().SetMaxOpenConns(100)
}

// CloseDB 关闭数据库连接
func CloseDB() {
	defer db.Close()
}

```

## Demo

> 实例程序

+ 在`./`目录下新建`main.go`文件

```GO
package main

import (
	"fmt"
	setting "go-gin-example/pkg/settings"
	"net/http"

	"github.com/gin-gonic/gin"
)

func main() {
	router := gin.Default()
	router.GET("/test", func(c *gin.Context) {
		c.JSON(200, gin.H{
			"message": "test",
		})
	})

	s := &http.Server{
		Addr:           fmt.Sprintf(":%d", setting.HTTPPort),
		Handler:        router,
		ReadTimeout:    setting.ReadTimeout,
		WriteTimeout:   setting.WriteTimeout,
		MaxHeaderBytes: 1 << 20,
	}
	// 调用在&http.Server中设置的参数,因此上面要用&,要改变参数的值
	s.ListenAndServe()
}
```

+ 浏览器输入`localhost：8000/test`返回`{"message":"test"}`则成功

## 从main.go中分离路由

+  在`./routers`目录下新建`router.go`文件

```go
package routers

import (
	setting "go-gin-example/pkg/settings"

	"github.com/gin-gonic/gin"
)

func InitRouter() *gin.Engine {
	r := gin.New()

	r.Use(gin.Logger())
	r.Use(gin.Recovery())

	gin.SetMode(setting.RunMode)

	r.GET("/test", func(c *gin.Context) {
		c.JSON(200, gin.H{
			"message": "test",
		})
	})

	return r
}
```

+ 修改`main.go`文件

```go
package main

import (
	"fmt"
	setting "go-gin-example/pkg/settings"
	"go-gin-example/routers"
	"net/http"
)

func main() {
	router := routers.InitRouter()

	s := &http.Server{
		Addr:           fmt.Sprintf(":%d", setting.HTTPPort),
		Handler:        router,
		ReadTimeout:    setting.ReadTimeout,
		WriteTimeout:   setting.WriteTimeout,
		MaxHeaderBytes: 1 << 20,
	}

	s.ListenAndServer()
}
```

## 当前目录结构

```shell
go-gin-example/
├── conf
│   └── app.ini
├── main.go
├── middleware
├── models
│   └── models.go
├── pkg
│   ├── e
│   │   ├── code.go
│   │   └── msg.go
│   ├── setting
│   │   └── setting.go
│   └── util
│       └── pagination.go
├── routers
│   └── router.go
├── runtime
```



